diff -urN TC4_uboot/board/samsung/smdkc210/lowlevel_init_POP.S iTop4412_uboot/board/samsung/smdkc210/lowlevel_init_POP.S
--- TC4_uboot/board/samsung/smdkc210/lowlevel_init_POP.S	1969-12-31 16:00:00.000000000 -0800
+++ iTop4412_uboot/board/samsung/smdkc210/lowlevel_init_POP.S	2015-11-09 00:59:35.000000000 -0800
@@ -0,0 +1,835 @@
+/*
+ * Memory Setup stuff - taken from blob memsetup.S
+ *
+ * Copyright (C) 1999 2000 2001 Erik Mouw (J.A.K.Mouw@its.tudelft.nl) and
+ *                     Jan-Derk Bakker (J.D.Bakker@its.tudelft.nl)
+ *
+ * Modified for the Samsung SMDK2410 by
+ * (C) Copyright 2002
+ * David Mueller, ELSOFT AG, <d.mueller@elsoft.ch>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+#include <config.h>
+#include <version.h>
+
+#include <s5pc210.h>
+#include "smdk4x12_val.h" //mj
+
+#define check_mem
+#define MEM_DLLl_ON
+
+_TEXT_BASE:
+	.word	TEXT_BASE
+
+	.globl lowlevel_init
+lowlevel_init:
+#if 1//*****ly
+	/* use iROM stack in bl2 */
+	ldr	sp, =0x02060000
+#endif
+	push	{lr}
+
+	/* check reset status  */
+	ldr     r0, =(INF_REG_BASE + INF_REG1_OFFSET)
+        ldr     r1, [r0]
+
+	/* AFTR wakeup reset */
+	ldr	r2, =S5P_CHECK_DIDLE
+	cmp	r1, r2
+	beq	exit_wakeup
+
+	/* Sleep wakeup reset */
+	ldr	r2, =S5P_CHECK_SLEEP
+	cmp	r1, r2
+	beq	wakeup_reset
+
+        /* PS-Hold high */
+        ldr r0, =0x1002330c
+        ldr r1, [r0]
+        orr r1, r1, #0x300
+        str r1, [r0]
+
+        ldr     r0, =0x11000c08
+        ldr r1, =0x0
+        str r1, [r0]
+
+        /* Clear  MASK_WDT_RESET_REQUEST  */
+        ldr r0, =0x1002040c
+        ldr r1, =0x00
+        str r1, [r0]
+        
+#ifdef check_mem /*liyang 20110822*/
+	/* when we already run in ram, we don't need to relocate U-Boot.
+	 * and actually, memory controller must be configured before U-Boot
+	 * is running in ram.
+	 */
+	ldr	r0, =0xff000fff
+	bic	r1, pc, r0		/* r0 <- current base addr of code */
+	ldr	r2, _TEXT_BASE		/* r1 <- original base addr in ram */
+	bic	r2, r2, r0		/* r0 <- current base addr of code */
+	cmp     r1, r2                  /* compare r0, r1                  */
+	beq     1f			/* r0 == r1 then skip sdram init   */
+#endif
+
+/*	liyang 20110822
+	
+	ldr	r0, =CHIP_ID_BASE
+	ldr	r1, [r0]
+	lsr	r1, r1, #8
+	and	r1, r1, #3
+	cmp	r1, #2
+	bne v310_1
+
+*/
+
+	/* Memory initialize */
+	bl mem_ctrl_asm_init
+
+
+	/* init system clock */
+	bl system_clock_init
+
+
+	bl tzpc_init
+	
+	b	1f
+
+v310_1:
+	/* init system clock */
+	bl	system_clock_init
+
+	/* Memory initialize	*/
+	bl	mem_ctrl_asm_init
+
+1:
+
+#ifdef CONFIG_EVT1___
+	/* store DMC density information in DRAM */
+	/* mem_ctrl_asm_init returns dmc_density in r6 */
+	ldr	r0, =CFG_UBOOT_BASE
+	sub	r0, r0, #4
+	str	r6, [r0]
+#endif
+	/*wenpin.cui: headphone and sw uart switch init*/
+	ldr	r0, =0x11000C44
+	ldr	r1, [r0]
+	and	r1, r1, #0x4 	
+	cmp	r1, #0x4	/*uart*/	
+	beq	out	
+
+	ldr     r0, =0x11400084  /* GPC1(0)  */
+	ldr     r1, [r0]	/* read GPC1DAT status*/
+	orr	r1, r1, #0x1	/* GPC1(0) output high  */
+	str     r1, [r0]
+
+	ldr     r0, =0x11400080  /* GPC1(0)  */
+	ldr	r1, [r0]
+	and	r1, r1, #0xfffffff0
+	orr     r1, r1, #0x1	/* GPC1(0) output  */
+	str     r1, [r0]
+out:
+	/* for UART */
+	bl uart_asm_init
+
+       
+
+#if defined(CONFIG_ONENAND)
+	bl onenandcon_init
+#endif
+
+#if defined(CONFIG_NAND)
+	/* simple init for NAND */
+	bl nand_asm_init
+#endif
+
+	/* Print 'K' */
+	ldr	r0, =ELFIN_UART_CONSOLE_BASE
+	ldr	r1, =0x4b4b4b4b
+	str	r1, [r0, #UTXH_OFFSET]
+
+	/* 2010.08.27 by icarus : for temporary 3D clock fix */
+	ldr	r1, =0x1
+	ldr	r2, =0x1003C22C
+	str	r1, [r2]
+	ldr	r1, =0x2
+	ldr	r2, =0x1003C52C
+	str	r1, [r2]
+
+	/* 2010.10.17 by icarus : for temporary MFC clock fix */
+	ldr	r1, =0x3
+	ldr	r2, =0x1003C528
+	str	r1, [r2]
+
+	pop	{pc}
+
+wakeup_reset:
+	ldr	r0, =CHIP_ID_BASE
+	ldr	r1, [r0]
+	lsr	r1, r1, #8
+	and	r1, r1, #3
+	cmp	r1, #2
+	bne	wake_v310
+	
+	//mj 
+	/* check C2C_CTRL enable bit */
+	ldr r3, =SYSC_PMU_BASE
+	ldr r1, [r3, #C2C_CTRL_OFFSET]
+	and r1, r1, #1
+	cmp r1, #0
+	bne skip_dmc
+	
+	/* init system clock */
+	bl	mem_ctrl_asm_init
+skip_dmc:
+	bl	system_clock_init
+	bl	tzpc_init
+	b	exit_wakeup
+
+wake_v310:
+	bl system_clock_init
+	bl mem_ctrl_asm_init
+	bl tzpc_init
+
+exit_wakeup:
+	/*Load return address and jump to kernel*/
+	ldr	r0, =(INF_REG_BASE+INF_REG0_OFFSET)
+	ldr	r1, [r0]	/* r1 = physical address of s5pc110_cpu_resume function*/
+
+	mov	pc, r1		/*Jump to kernel */
+	nop
+	nop
+
+/*
+ * system_clock_init: Initialize core clock and bus clock.
+ * void system_clock_init(void)
+ */
+system_clock_init:
+	push	{lr}
+	
+	ldr	r0, =CMU_BASE	@0x1003_0000
+
+@ CMU_CPU MUX / DIV
+	ldr	r1, =0x0
+	ldr	r2, =CLK_SRC_CPU_OFFSET
+	str	r1, [r0, r2]
+
+	/* wait ?us */
+	mov	r1, #0x10000
+1:	subs	r1, r1, #1
+	bne	1b
+/* liyang removed it
+	ldr	r1, =CLK_DIV_CPU0_VAL
+	ldr	r2, =CLK_DIV_CPU0_OFFSET
+	str	r1, [r0, r2]
+	ldr	r1, =CLK_DIV_CPU1_VAL
+	ldr	r2, =CLK_DIV_CPU1_OFFSET
+	str	r1, [r0, r2]
+
+*/
+@ CMU_DMC MUX / DIV
+#ifdef CONFIG_EVT1
+	ldr	r1, =0x10000
+#else
+	ldr	r1, =CLK_SRC_DMC_VAL
+#endif
+	ldr	r2, =CLK_SRC_DMC_OFFSET
+	str	r1, [r0, r2]
+
+	/* wait ?us */
+	mov	r1, #0x10000
+2:	subs	r1, r1, #1
+	bne	2b
+
+	ldr	r1, =0x00111113//CLK_DIV_DMC0_VAL
+	ldr	r2, =CLK_DIV_DMC0_OFFSET
+	str	r1, [r0, r2]
+	ldr	r1, =0x00551113//CLK_DIV_DMC1_VAL
+	ldr	r2, =CLK_DIV_DMC1_OFFSET
+	str	r1, [r0, r2]
+
+	ldr	r1, =0x01010100
+	ldr	r2, =CLK_DIV_DMC1_OFFSET
+	str	r1, [r0, r2]
+	
+///////////////////////////////////////////////
+@ CMU_TOP MUX / DIV
+	ldr	r1, =0x0//CLK_SRC_TOP0_VAL
+	ldr	r2, =CLK_SRC_TOP0_OFFSET
+	str	r1, [r0, r2]
+	ldr	r1, =0x0//CLK_SRC_TOP1_VAL
+	ldr	r2, =CLK_SRC_TOP1_OFFSET
+	str	r1, [r0, r2]
+
+	/* wait ?us */
+	mov	r1, #0x10000
+3:	subs	r1, r1, #1
+	bne	3b
+
+	ldr	r1, =0x01315474//for ISP,ACLK_200,ACLK_400_MCUISP,0x03315473//CLK_DIV_TOP_VAL
+	ldr	r2, =CLK_DIV_TOP_OFFSET
+	str	r1, [r0, r2]
+
+@ CMU_LEFTBUS MUX / DIV
+	ldr	r1, =0x10//CLK_SRC_LEFTBUS_VAL
+	ldr	r2, =CLK_SRC_LEFTBUS_OFFSET
+	str	r1, [r0, r2]
+
+	/* wait ?us */
+	mov	r1, #0x10000
+4:	subs	r1, r1, #1
+	bne	4b
+
+	ldr	r1, =0x00000013//CLK_DIV_LEFRBUS_VAL
+	ldr	r2, =CLK_DIV_LEFTBUS_OFFSET
+	str	r1, [r0, r2]
+
+@ CMU_RIGHTBUS MUX / DIV
+	ldr	r1, =0x10//CLK_SRC_RIGHTBUS_VAL
+	ldr	r2, =CLK_SRC_RIGHTBUS_OFFSET
+	str	r1, [r0, r2]
+
+	/* wait ?us */
+	mov	r1, #0x10000
+5:	subs	r1, r1, #1
+	bne	5b
+
+	ldr	r1, =0x00000013//CLK_DIV_RIGHTBUS_VAL
+	ldr	r2, =CLK_DIV_RIGHTBUS_OFFSET
+	str	r1, [r0, r2]
+
+@ Set PLL locktime
+	ldr	r1, =APLL_LOCK_VAL
+	ldr	r2, =APLL_LOCK_OFFSET
+	str	r1, [r0, r2]
+	ldr	r1, =MPLL_LOCK_VAL
+	ldr	r2, =MPLL_LOCK_OFFSET
+	str	r1, [r0, r2]
+	ldr	r1, =EPLL_LOCK_VAL
+	ldr	r2, =EPLL_LOCK_OFFSET
+	str	r1, [r0, r2]
+	ldr	r1, =VPLL_LOCK_VAL
+	ldr	r2, =VPLL_LOCK_OFFSET
+	str	r1, [r0, r2]
+
+	
+
+	ldr	r1, =CLK_DIV_CPU0_VAL
+	ldr	r2, =CLK_DIV_CPU0_OFFSET
+	str	r1, [r0, r2]
+	ldr	r1, =CLK_DIV_CPU1_VAL
+	ldr	r2, =CLK_DIV_CPU1_OFFSET
+	str	r1, [r0, r2]
+
+
+	  
+@ Set PLL P,M,S ON
+@ Set APLL
+	ldr	r1, =APLL_CON1_VAL
+	ldr	r2, =APLL_CON1_OFFSET
+	str	r1, [r0, r2]
+
+	ldr	r1, =APLL_CON0_VAL
+	ldr	r2, =APLL_CON0_OFFSET
+	str	r1, [r0, r2]
+
+@ Set MPLL//liyang
+	ldr	r1, =MPLL_CON1_VAL
+	ldr	r2, =MPLL_CON1_OFFSET
+	str	r1, [r0, r2]
+	ldr	r1, =MPLL_CON0_VAL
+	ldr	r2, =MPLL_CON0_OFFSET
+	str	r1, [r0, r2]
+
+@ Set EPLL//liyang
+	ldr	r1, =EPLL_CON2_VAL
+	ldr	r2, =EPLL_CON2_OFFSET
+	str	r1, [r0, r2]
+	ldr	r1, =EPLL_CON1_VAL
+	ldr	r2, =EPLL_CON1_OFFSET
+	str	r1, [r0, r2]
+	ldr	r1, =EPLL_CON0_VAL
+	ldr	r2, =EPLL_CON0_OFFSET
+	str	r1, [r0, r2]
+
+@ Set VPLL//liyang
+	ldr	r1, =VPLL_CON2_VAL
+	ldr	r2, =VPLL_CON2_OFFSET
+	str	r1, [r0, r2]
+	ldr	r1, =VPLL_CON1_VAL
+	ldr	r2, =VPLL_CON1_OFFSET
+	str	r1, [r0, r2]
+	ldr	r1, =VPLL_CON0_VAL
+	ldr	r2, =VPLL_CON0_OFFSET
+	str	r1, [r0, r2]
+
+	/* wait ?us */
+	mov	r1, #0x30000
+6:	subs	r1, r1, #1
+	bne	6b
+
+	ldr	r1, =CLK_SRC_CPU_VAL_MOUTMPLLFOUT
+	ldr	r2, =CLK_SRC_CPU_OFFSET
+	str	r1, [r0, r2]
+
+
+
+
+	//d.s SD:0x10040200 %LE %LONG 0x00111000 ;CLK_SRC_DMC	MUX_MPLL out => PLL out, DMC & C2C
+	//d.s SD:0x10040504 %LE %LONG 0x01011171 ;CLK_SRC_DMC1
+	//d.s SD:0x1003C210 %LE %LONG 0x00000110 ;CLK_SRC_TOP0	MUX_E/VPLL out => PLL out, BUS(Main BUS)
+	//d.s SD:0x1003C214 %LE %LONG 0x01101000 ;CLK_SRC_TOP1	BUS(ISP,GPS)
+
+
+	ldr	r1, =0x00111000//CLK_SRC_CPU_VAL_MOUTMPLLFOUT
+	ldr	r2, =0x10040200
+	str	r1, [r2]
+
+	
+	ldr	r1, =0x01011171//CLK_SRC_CPU_VAL_MOUTMPLLFOUT
+	ldr	r2, =0x10040504
+	str	r1, [r2]
+
+		
+	ldr	r1, =0x00000110//CLK_SRC_CPU_VAL_MOUTMPLLFOUT
+	ldr	r2, =0x1003C210
+	str	r1, [r2]
+
+	ldr	r1, =0x01101000//CLK_SRC_CPU_VAL_MOUTMPLLFOUT
+	ldr	r2, =0x1003C214
+	str	r1, [r2]
+	
+	
+	/* wait ?us */
+	mov	r1, #0x10000
+7:	subs	r1, r1, #1
+	bne	7b
+	//d.s SD:0x1003C52C %LE %LONG 0x00000003 ;CLK_DIV_G3D  
+	//d.s SD:0x1003C22C %LE %LONG 0x00000000 ;CLK_SRC_G3D	SCLKMPLL
+
+	//d.s SD:0x1003C528 %LE %LONG 0x00000003 ;CLK_DIV_MFC  
+	//d.s SD:0x1003C228 %LE %LONG 0x00000000 ;CLK_SRC_G3D	SCLKMPLL	
+
+
+	ldr	r1, =0x00000003//CLK_SRC_CPU_VAL_MOUTMPLLFOUT
+	ldr	r2, =0x1003C52C
+	str	r1, [r2]
+
+	
+	ldr	r1, =0x00000000//CLK_SRC_CPU_VAL_MOUTMPLLFOUT
+	ldr	r2, =0x1003C22C
+	str	r1, [r2]
+
+		
+	ldr	r1, =0x00000003//CLK_SRC_CPU_VAL_MOUTMPLLFOUT
+	ldr	r2, =0x1003C528
+	str	r1, [r2]
+
+	ldr	r1, =0x00000000//CLK_SRC_CPU_VAL_MOUTMPLLFOUT
+	ldr	r2, =0x1003C228
+	str	r1, [r2]
+
+
+
+
+
+/* liyang removed
+	ldr	r0, =CHIP_ID_BASE
+	ldr	r1, [r0]
+	lsr	r1, r1, #8
+	and	r1, r1, #3
+	cmp	r1, #2
+	bne	v310_2
+*/
+@ ConControl
+#ifdef MEM_DLLl_ON
+	ldr	r0, =APB_DMC_0_BASE
+#ifdef CONFIG_EVT1__	
+	ldr	r1, =0x6910100A
+#else
+	ldr	r1, =0x7f10100A //ly
+#endif
+	ldr	r2, =DMC_PHYCONTROL0
+	str	r1, [r0, r2]
+	ldr	r1, =0xe0000084//0x00000084
+	ldr	r2, =DMC_PHYCONTROL1
+	str	r1, [r0, r2]
+#ifdef CONFIG_EVT1__
+	ldr	r1, =0x6910100B
+#else
+	ldr	r1, =0x7f10100B
+#endif
+	ldr	r2, =DMC_PHYCONTROL0
+	str	r1, [r0, r2]
+
+	/* wait ?us */
+	mov	r1, #0x20000
+8:	subs	r1, r1, #1
+	bne	8b
+
+	ldr	r1, =0x0000008C
+	ldr	r2, =DMC_PHYCONTROL1
+	str	r1, [r0, r2]
+	ldr	r1, =0x00000084
+	ldr	r2, =DMC_PHYCONTROL1
+	str	r1, [r0, r2]
+
+	/* wait ?us */
+	mov	r1, #0x20000
+9:	subs	r1, r1, #1
+	bne	9b
+
+	ldr	r0, =APB_DMC_1_BASE
+#ifdef CONFIG_EVT1___	
+	ldr	r1, =0xE910100A
+#else
+	ldr	r1, =0x7f10100A//ly
+#endif
+	ldr	r2, =DMC_PHYCONTROL0
+	str	r1, [r0, r2]
+	ldr	r1, =0xE0000084//ly
+	ldr	r2, =DMC_PHYCONTROL1
+	str	r1, [r0, r2]
+#ifdef CONFIG_EVT1___
+	ldr	r1, =0xE910100B
+#else
+	ldr	r1, =0x7f10100B
+#endif
+	ldr	r2, =DMC_PHYCONTROL0
+	str	r1, [r0, r2]
+
+	/* wait ?us */
+	mov	r1, #0x20000
+10:	subs	r1, r1, #1
+	bne	10b
+
+	ldr	r1, =0x0000008C
+	ldr	r2, =DMC_PHYCONTROL1
+	str	r1, [r0, r2]
+	ldr	r1, =0x00000084
+	ldr	r2, =DMC_PHYCONTROL1
+	str	r1, [r0, r2]
+
+	/* wait ?us */
+	mov	r1, #0x20000
+11:	subs	r1, r1, #1
+	bne	11b
+#endif
+
+	ldr	r0, =APB_DMC_0_BASE
+	ldr	r1, =0x0FFF30fa
+	ldr	r2, =DMC_CONCONTROL
+	str	r1, [r0, r2]
+	ldr	r0, =APB_DMC_1_BASE
+	ldr	r1, =0x0FFF30fa
+	ldr	r2, =DMC_CONCONTROL
+	str	r1, [r0, r2]
+
+	ldr	r0, =APB_DMC_0_BASE
+#ifdef CONFIG_EVT1_____
+	ldr	r1, =0x00202523
+#else
+	ldr	r1, =0x00202533//ly
+#endif
+	ldr	r2, =DMC_MEMCONTROL
+	str	r1, [r0, r2]
+	ldr	r0, =APB_DMC_1_BASE
+#ifdef CONFIG_EVT1____
+	ldr	r1, =0x00202523
+#else
+	ldr	r1, =0x00202533
+#endif
+	ldr	r2, =DMC_MEMCONTROL
+	str	r1, [r0, r2]
+v310_2:
+	pop	{pc}
+
+/*
+ *	Check clock until stable.
+ */
+	
+	/* Check devider change state */
+wait_div_state1:
+	ldr	r1, =(ELFIN_CLOCK_POWER_BASE + CLK_DIV_STAT1_OFFSET)
+        ldr     r2, [r1]
+	tst	r2, #(0x1<<15)
+	bne	wait_div_state1
+	mov	pc, lr
+	
+	/* Check source change state */
+wait_mux_state1:
+	ldr	r1, =(ELFIN_CLOCK_POWER_BASE + CLK_MUX_STAT1_OFFSET)
+        ldr     r2, [r1]
+	tst	r2, #(0x1<<31)
+	bne	wait_mux_state1
+	mov	pc, lr
+	
+	/* Check source change state */
+wait_mux_state0:
+	ldr	r1, =(ELFIN_CLOCK_POWER_BASE + CLK_MUX_STAT0_OFFSET)
+        ldr     r2, [r1]
+	tst	r2, #(0x4)
+	bne	wait_mux_state0
+	mov	pc, lr
+
+/*
+ * uart_asm_init: Initialize UART in asm mode, 115200bps fixed.
+ * void uart_asm_init(void)
+ */
+	.globl uart_asm_init
+uart_asm_init:
+
+	/* set GPIO to enable UART */
+	@ GPIO setting for UART for UART0/1
+	ldr	r0, =0x11400000
+	ldr	r1, =0x22222222
+	str   	r1, [r0]
+	ldr	r0, =0x11400020
+	ldr	r1, =0x222222
+	str	r1, [r0]
+
+	ldr	r0, =CMU_BASE	@0x1003_0000
+	ldr	r1, =CLK_SRC_PERIL0_VAL		@0x666666
+	ldr	r2, =CLK_SRC_PERIL0_OFFSET
+	str	r1, [r0, r2]
+	ldr	r1, =CLK_DIV_PERIL0_VAL		@0x777777
+	ldr	r2, =CLK_DIV_PERIL0_OFFSET
+	str	r1, [r0, r2]
+
+	ldr	r0, =ELFIN_UART_CONSOLE_BASE		@0xEC000000
+	ldr	r1, =0x111
+	str	r1, [r0, #UFCON_OFFSET]
+
+	mov	r1, #0x3
+	str	r1, [r0, #ULCON_OFFSET]
+
+	ldr	r1, =0x3c5
+	str	r1, [r0, #UCON_OFFSET]
+
+	ldr	r1, =UART_UBRDIV_VAL	@0x2B /*  UDIV(43) = ((82,500,000 / 16 / 115200) - 1) */
+	str	r1, [r0, #UBRDIV_OFFSET]
+
+	ldr	r1, =UART_UDIVSLOT_VAL	@0xC /* UFRACVAL(12) = ((((82,500,000 / 16 / 115200) - 1) - 43) * 16) */
+	str	r1, [r0, #UDIVSLOT_OFFSET]
+
+	ldr	r1, =0x4f4f4f4f
+	str	r1, [r0, #UTXH_OFFSET]		@'O'
+
+	mov	pc, lr
+
+/*
+ * OneNAND Interface Init
+ */
+onenandcon_init:
+wait_orwb:
+	@; Read ONENAND_IF_STATUS
+	ldr	r0, =CFG_ONENANDXL_BASE		@; 0x0C600000
+	ldr	r1, [r0, #0x100]		@; ONENAND_IF_STATUS_OFFSET(0x100)
+	bic	r1, r1, #0xFFFFFFFE
+	cmp	r1, #0x0
+
+	@; ORWB != 0x0
+	bne	wait_orwb
+
+	@; write new configuration to onenand system configuration1 register
+	ldr	r1, =0xF006			@; Sync.
+	ldr	r2, =(CFG_ONENAND_BASE+0x1E442)	@; 0x1E442(REG_SYS_CONF1)
+	strh	r1, [r2]
+
+	@; read one dummy halfword
+	ldrh	r1, [r2]
+	ldrh	r1, [r2]
+
+	@; write new configuration to ONENAND_IF_CTRL
+	ldr	r0, =CFG_ONENANDXL_BASE		@; 0x0C600000
+	@;ldr	r1, =0x2F006			@; ONENAND_IF_CTRL_REG_VAL (GCE off)
+	ldr	r1, =0x402F006			@; ONENAND_IF_CTRL_REG_VAL (GCE on)
+	str	r1, [r0, #0x100]		@; ONENAND_IF_STATUS_OFFSET(0x100)
+
+	mov	pc, lr
+
+/*
+ * Nand Interface Init for SMDKC100
+ */
+	.globl nand_asm_init
+nand_asm_init:
+
+	/* Setting GPIO for NAND */
+	/* This setting is NAND initialze code at booting time in iROM. */
+
+	ldr	r0, =0x11000000
+	
+	ldr     r1, [r0, #MP01CON_OFFSET]
+	bic     r1, r1, #(0xf<<8)
+	orr     r1, r1, #(0x3<<8)
+	str     r1, [r0, #MP01CON_OFFSET]
+
+@	ldr	r1, [r0, #MP01CON_OFFSET]
+@	bic	r1, r1, #(0xf<<8)
+@       orr     r1, r1, #((0x3<<8)|(0x2<<16)|(0x2<<20))
+@       orr     r1, r1, #0x220300
+@       ldr     r2, =0x220300
+@       bic     r1, r1, r2
+@	str	r1, [r0, #MP01CON_OFFSET]
+
+        ldr     r1, [r0, #MP01PUD_OFFSET]
+        bic     r1, r1, #(0x3<<4)
+        str     r1, [r0, #MP01PUD_OFFSET]
+
+	ldr     r1, [r0, #MP03CON_OFFSET]
+	bic     r1, r1, #0xFFFFFF
+
+	ldr     r2, =0x222
+	orr     r1, r1, r2
+	str     r1, [r0, #MP03CON_OFFSET]
+
+	ldr	r0, =ELFIN_NAND_BASE
+	ldr     r1, [r0, #NFCONF_OFFSET]
+
+	ldr     r2, =0x7772
+	bic	r1, r1, r2
+
+	ldr	r2, =NFCONF_VAL
+	orr	r1, r1, r2
+	str	r1, [r0, #NFCONF_OFFSET]
+	ldr	r1, [r0, #NFCONT_OFFSET]
+	ldr     r2, =0x6
+	bic	r1, r1, r2
+
+	ldr	r2, =NFCONT_VAL
+
+	orr	r1, r1, r2
+	str	r1, [r0, #NFCONT_OFFSET]
+	ldr     r1, [r0, #MP01CON_OFFSET]
+	bic     r1, r1, #(0xf<<8)
+	orr     r1, r1, #(0x3<<8)
+	str     r1, [r0, #MP01CON_OFFSET]
+	mov	pc, lr
+
+/*
+ * Setting TZPC[TrustZone Protection Controller]
+ */
+
+tzpc_init:
+
+	ldr	r0, =ELFIN_TZPC0_BASE
+ 	mov	r1, #0x0
+ 	str	r1, [r0]
+ 	mov	r1, #0xff
+ 	str	r1, [r0, #TZPC_DECPROT0SET_OFFSET]
+ 	str	r1, [r0, #TZPC_DECPROT1SET_OFFSET]
+	@@@;;str	  r1, [r0, #TZPC_DECPROT2SET_OFFSET] 	
+	str	r1, [r0, #TZPC_DECPROT3SET_OFFSET]
+
+ 	ldr 	r0, =ELFIN_TZPC1_BASE
+ 	str	r1, [r0, #TZPC_DECPROT0SET_OFFSET]
+ 	str	r1, [r0, #TZPC_DECPROT1SET_OFFSET]
+	str	r1, [r0, #TZPC_DECPROT2SET_OFFSET] 	
+	str	r1, [r0, #TZPC_DECPROT3SET_OFFSET]
+
+ 	ldr	r0, =ELFIN_TZPC2_BASE
+ 	str	r1, [r0, #TZPC_DECPROT0SET_OFFSET]
+ 	str	r1, [r0, #TZPC_DECPROT1SET_OFFSET]
+	str	r1, [r0, #TZPC_DECPROT2SET_OFFSET]
+	str	r1, [r0, #TZPC_DECPROT3SET_OFFSET] 
+
+ 	ldr	r0, =ELFIN_TZPC3_BASE
+ 	str	r1, [r0, #TZPC_DECPROT0SET_OFFSET]
+ 	str	r1, [r0, #TZPC_DECPROT1SET_OFFSET]
+	str	r1, [r0, #TZPC_DECPROT2SET_OFFSET] 	
+	str	r1, [r0, #TZPC_DECPROT3SET_OFFSET]
+
+ 	ldr	r0, =ELFIN_TZPC4_BASE
+ 	str	r1, [r0, #TZPC_DECPROT0SET_OFFSET]
+ 	str	r1, [r0, #TZPC_DECPROT1SET_OFFSET]
+	str	r1, [r0, #TZPC_DECPROT2SET_OFFSET]
+	str	r1, [r0, #TZPC_DECPROT3SET_OFFSET]
+
+ 	ldr	r0, =ELFIN_TZPC5_BASE
+ 	str	r1, [r0, #TZPC_DECPROT0SET_OFFSET]
+ 	str	r1, [r0, #TZPC_DECPROT1SET_OFFSET]
+	str	r1, [r0, #TZPC_DECPROT2SET_OFFSET]
+	str	r1, [r0, #TZPC_DECPROT3SET_OFFSET]
+
+ 	mov	pc, lr
+
+
+#ifdef CONFIG_ENABLE_MMU
+
+/*
+ * MMU Table for SMDKC210
+ * 0x0000_0000 -- 0x1FFF_FFFF => A:0x0000_0000 -- 0x1FFF_FFFF
+ * 0x2000_0000 -- 0x3FFF_FFFF => Not Allowed
+ * 0x4000_0000 -- 0x5FFF_FFFF => A:0x4000_0000 -- 0x5FFF_FFFF
+ * 0x6000_0000 -- 0xBFFF_FFFF => Not Allowed
+ * 0xC000_0000 -- 0xDFFF_FFFF => A:0x4000_0000 -- 0X5FFF_FFFF
+ * 0xE000_0000 -- 0xFFFF_FFFF => Not Allowed
+ */
+
+	/* form a first-level section entry */
+.macro FL_SECTION_ENTRY base,ap,d,c,b
+	.word (\base << 20) | (\ap << 10) | \
+	      (\d << 5) | (1<<4) | (\c << 3) | (\b << 2) | (1<<1)
+.endm
+
+.section .mmudata, "a"
+	.align 14
+	// the following alignment creates the mmu table at address 0x4000.
+	.globl mmu_table
+mmu_table:
+	.set __base,0
+	// Access for iRAM
+	.rept 0x200
+	FL_SECTION_ENTRY __base,3,0,0,0
+	.set __base,__base+1
+	.endr
+
+	// Not Allowed
+	.rept 0x400 - 0x200
+	.word 0x00000000
+	.endr
+
+	.set __base,0x400
+	// 512MB for SDRAM with cacheable
+	.rept 0x600 - 0x400
+	FL_SECTION_ENTRY __base,3,0,1,1
+	.set __base,__base+1
+	.endr
+
+	// access is not allowed.
+	.rept 0xc00 - 0x600
+	.word 0x00000000
+	.endr
+
+	.set __base,0x400
+	// 512MB for SDRAM with cacheable
+	.rept 0xE00 - 0xC00
+	FL_SECTION_ENTRY __base,3,0,1,1
+	.set __base,__base+1
+	.endr
+
+	// access is not allowed.
+	.rept 0x1000 - 0xE00
+	.word 0x00000000
+	.endr
+
+#endif
+
diff -urN TC4_uboot/board/samsung/smdkc210/lowlevel_init_SCP.S iTop4412_uboot/board/samsung/smdkc210/lowlevel_init_SCP.S
--- TC4_uboot/board/samsung/smdkc210/lowlevel_init_SCP.S	1969-12-31 16:00:00.000000000 -0800
+++ iTop4412_uboot/board/samsung/smdkc210/lowlevel_init_SCP.S	2015-11-09 00:59:35.000000000 -0800
@@ -0,0 +1,801 @@
+/*
+ * Memory Setup stuff - taken from blob memsetup.S
+ *
+ * Copyright (C) 1999 2000 2001 Erik Mouw (J.A.K.Mouw@its.tudelft.nl) and
+ *                     Jan-Derk Bakker (J.D.Bakker@its.tudelft.nl)
+ *
+ * Modified for the Samsung SMDK2410 by
+ * (C) Copyright 2002
+ * David Mueller, ELSOFT AG, <d.mueller@elsoft.ch>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+#include <config.h>
+#include <version.h>
+
+#include <s5pc210.h>
+#include "smdk4x12_val.h" //mj
+
+#define check_mem
+#define MEM_DLLl_ON
+
+/* add by cym 20130218 */
+wait_mux_state:
+	ldr r1, [r0, r2]
+	cmp r1, r3
+	bne wait_mux_state
+	mov pc, lr
+
+wait_pll_lock:
+	ldr r1, [r0, r2]
+	tst r1, #(1<<29)
+	beq wait_pll_lock
+	mov pc, lr
+
+wait_phy_state:
+	ldr r1, [r0, #DMC_PHYSTATUS]
+	tst r1, #(1<<2)
+	beq wait_phy_state
+	mov pc, lr
+/* end add */
+
+_TEXT_BASE:
+	.word	TEXT_BASE
+
+	.globl lowlevel_init
+lowlevel_init:
+#if 1//*****ly
+	/* use iROM stack in bl2 */
+	ldr	sp, =0x02060000
+#endif
+	push	{lr}
+
+	/* check reset status  */
+	ldr     r0, =(INF_REG_BASE + INF_REG1_OFFSET)
+        ldr     r1, [r0]
+
+	/* AFTR wakeup reset */
+	ldr	r2, =S5P_CHECK_DIDLE
+	cmp	r1, r2
+	beq	exit_wakeup
+
+	/* Sleep wakeup reset */
+	ldr	r2, =S5P_CHECK_SLEEP
+	cmp	r1, r2
+	beq	wakeup_reset
+
+        /* PS-Hold high */
+        ldr r0, =0x1002330c
+        ldr r1, [r0]
+        orr r1, r1, #0x300
+        str r1, [r0]
+
+        ldr     r0, =0x11000c08
+        ldr r1, =0x0
+        str r1, [r0]
+
+        /* Clear  MASK_WDT_RESET_REQUEST  */
+        ldr r0, =0x1002040c
+        ldr r1, =0x00
+        str r1, [r0]
+        
+#ifdef check_mem /*liyang 20110822*/
+	/* when we already run in ram, we don't need to relocate U-Boot.
+	 * and actually, memory controller must be configured before U-Boot
+	 * is running in ram.
+	 */
+	ldr	r0, =0xff000fff
+	bic	r1, pc, r0		/* r0 <- current base addr of code */
+	ldr	r2, _TEXT_BASE		/* r1 <- original base addr in ram */
+	bic	r2, r2, r0		/* r0 <- current base addr of code */
+	cmp     r1, r2                  /* compare r0, r1                  */
+	beq     1f			/* r0 == r1 then skip sdram init   */
+#endif
+
+/*	liyang 20110822
+	
+	ldr	r0, =CHIP_ID_BASE
+	ldr	r1, [r0]
+	lsr	r1, r1, #8
+	and	r1, r1, #3
+	cmp	r1, #2
+	bne v310_1
+
+*/
+	/* add by cym 20130218 */
+	/* init system clock */
+	bl system_clock_init_scp
+	
+	/* Memory initialize */
+	bl mem_ctrl_asm_init_ddr3
+
+	/* end add */
+	
+
+	bl tzpc_init
+	
+	b	1f
+
+v310_1:
+	/* add by cym 20130218 */
+	/* init system clock */
+	bl	system_clock_init_scp
+
+	/* Memory initialize	*/
+	bl	mem_ctrl_asm_init_ddr3
+/* end add */
+
+1:
+
+#ifdef CONFIG_EVT1___
+	/* store DMC density information in DRAM */
+	/* mem_ctrl_asm_init returns dmc_density in r6 */
+	ldr	r0, =CFG_UBOOT_BASE
+	sub	r0, r0, #4
+	str	r6, [r0]
+#endif
+#if 0 //test for mt6620 turn off GPC1(0)
+	/*wenpin.cui: headphone and sw uart switch init*/
+	ldr	r0, =0x11000C44
+	ldr	r1, [r0]
+	and	r1, r1, #0x4 	
+	cmp	r1, #0x4	/*uart*/	
+	beq	out	
+
+	ldr     r0, =0x11400084  /* GPC1(0)  */
+	ldr     r1, [r0]	/* read GPC1DAT status*/
+	orr	r1, r1, #0x1	/* GPC1(0) output high  */
+	str     r1, [r0]
+
+	ldr     r0, =0x11400080  /* GPC1(0)  */
+	ldr	r1, [r0]
+	and	r1, r1, #0xfffffff0
+	orr     r1, r1, #0x1	/* GPC1(0) output  */
+	str     r1, [r0]
+#endif
+out:
+	/* for UART */
+	bl uart_asm_init
+
+       
+
+#if defined(CONFIG_ONENAND)
+	bl onenandcon_init
+#endif
+
+#if defined(CONFIG_NAND)
+	/* simple init for NAND */
+	bl nand_asm_init
+#endif
+
+	/* Print 'K' */
+	ldr	r0, =ELFIN_UART_CONSOLE_BASE
+	ldr	r1, =0x4b4b4b4b
+	str	r1, [r0, #UTXH_OFFSET]
+
+	/* 2010.08.27 by icarus : for temporary 3D clock fix */
+	ldr	r1, =0x1
+	ldr	r2, =0x1003C22C
+	str	r1, [r2]
+	ldr	r1, =0x2
+	ldr	r2, =0x1003C52C
+	str	r1, [r2]
+
+	/* 2010.10.17 by icarus : for temporary MFC clock fix */
+	ldr	r1, =0x3
+	ldr	r2, =0x1003C528
+	str	r1, [r2]
+
+	pop	{pc}
+
+wakeup_reset:
+	ldr	r0, =CHIP_ID_BASE
+	ldr	r1, [r0]
+	lsr	r1, r1, #8
+	and	r1, r1, #3
+	cmp	r1, #2
+	bne	wake_v310
+	
+	//mj 
+	/* check C2C_CTRL enable bit */
+	ldr r3, =SYSC_PMU_BASE
+	ldr r1, [r3, #C2C_CTRL_OFFSET]
+	and r1, r1, #1
+	cmp r1, #0
+	bne skip_dmc
+	
+	/* init system clock */
+	/* add by cym 20130218 */
+	bl	mem_ctrl_asm_init_ddr3
+	/* end add */
+skip_dmc:
+	/* add by cym 20130218 */
+	bl	system_clock_init_scp
+	/* end add */
+	bl	tzpc_init
+	b	exit_wakeup
+
+wake_v310:
+	/* add by cym 20130218 */
+	bl system_clock_init_scp
+	bl mem_ctrl_asm_init_ddr3
+	/* end add */
+	
+	bl tzpc_init
+
+exit_wakeup:
+	/*Load return address and jump to kernel*/
+	ldr	r0, =(INF_REG_BASE+INF_REG0_OFFSET)
+	ldr	r1, [r0]	/* r1 = physical address of s5pc110_cpu_resume function*/
+
+	mov	pc, r1		/*Jump to kernel */
+	nop
+	nop
+
+/*
+ * system_clock_init: Initialize core clock and bus clock.
+ * void system_clock_init(void)
+ */
+
+ /* add by cym 20130218 */
+system_clock_init_scp:
+	push	{lr}
+	
+	ldr	r0, =ELFIN_CLOCK_BASE	@0x1003_0000
+
+@ CMU_CPU MUX / DIV
+	ldr	r1, =0x0
+	ldr	r2, =CLK_SRC_CPU_OFFSET
+	str	r1, [r0, r2]
+
+	ldr r2, =CLK_MUX_STAT_CPU_OFFSET
+	ldr r3, =0x01110001
+	bl wait_mux_state
+
+	ldr	r1, =CLK_DIV_DMC0_VAL
+	ldr	r2, =CLK_DIV_DMC0_OFFSET
+	str	r1, [r0, r2]
+	ldr	r1, =CLK_DIV_DMC1_VAL
+	ldr	r2, =CLK_DIV_DMC1_OFFSET
+	str	r1, [r0, r2]
+
+@ CMU_TOP MUX / DIV
+	ldr	r1, =0x0
+	ldr	r2, =CLK_SRC_TOP0_OFFSET
+	str	r1, [r0, r2]
+
+	ldr r2, =CLK_MUX_STAT_TOP_OFFSET
+	ldr r3, =0x11111111
+	bl wait_mux_state
+
+	ldr	r1, =0x0
+	ldr	r2, =CLK_SRC_TOP1_OFFSET
+	str	r1, [r0, r2]
+
+	ldr r2, =CLK_MUX_STAT_TOP1_OFFSET
+	ldr r3, =0x01111110
+	bl wait_mux_state
+
+	ldr	r1, =CLK_DIV_TOP_VAL
+	ldr	r2, =CLK_DIV_TOP_OFFSET
+	str	r1, [r0, r2]
+
+@ CMU_LEFTBUS MUX / DIV
+	ldr	r1, =0x10
+	ldr	r2, =CLK_SRC_LEFTBUS_OFFSET
+	str	r1, [r0, r2]
+
+	ldr r2, =CLK_MUX_STAT_LEFTBUS_OFFSET
+	ldr r3, =0x00000021
+	bl wait_mux_state
+
+	ldr	r1, =CLK_DIV_LEFRBUS_VAL
+	ldr	r2, =CLK_DIV_LEFTBUS_OFFSET
+	str	r1, [r0, r2]
+
+@ CMU_RIGHTBUS MUX / DIV
+	ldr	r1, =0x10
+	ldr	r2, =CLK_SRC_RIGHTBUS_OFFSET
+	str	r1, [r0, r2]
+
+	ldr r2, =CLK_MUX_STAT_RIGHTBUS_OFFSET
+	ldr r3, =0x00000021
+	bl wait_mux_state
+
+	ldr	r1, =CLK_DIV_RIGHTBUS_VAL
+	ldr	r2, =CLK_DIV_RIGHTBUS_OFFSET
+	str	r1, [r0, r2]
+
+@ Set PLL locktime
+	ldr	r1, =APLL_LOCK_VAL
+	ldr	r2, =APLL_LOCK_OFFSET
+	str	r1, [r0, r2]
+
+	ldr	r1, =MPLL_LOCK_VAL
+	ldr	r2, =MPLL_LOCK_OFFSET
+	str	r1, [r0, r2]
+
+	ldr	r1, =EPLL_LOCK_VAL
+	ldr	r2, =EPLL_LOCK_OFFSET
+	str	r1, [r0, r2]
+
+	ldr	r1, =VPLL_LOCK_VAL
+	ldr	r2, =VPLL_LOCK_OFFSET
+	str	r1, [r0, r2]
+
+	ldr	r1, =CLK_DIV_CPU0_VAL
+	ldr	r2, =CLK_DIV_CPU0_OFFSET
+	str	r1, [r0, r2]
+	ldr	r1, =CLK_DIV_CPU1_VAL
+	ldr	r2, =CLK_DIV_CPU1_OFFSET
+	str	r1, [r0, r2]
+
+@ Set APLL
+	ldr	r1, =APLL_CON1_VAL
+	ldr	r2, =APLL_CON1_OFFSET
+	str	r1, [r0, r2]
+	ldr	r1, =APLL_CON0_VAL
+	ldr	r2, =APLL_CON0_OFFSET
+	str	r1, [r0, r2]
+
+	/* check MPLL and if MPLL is not 400 Mhz skip MPLL resetting for C2C operation */
+	ldr	r2, =MPLL_CON0_OFFSET
+	ldr r1, [r0, r2]
+	ldr r3, =0xA0640301
+	cmp r1, r3
+	bne skip_mpll
+
+@ Set MPLL
+	ldr	r1, =MPLL_CON1_VAL
+	ldr	r2, =MPLL_CON1_OFFSET
+	str	r1, [r0, r2]
+	ldr	r1, =MPLL_CON0_VAL
+	ldr	r2, =MPLL_CON0_OFFSET
+	str	r1, [r0, r2]
+skip_mpll:
+
+@ Set EPLL
+	ldr     r1, =EPLL_CON2_VAL
+	ldr     r2, =EPLL_CON2_OFFSET
+	str     r1, [r0, r2]
+	ldr     r1, =EPLL_CON1_VAL
+	ldr     r2, =EPLL_CON1_OFFSET
+	str     r1, [r0, r2]
+	ldr     r1, =EPLL_CON0_VAL
+	ldr     r2, =EPLL_CON0_OFFSET
+	str     r1, [r0, r2]
+
+@ Set VPLL
+	ldr     r1, =VPLL_CON2_VAL
+	ldr     r2, =VPLL_CON2_OFFSET
+	str     r1, [r0, r2]
+	ldr     r1, =VPLL_CON1_VAL
+	ldr     r2, =VPLL_CON1_OFFSET
+	str     r1, [r0, r2]
+	ldr     r1, =VPLL_CON0_VAL
+	ldr     r2, =VPLL_CON0_OFFSET
+	str     r1, [r0, r2]
+
+	ldr r2, =APLL_CON0_OFFSET
+	bl wait_pll_lock
+	ldr r2, =MPLL_CON0_OFFSET
+	bl wait_pll_lock
+	ldr r2, =EPLL_CON0_OFFSET
+	bl wait_pll_lock
+	ldr r2, =VPLL_CON0_OFFSET
+	bl wait_pll_lock
+
+	ldr	r1, =0x01000001
+	ldr	r2, =CLK_SRC_CPU_OFFSET
+	str	r1, [r0, r2]
+
+	ldr r2, =CLK_MUX_STAT_CPU_OFFSET
+	ldr r3, =0x02110002
+	bl wait_mux_state
+
+	ldr	r1, =0x00011000
+	ldr	r2, =CLK_SRC_DMC_OFFSET
+	str	r1, [r0, r2]
+
+	ldr r2, =CLK_MUX_STAT_DMC_OFFSET
+	ldr r3, =0x11102111
+	bl wait_mux_state
+
+	ldr	r1, =0x00000110
+	ldr	r2, =CLK_SRC_TOP0_OFFSET
+	str	r1, [r0, r2]
+
+	ldr r2, =CLK_MUX_STAT_TOP_OFFSET
+	ldr r3, =0x11111221
+	bl wait_mux_state
+
+	/* skip MUX_ACLK_200_SUB_SEL, MUX_ACLK_400_MCUISP_SUB_SEL setting for CMU_SYSCLK_ISP function */
+	ldr	r1, =0x00011000
+	ldr	r2, =CLK_SRC_TOP1_OFFSET
+	str	r1, [r0, r2]
+
+	ldr r2, =CLK_MUX_STAT_TOP1_OFFSET
+	ldr r3, =0x01122110
+	bl wait_mux_state
+
+	ldr	r0, =CHIP_ID_BASE
+	ldr	r1, [r0]
+	lsr	r1, r1, #8
+	and	r1, r1, #3
+	cmp	r1, #2
+	bne	v310_2
+
+	/* check C2C_CTRL enable bit */
+	ldr r3, =S5PV310_POWER_BASE
+	ldr r1, [r3, #C2C_CTRL_OFFSET]
+	and r1, r1, #1
+	cmp r1, #0
+	bne v310_2
+
+@ ConControl
+#ifdef MEM_DLLl_ON
+	ldr	r0, =APB_DMC_0_BASE
+
+	ldr	r1, =0x7F10100A
+	ldr	r2, =DMC_PHYCONTROL0
+	str	r1, [r0, r2]
+
+	ldr	r1, =0xE0000084
+	ldr	r2, =DMC_PHYCONTROL1
+	str	r1, [r0, r2]
+
+	ldr	r1, =0x7F10100B
+	ldr	r2, =DMC_PHYCONTROL0
+	str	r1, [r0, r2]
+
+	bl wait_phy_state
+
+	ldr	r1, =0x0000008C
+	ldr	r2, =DMC_PHYCONTROL1
+	str	r1, [r0, r2]
+	ldr	r1, =0x00000084
+	ldr	r2, =DMC_PHYCONTROL1
+	str	r1, [r0, r2]
+
+	bl wait_phy_state
+
+	ldr	r0, =APB_DMC_1_BASE
+
+	ldr	r1, =0x7F10100A
+	ldr	r2, =DMC_PHYCONTROL0
+	str	r1, [r0, r2]
+
+	ldr	r1, =0xE0000084
+	ldr	r2, =DMC_PHYCONTROL1
+	str	r1, [r0, r2]
+
+	ldr	r1, =0x7F10100B
+	ldr	r2, =DMC_PHYCONTROL0
+	str	r1, [r0, r2]
+
+	bl wait_phy_state
+
+	ldr	r1, =0x0000008C
+	ldr	r2, =DMC_PHYCONTROL1
+	str	r1, [r0, r2]
+	ldr	r1, =0x00000084
+	ldr	r2, =DMC_PHYCONTROL1
+	str	r1, [r0, r2]
+
+	bl wait_phy_state
+#endif
+
+	ldr	r0, =APB_DMC_0_BASE
+	ldr	r1, =0x0FFF30FA
+	ldr	r2, =DMC_CONCONTROL
+	str	r1, [r0, r2]
+
+	ldr	r0, =APB_DMC_1_BASE
+	ldr	r1, =0x0FFF30FA
+	ldr	r2, =DMC_CONCONTROL
+	str	r1, [r0, r2]
+
+	ldr	r0, =APB_DMC_0_BASE
+	ldr	r1, =0x00202533
+	ldr	r2, =DMC_MEMCONTROL
+	str	r1, [r0, r2]
+
+	ldr	r0, =APB_DMC_1_BASE
+	ldr	r1, =0x00202533
+	ldr	r2, =DMC_MEMCONTROL
+	str	r1, [r0, r2]
+
+v310_2:
+	pop	{pc}
+
+/* end add */
+
+/*
+ *	Check clock until stable.
+ */
+	
+	/* Check devider change state */
+wait_div_state1:
+	ldr	r1, =(ELFIN_CLOCK_POWER_BASE + CLK_DIV_STAT1_OFFSET)
+        ldr     r2, [r1]
+	tst	r2, #(0x1<<15)
+	bne	wait_div_state1
+	mov	pc, lr
+	
+	/* Check source change state */
+wait_mux_state1:
+	ldr	r1, =(ELFIN_CLOCK_POWER_BASE + CLK_MUX_STAT1_OFFSET)
+        ldr     r2, [r1]
+	tst	r2, #(0x1<<31)
+	bne	wait_mux_state1
+	mov	pc, lr
+	
+	/* Check source change state */
+wait_mux_state0:
+	ldr	r1, =(ELFIN_CLOCK_POWER_BASE + CLK_MUX_STAT0_OFFSET)
+        ldr     r2, [r1]
+	tst	r2, #(0x4)
+	bne	wait_mux_state0
+	mov	pc, lr
+
+/*
+ * uart_asm_init: Initialize UART in asm mode, 115200bps fixed.
+ * void uart_asm_init(void)
+ */
+	.globl uart_asm_init
+uart_asm_init:
+
+	/* set GPIO to enable UART */
+	@ GPIO setting for UART for UART0/1
+	ldr	r0, =0x11400000
+	ldr	r1, =0x22222222
+	str   	r1, [r0]
+	ldr	r0, =0x11400020
+	ldr	r1, =0x222222
+	str	r1, [r0]
+
+	ldr	r0, =CMU_BASE	@0x1003_0000
+	ldr	r1, =CLK_SRC_PERIL0_VAL		@0x666666
+	ldr	r2, =CLK_SRC_PERIL0_OFFSET
+	str	r1, [r0, r2]
+	ldr	r1, =CLK_DIV_PERIL0_VAL		@0x777777
+	ldr	r2, =CLK_DIV_PERIL0_OFFSET
+	str	r1, [r0, r2]
+
+	ldr	r0, =ELFIN_UART_CONSOLE_BASE		@0xEC000000
+	ldr	r1, =0x111
+	str	r1, [r0, #UFCON_OFFSET]
+
+	mov	r1, #0x3
+	str	r1, [r0, #ULCON_OFFSET]
+
+	ldr	r1, =0x3c5
+	str	r1, [r0, #UCON_OFFSET]
+
+	ldr	r1, =UART_UBRDIV_VAL	@0x2B /*  UDIV(43) = ((82,500,000 / 16 / 115200) - 1) */
+	str	r1, [r0, #UBRDIV_OFFSET]
+
+	ldr	r1, =UART_UDIVSLOT_VAL	@0xC /* UFRACVAL(12) = ((((82,500,000 / 16 / 115200) - 1) - 43) * 16) */
+	str	r1, [r0, #UDIVSLOT_OFFSET]
+
+	ldr	r1, =0x4f4f4f4f
+	str	r1, [r0, #UTXH_OFFSET]		@'O'
+
+	mov	pc, lr
+
+/*
+ * OneNAND Interface Init
+ */
+onenandcon_init:
+wait_orwb:
+	@; Read ONENAND_IF_STATUS
+	ldr	r0, =CFG_ONENANDXL_BASE		@; 0x0C600000
+	ldr	r1, [r0, #0x100]		@; ONENAND_IF_STATUS_OFFSET(0x100)
+	bic	r1, r1, #0xFFFFFFFE
+	cmp	r1, #0x0
+
+	@; ORWB != 0x0
+	bne	wait_orwb
+
+	@; write new configuration to onenand system configuration1 register
+	ldr	r1, =0xF006			@; Sync.
+	ldr	r2, =(CFG_ONENAND_BASE+0x1E442)	@; 0x1E442(REG_SYS_CONF1)
+	strh	r1, [r2]
+
+	@; read one dummy halfword
+	ldrh	r1, [r2]
+	ldrh	r1, [r2]
+
+	@; write new configuration to ONENAND_IF_CTRL
+	ldr	r0, =CFG_ONENANDXL_BASE		@; 0x0C600000
+	@;ldr	r1, =0x2F006			@; ONENAND_IF_CTRL_REG_VAL (GCE off)
+	ldr	r1, =0x402F006			@; ONENAND_IF_CTRL_REG_VAL (GCE on)
+	str	r1, [r0, #0x100]		@; ONENAND_IF_STATUS_OFFSET(0x100)
+
+	mov	pc, lr
+
+/*
+ * Nand Interface Init for SMDKC100
+ */
+	.globl nand_asm_init
+nand_asm_init:
+
+	/* Setting GPIO for NAND */
+	/* This setting is NAND initialze code at booting time in iROM. */
+
+	ldr	r0, =0x11000000
+	
+	ldr     r1, [r0, #MP01CON_OFFSET]
+	bic     r1, r1, #(0xf<<8)
+	orr     r1, r1, #(0x3<<8)
+	str     r1, [r0, #MP01CON_OFFSET]
+
+@	ldr	r1, [r0, #MP01CON_OFFSET]
+@	bic	r1, r1, #(0xf<<8)
+@       orr     r1, r1, #((0x3<<8)|(0x2<<16)|(0x2<<20))
+@       orr     r1, r1, #0x220300
+@       ldr     r2, =0x220300
+@       bic     r1, r1, r2
+@	str	r1, [r0, #MP01CON_OFFSET]
+
+        ldr     r1, [r0, #MP01PUD_OFFSET]
+        bic     r1, r1, #(0x3<<4)
+        str     r1, [r0, #MP01PUD_OFFSET]
+
+	ldr     r1, [r0, #MP03CON_OFFSET]
+	bic     r1, r1, #0xFFFFFF
+
+	ldr     r2, =0x222
+	orr     r1, r1, r2
+	str     r1, [r0, #MP03CON_OFFSET]
+
+	ldr	r0, =ELFIN_NAND_BASE
+	ldr     r1, [r0, #NFCONF_OFFSET]
+
+	ldr     r2, =0x7772
+	bic	r1, r1, r2
+
+	ldr	r2, =NFCONF_VAL
+	orr	r1, r1, r2
+	str	r1, [r0, #NFCONF_OFFSET]
+	ldr	r1, [r0, #NFCONT_OFFSET]
+	ldr     r2, =0x6
+	bic	r1, r1, r2
+
+	ldr	r2, =NFCONT_VAL
+
+	orr	r1, r1, r2
+	str	r1, [r0, #NFCONT_OFFSET]
+	ldr     r1, [r0, #MP01CON_OFFSET]
+	bic     r1, r1, #(0xf<<8)
+	orr     r1, r1, #(0x3<<8)
+	str     r1, [r0, #MP01CON_OFFSET]
+	mov	pc, lr
+
+/*
+ * Setting TZPC[TrustZone Protection Controller]
+ */
+
+tzpc_init:
+
+	ldr	r0, =ELFIN_TZPC0_BASE
+ 	mov	r1, #0x0
+ 	str	r1, [r0]
+ 	mov	r1, #0xff
+ 	str	r1, [r0, #TZPC_DECPROT0SET_OFFSET]
+ 	str	r1, [r0, #TZPC_DECPROT1SET_OFFSET]
+	@@@;;str	  r1, [r0, #TZPC_DECPROT2SET_OFFSET] 	
+	str	r1, [r0, #TZPC_DECPROT3SET_OFFSET]
+
+ 	ldr 	r0, =ELFIN_TZPC1_BASE
+ 	str	r1, [r0, #TZPC_DECPROT0SET_OFFSET]
+ 	str	r1, [r0, #TZPC_DECPROT1SET_OFFSET]
+	str	r1, [r0, #TZPC_DECPROT2SET_OFFSET] 	
+	str	r1, [r0, #TZPC_DECPROT3SET_OFFSET]
+
+ 	ldr	r0, =ELFIN_TZPC2_BASE
+ 	str	r1, [r0, #TZPC_DECPROT0SET_OFFSET]
+ 	str	r1, [r0, #TZPC_DECPROT1SET_OFFSET]
+	str	r1, [r0, #TZPC_DECPROT2SET_OFFSET]
+	str	r1, [r0, #TZPC_DECPROT3SET_OFFSET] 
+
+ 	ldr	r0, =ELFIN_TZPC3_BASE
+ 	str	r1, [r0, #TZPC_DECPROT0SET_OFFSET]
+ 	str	r1, [r0, #TZPC_DECPROT1SET_OFFSET]
+	str	r1, [r0, #TZPC_DECPROT2SET_OFFSET] 	
+	str	r1, [r0, #TZPC_DECPROT3SET_OFFSET]
+
+ 	ldr	r0, =ELFIN_TZPC4_BASE
+ 	str	r1, [r0, #TZPC_DECPROT0SET_OFFSET]
+ 	str	r1, [r0, #TZPC_DECPROT1SET_OFFSET]
+	str	r1, [r0, #TZPC_DECPROT2SET_OFFSET]
+	str	r1, [r0, #TZPC_DECPROT3SET_OFFSET]
+
+ 	ldr	r0, =ELFIN_TZPC5_BASE
+ 	str	r1, [r0, #TZPC_DECPROT0SET_OFFSET]
+ 	str	r1, [r0, #TZPC_DECPROT1SET_OFFSET]
+	str	r1, [r0, #TZPC_DECPROT2SET_OFFSET]
+	str	r1, [r0, #TZPC_DECPROT3SET_OFFSET]
+
+ 	mov	pc, lr
+
+
+#ifdef CONFIG_ENABLE_MMU
+
+/*
+ * MMU Table for SMDKC210
+ * 0x0000_0000 -- 0x1FFF_FFFF => A:0x0000_0000 -- 0x1FFF_FFFF
+ * 0x2000_0000 -- 0x3FFF_FFFF => Not Allowed
+ * 0x4000_0000 -- 0x5FFF_FFFF => A:0x4000_0000 -- 0x5FFF_FFFF
+ * 0x6000_0000 -- 0xBFFF_FFFF => Not Allowed
+ * 0xC000_0000 -- 0xDFFF_FFFF => A:0x4000_0000 -- 0X5FFF_FFFF
+ * 0xE000_0000 -- 0xFFFF_FFFF => Not Allowed
+ */
+
+	/* form a first-level section entry */
+.macro FL_SECTION_ENTRY base,ap,d,c,b
+	.word (\base << 20) | (\ap << 10) | \
+	      (\d << 5) | (1<<4) | (\c << 3) | (\b << 2) | (1<<1)
+.endm
+
+.section .mmudata, "a"
+	.align 14
+	// the following alignment creates the mmu table at address 0x4000.
+	.globl mmu_table
+mmu_table:
+	.set __base,0
+	// Access for iRAM
+	.rept 0x200
+	FL_SECTION_ENTRY __base,3,0,0,0
+	.set __base,__base+1
+	.endr
+
+	// Not Allowed
+	.rept 0x400 - 0x200
+	.word 0x00000000
+	.endr
+
+	.set __base,0x400
+	// 512MB for SDRAM with cacheable
+	.rept 0x600 - 0x400
+	FL_SECTION_ENTRY __base,3,0,1,1
+	.set __base,__base+1
+	.endr
+
+	// access is not allowed.
+	.rept 0xc00 - 0x600
+	.word 0x00000000
+	.endr
+
+	.set __base,0x400
+	// 512MB for SDRAM with cacheable
+	.rept 0xE00 - 0xC00
+	FL_SECTION_ENTRY __base,3,0,1,1
+	.set __base,__base+1
+	.endr
+
+	// access is not allowed.
+	.rept 0x1000 - 0xE00
+	.word 0x00000000
+	.endr
+
+#endif
+
diff -urN TC4_uboot/board/samsung/smdkc210/Makefile iTop4412_uboot/board/samsung/smdkc210/Makefile
--- TC4_uboot/board/samsung/smdkc210/Makefile	2012-04-24 01:02:09.000000000 -0700
+++ iTop4412_uboot/board/samsung/smdkc210/Makefile	2015-11-09 00:59:35.000000000 -0800
@@ -30,8 +30,12 @@
 
 COBJS-y	:= smdkc210.o
 COBJS-$(CONFIG_SAMSUNG_ONENAND)	+= onenand.o
+
+
+
 SOBJS	:= lowlevel_init.o
 
+
 SRCS    := $(SOBJS:.o=.S) $(COBJS-y:.o=.c)
 OBJS	:= $(addprefix $(obj),$(COBJS-y))
 SOBJS	:= $(addprefix $(obj),$(SOBJS))
diff -urN TC4_uboot/board/samsung/smdkc210/smdkc210.c iTop4412_uboot/board/samsung/smdkc210/smdkc210.c
--- TC4_uboot/board/samsung/smdkc210/smdkc210.c	2012-04-24 01:02:09.000000000 -0700
+++ iTop4412_uboot/board/samsung/smdkc210/smdkc210.c	2015-11-09 00:59:35.000000000 -0800
@@ -140,16 +140,36 @@
 			gd->bd->bi_dram[1].size = PHYS_SDRAM_2_SIZE;
 		}
 		else{//ly
-			printf("POP for C220\n");
-			nr_dram_banks = 4;
-			gd->bd->bi_dram[0].start = PHYS_SDRAM_1;
-			gd->bd->bi_dram[0].size = PHYS_SDRAM_1_SIZE;
-			gd->bd->bi_dram[1].start = PHYS_SDRAM_2;
-			gd->bd->bi_dram[1].size = PHYS_SDRAM_2_SIZE;
-			gd->bd->bi_dram[2].start = PHYS_SDRAM_3;
-			gd->bd->bi_dram[2].size = PHYS_SDRAM_3_SIZE;
-			gd->bd->bi_dram[3].start = PHYS_SDRAM_4;
-			gd->bd->bi_dram[3].size = PHYS_SDRAM_4_SIZE;
+                    printf("POP for C220\n");
+
+#if defined(CONFIG_POP_2GDDR) || defined(CONFIG_POP_2GDDR_Ubuntu)
+                    nr_dram_banks = 8;
+#else
+                    nr_dram_banks = 4;
+#endif
+
+                    gd->bd->bi_dram[0].start = PHYS_SDRAM_1;
+                    gd->bd->bi_dram[0].size = PHYS_SDRAM_1_SIZE;
+                    gd->bd->bi_dram[1].start = PHYS_SDRAM_2;
+                    gd->bd->bi_dram[1].size = PHYS_SDRAM_2_SIZE;
+                    gd->bd->bi_dram[2].start = PHYS_SDRAM_3;
+                    gd->bd->bi_dram[2].size = PHYS_SDRAM_3_SIZE;
+                    gd->bd->bi_dram[3].start = PHYS_SDRAM_4;
+                    gd->bd->bi_dram[3].size = PHYS_SDRAM_4_SIZE;
+
+#if defined(CONFIG_POP_2GDDR) || defined(CONFIG_POP_2GDDR_Ubuntu)
+
+                    gd->bd->bi_dram[4].start = PHYS_SDRAM_5;
+                    gd->bd->bi_dram[4].size = PHYS_SDRAM_5_SIZE;
+                    gd->bd->bi_dram[5].start = PHYS_SDRAM_6;
+                    gd->bd->bi_dram[5].size = PHYS_SDRAM_6_SIZE;
+                    gd->bd->bi_dram[6].start = PHYS_SDRAM_7;
+                    gd->bd->bi_dram[6].size = PHYS_SDRAM_7_SIZE;
+                    gd->bd->bi_dram[7].start = PHYS_SDRAM_8;
+                    gd->bd->bi_dram[7].size = PHYS_SDRAM_8_SIZE;
+
+#endif
+			
 		}
 #else
 		nr_dram_banks = 2;
@@ -246,7 +266,17 @@
 				&& boot_mode == 0) {
 		//printf("board_late_init\n");
 		char boot_cmd[100];
+/* modify by cym 20131206 */
+#if 0
 		sprintf(boot_cmd, "movi read kernel 40008000;movi read rootfs 40d00000 100000;bootm 40008000 40d00000");
+#else
+#ifdef SMDK4412_SUPPORT_UBUNTU
+		sprintf(boot_cmd, "movi read kernel 40008000;bootm 40008000 40d00000");
+#else
+		sprintf(boot_cmd, "movi read kernel 40008000;movi read rootfs 40df0000 100000;bootm 40008000 40df0000");
+#endif
+#endif
+/* end modify */
 		setenv("bootcmd", boot_cmd);
 		}
 
@@ -310,6 +340,10 @@
 	sprintf(run_cmd,"emmc close 0");
 	run_command(run_cmd, 0);
 
+	/* add by cym 20130823 */
+	return 0;
+	/* end add */
+
 	if (memcmp((void *)(CFG_PHY_UBOOT_BASE+cmp_off),(void *)(CFG_PHY_KERNEL_BASE+cmp_off),blkcnt))
 	{
 		//printf("mem is different\n");
diff -urN TC4_uboot/build_uboot.sh iTop4412_uboot/build_uboot.sh
--- TC4_uboot/build_uboot.sh	2012-06-07 01:50:17.000000000 -0700
+++ iTop4412_uboot/build_uboot.sh	2015-11-09 00:59:35.000000000 -0800
@@ -1,36 +1,52 @@
 #!/bin/sh
-#./build_uboot.sh ---> build the uboot images for tc4
-#./build_uboot.sh tc4_plus -->build the uboot images for tc4_plus
-#./build_uboot.sh clean ----> clean the images
-#./build_uboot.sh windows ----> encrypt the uboot image in window pc
 
 
+if [ -z $1 ]
+then	
+   echo "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
+   echo "Please use correct make config.for example make SCP_1GDDR for SCP 1G DDR CoreBoard linux,android OS"
+   echo "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
+   exit 0
+fi
+
+if   [ "$1" = "SCP_1GDDR" ] ||   [ "$1" = "SCP_2GDDR" ] || [ "$1" = "SCP_1GDDR_Ubuntu" ] ||   [ "$1" = "SCP_2GDDR_Ubuntu" ]
+then 
+      sec_path="../CodeSign4SecureBoot_SCP/"
+      CoreBoard_type="SCP"
+
+elif [ "$1" = "POP_1GDDR" ] || [ "$1" = "POP_1GDDR_Ubuntu" ]
+then
+      sec_path="../CodeSign4SecureBoot_POP/"
+      CoreBoard_type="POP"
+
+elif [ "$1" = "POP_2GDDR" ] ||  [ "$1" = "POP_2GDDR_Ubuntu" ]
+then
+     sec_path="../CodeSign4SecureBoot_POP/"
+     CoreBoard_type="POP2G"
+else
+      echo "make config error,please use correct params......"
+      exit 0
+fi
 
-option1="tc4_plus"
-sec_path="../CodeSign4SecureBoot/"
+ 
 CPU_JOB_NUM=$(grep processor /proc/cpuinfo | awk '{field=$NF};END{print field+1}')
 ROOT_DIR=$(pwd)
 CUR_DIR=${ROOT_DIR##*/}
 
 
+
+#clean
+make distclean
+
+#rm link file
+rm ${ROOT_DIR}/board/samsung/smdkc210/lowlevel_init.S	
+rm ${ROOT_DIR}/cpu/arm_cortexa9/s5pc210/cpu_init.S
+
 case "$1" in
 	clean)
 		echo make clean
-		rm u-boot.bin
-		rm u-boot-exynos4412-evt0-nonfused.bin
-		rm u-boot-exynos4212-evt0-nonfused.bin
-		rm u-boot-exynos4412-evt1-efused.bin
 		make mrproper
 		;;
-	windows)
-		make tc4_android_config
-		make -j$CPU_JOB_NUM
-		echo "******************************************************************************************"
-		echo "[NOTICE]please copy "checksum_bl2_14k.bin" and "u-boot.bin" to your"
-		echo " windows pc for encryption and gernerate the final bin file for your using "
-		echo "******************************************************************************************"
-		;;
-		
 	*)
 			
 		if [ ! -d $sec_path ]
@@ -40,17 +56,39 @@
 			echo "**********************************************"
 			return
 		fi
-		
-		if [ -z $1 ]
-		then
-			make tc4_android_config
-		elif [ $1 = $option1 ]
-		then
-			make tc4_plus_android_config
-		else
-			echo please input right parameter.
-			exit 0
-		fi
+
+                if [ "$1" = "SCP_1GDDR" ]
+                then
+                	make itop_4412_android_config_scp_1GDDR
+
+                elif [ "$1" = "SCP_2GDDR" ]
+                then
+                       make itop_4412_android_config_scp_2GDDR
+
+                elif [ "$1" = "POP_1GDDR" ]
+                then
+                       make itop_4412_android_config_pop_1GDDR
+
+                elif [ "$1" = "POP_2GDDR" ]
+                then
+                       make itop_4412_android_config_pop_2GDDR
+
+                elif [ "$1" = "SCP_1GDDR_Ubuntu" ]	
+                then
+                       make itop_4412_ubuntu_config_scp_1GDDR
+
+                elif [ "$1" = "SCP_2GDDR_Ubuntu" ]
+                then
+                       make itop_4412_ubuntu_config_scp_2GDDR
+
+                elif [ "$1" = "POP_1GDDR_Ubuntu" ]
+                then
+                       make itop_4412_ubuntu_config_pop_1GDDR
+
+                elif [ "$1" = "POP_2GDDR_Ubuntu" ]
+                then
+                       make itop_4412_ubuntu_config_pop_2GDDR
+		fi	
 		
 		make -j$CPU_JOB_NUM
 		
@@ -67,30 +105,34 @@
 		rm checksum_bl2_14k.bin
 		
 		cd $sec_path
-		./codesigner_v21 -v2.1 checksum_bl2_14k.bin BL2.bin.signed.4412 Exynos4412_V21.prv -STAGE2
-		./codesigner_v21 -v2.1 checksum_bl2_14k.bin BL2.bin.signed.4212 Exynos4212_V21.prv -STAGE2
-		
-		
-		cat E4412.S.BL1.SSCR.EVT1.1.bin BL2.bin.signed.4412 paddingaa u-boot.bin > u-boot-exynos4412-evt1-efused.bin
-		cat E4212.S.BL1.SSCR.EVT1.1.bin BL2.bin.signed.4212 paddingaa u-boot.bin > u-boot-exynos4212-evt1-efused.bin
+		#./codesigner_v21 -v2.1 checksum_bl2_14k.bin BL2.bin.signed.4412 Exynos4412_V21.prv -STAGE2
 		
 		# gernerate the uboot bin file support trust zone
-		cat E4412.S.BL1.SSCR.EVT1.1.bin E4412.BL2.TZ.SSCR.EVT1.1.bin all00_padding.bin u-boot.bin E4412.TZ.SSCR.EVT1.1.bin > u-boot-exynos4412-evt1-efused-tz.bin
-		cat E4212.BL1.TZ.SSCR.EVT1.1.bin E4212.BL2.TZ.SSCR.EVT1.1.bin u-boot.bin E4212.TZ.SSCR.EVT1.1.bin > u-boot-exynos4212-evt1-efused-tz.bin
-		
-		
-		mv u-boot-exynos4212-evt1-efused.bin $ROOT_DIR
-		mv u-boot-exynos4412-evt1-efused.bin $ROOT_DIR
-		mv u-boot-exynos4412-evt1-efused-tz.bin $ROOT_DIR
-		mv u-boot-exynos4212-evt1-efused-tz.bin $ROOT_DIR
+		#cat E4412.S.BL1.SSCR.EVT1.1.bin E4412.BL2.TZ.SSCR.EVT1.1.bin all00_padding.bin u-boot.bin E4412.TZ.SSCR.EVT1.1.bin > u-boot-iTOP-4412.bin
+
+
+                if  [ "$CoreBoard_type" = "SCP" ]
+                then
+		        cat E4412_N.bl1.SCP2G.bin bl2.bin all00_padding.bin u-boot.bin tzsw_SMDK4412_SCP_2GB.bin > u-boot-iTOP-4412.bin
+
+                elif [ "$CoreBoard_type" = "POP" ]
+                then
+                   cat E4412.S.BL1.SSCR.EVT1.1.bin E4412.BL2.TZ.SSCR.EVT1.1.bin all00_padding.bin u-boot.bin E4412.TZ.SSCR.EVT1.1.bin > u-boot-iTOP-4412.bin
+
+                elif [ "$CoreBoard_type" = "POP2G"  ]
+                then
+                   cat bl2.bin u-boot.bin E4412.TZ.SSCR.EVT1.1.bin > u-boot-iTOP-4412.bin
+
+                else
+                   echo  "make uboot image error......" 
+                fi
+
+		mv u-boot-iTOP-4412.bin $ROOT_DIR
 		
 		rm checksum_bl2_14k.bin
-		rm BL2.bin.signed.4412
-		rm BL2.bin.signed.4212
+		#rm BL2.bin.signed.4412
 		rm u-boot.bin
 
-		echo u-boot-exynos4412-evt1-efused.bin generated for Quad core secure boot,use this one to fuse exyons 4412 evt1.
-		echo echo Please use sd_fusing.sh in sdfuse_q directory with su permission for programming the u-boot to SD card. Ex: ./sd_fusing.sh /dev/sdb
 		echo 
 		echo 
 		;;
diff -urN TC4_uboot/common/cmd_fastboot.c iTop4412_uboot/common/cmd_fastboot.c
--- TC4_uboot/common/cmd_fastboot.c	2012-04-24 01:02:09.000000000 -0700
+++ iTop4412_uboot/common/cmd_fastboot.c	2015-11-09 00:59:35.000000000 -0800
@@ -124,36 +124,11 @@
 #endif
 
 /* LCD */
-#ifdef CONFIG_LOGO_DISPLAY //mj
-extern void Exynose_LCD_setfgcolor(unsigned int color);
-extern void Exynose_LCD_setleftcolor(unsigned int color);
-extern void Exynose_LCD_setprogress(unsigned int color);
-extern void Exynos_LCD_turnon(void);
-
-void LCD_turnon(void) 
-{
-	//Exynos_LCD_turnon();
-	//exynos_display_pic(UPDATING_LOGO);
-}
-void LCD_setfgcolor(unsigned int color)
-{
- 	//Exynose_LCD_setfgcolor(color);
-}
-void LCD_setleftcolor(unsigned int color)
-{
-	//Exynose_LCD_setleftcolor(color);
-}
-void LCD_setprogress(int percentage)
-{
-	//Exynose_LCD_setprogress(percentage);
-}
-#else
 void LCD_turnon(void) {}
 void LCD_setfgcolor(unsigned int color){}
 void LCD_setleftcolor(unsigned int color){}
 void LCD_setprogress(int percentage){}
 
-#endif
 /* Forward decl */
 static int rx_handler (const unsigned char *buffer, unsigned int buffer_size);
 static void reset_handler (void);
@@ -585,15 +560,6 @@
 		}
 		#endif
 
-		#ifdef CONFIG_LOGO_DISPLAY
-		else if (!strcmp(ptn->name, "logo"))
-		{
-			strncpy(part, "logo", 7);
-			argv[4] = length;
-			sprintf(length, "0x%x",0);
-			argc++;
-		}
-		#endif
 		else	/* kernel, fwbl1 */
 		{
 			argv[2] = ptn->name;
@@ -1499,14 +1465,6 @@
 	ptable[pcount].flags = FASTBOOT_PTENTRY_FLAGS_USE_MOVI_CMD;
 	pcount++;
 	#endif
-
-	#ifdef CONFIG_LOGO_DISPLAY
-	strcpy(ptable[pcount].name, "logo");
-	ptable[pcount].start = 0;
-	ptable[pcount].length = 0; 
-	ptable[pcount].flags = FASTBOOT_PTENTRY_FLAGS_USE_MOVI_CMD;
-	pcount++;
-	#endif
 
 	/* System */
 	get_mmc_part_info((dev_number_write == 0)?"0":"1", 2, &start, &count, &pid);
diff -urN TC4_uboot/common/cmd_mmc_fdisk.c iTop4412_uboot/common/cmd_mmc_fdisk.c
--- TC4_uboot/common/cmd_mmc_fdisk.c	2012-05-23 02:33:29.000000000 -0700
+++ iTop4412_uboot/common/cmd_mmc_fdisk.c	2015-11-09 00:59:35.000000000 -0800
@@ -23,8 +23,8 @@
 #define		_1GB				(1024*1024*1024)
 #define		DISK_START			RAW_AREA_SIZE//mj (16*1024*1024) //same as raw area size
 
-#define		SYSTEM_PART_SIZE		_300MB
-#define		USER_DATA_PART_SIZE		_1GB
+#define		SYSTEM_PART_SIZE		_1GB //_300MB
+#define		USER_DATA_PART_SIZE		_1GB //_300MB //_1GB
 #define		CACHE_PART_SIZE			_300MB
 
 #define		CHS_MODE			0
@@ -65,7 +65,7 @@
 } PartitionInfo;
 
 /////////////////////////////////////////////////////////////////
-int calc_unit(int length, SDInfo sdInfo)
+unsigned int calc_unit(unsigned int length, SDInfo sdInfo)
 {
 	if (sdInfo.addr_mode == CHS_MODE)
 		return ( (length / BLOCK_SIZE / sdInfo.unit + 1 ) * sdInfo.unit);
@@ -167,8 +167,8 @@
 /////////////////////////////////////////////////////////////////
 void make_partitionInfo(int LBA_start, int count, SDInfo sdInfo, PartitionInfo *partInfo)
 {
-        int             temp = 0;
-        int             _10MB_unit;
+        unsigned int             temp = 0;
+        unsigned int             _10MB_unit;
 
         partInfo->block_start   = LBA_start;
 
@@ -231,7 +231,7 @@
 /////////////////////////////////////////////////////////////////
 int make_mmc_partition(int total_block_count, unsigned char *mbr, int flag, char *argv[])
 {
-	int		block_start = 0, block_offset;
+	unsigned int		block_start = 0, block_offset;
 
 	SDInfo		sdInfo;
 	PartitionInfo	partInfo[4];
@@ -245,7 +245,16 @@
 ///////////////////////////////////////////////////////////
 // 반드시 Unit단위로 먼저 계산한다.
 	block_start	= calc_unit(DISK_START, sdInfo);
+/* modify by cym 20131206 */
+#if 0
 	block_offset	= calc_unit(SYSTEM_PART_SIZE, sdInfo);
+#else
+	if (flag)
+		block_offset = calc_unit((unsigned long long)simple_strtoul(argv[3], NULL, 0)*1024*1024, sdInfo);
+	else
+		block_offset = calc_unit(SYSTEM_PART_SIZE, sdInfo);
+#endif
+/* end modify */
 
 	partInfo[0].bootable	= 0x00;
 	partInfo[0].partitionId	= 0x83;
@@ -254,10 +263,24 @@
 
 ///////////////////////////////////////////////////////////	
 	block_start += block_offset;
+/* modify by cym 20131206 */
+#if 0
 	if (strcmp(argv[2], "1") == 0)// TF card
 		block_offset = calc_unit(_300MB, sdInfo);
 	else
 		block_offset = calc_unit(USER_DATA_PART_SIZE, sdInfo);
+#else
+	if (flag)
+		block_offset = calc_unit((unsigned long long)simple_strtoul(argv[4], NULL, 0)*1024*1024, sdInfo);
+	else
+	{
+		if (strcmp(argv[2], "1") == 0)// TF card
+			block_offset = calc_unit(_300MB, sdInfo);
+		else
+			block_offset = calc_unit(USER_DATA_PART_SIZE, sdInfo);
+	}
+#endif
+/* end modify */
 	
 	partInfo[1].bootable	= 0x00;
 	partInfo[1].partitionId	= 0x83;
@@ -266,7 +289,16 @@
 
 ///////////////////////////////////////////////////////////	
 	block_start += block_offset;
+/* modify by cym 20131206 */
+#if 0
 	block_offset = calc_unit(CACHE_PART_SIZE, sdInfo);
+#else
+	if(flag)
+		block_offset = calc_unit((unsigned long long)simple_strtoul(argv[5], NULL, 0)*1024*1024, sdInfo);
+	else
+		block_offset = calc_unit(CACHE_PART_SIZE, sdInfo);
+#endif
+/* end modify */
 	
 	partInfo[2].bootable	= 0x00;
 	partInfo[2].partitionId	= 0x83;
diff -urN TC4_uboot/common/cmd_movi.c iTop4412_uboot/common/cmd_movi.c
--- TC4_uboot/common/cmd_movi.c	2012-04-24 01:02:09.000000000 -0700
+++ iTop4412_uboot/common/cmd_movi.c	2015-11-09 00:59:35.000000000 -0800
@@ -148,19 +148,6 @@
 			raw_area_control.image[i].used_blk = 0;
 		}
 		
-		#ifdef CONFIG_LOGO_DISPLAY
-		/* image 8 should be logo part */
-		image[8].start_blk = (LOGO_PARTITION_START/MOVI_BLKSIZE);
-		image[8].used_blk =PART_SIZE_LOGO /MOVI_BLKSIZE + ((PART_SIZE_LOGO&(MOVI_BLKSIZE-1)) ? 1 : 0);
-		image[8].size = image[8].used_blk * MOVI_BLKSIZE;
-		if((image[8].size * CFG_MAX_LOGO_NUM)>(RAW_AREA_SIZE-LOGO_PARTITION_START))
-			printf("****[ERROR]*** There are too many logos to display\n");
-			
-		image[8].attribute = 0x30;
-		strcpy(image[8].description, "logo");
-		dbg("logo: %d\n", image[8].start_blk);
-
-		#endif
 		
 	}
 
@@ -242,14 +229,6 @@
 		addr = simple_strtoul(argv[3], NULL, 16);
 		break;		
 
-	#ifdef CONFIG_LOGO_DISPLAY
-	case 'l':
-		if (argc != 5)
-			goto usage;
-		attribute = 0x30;
-		addr = simple_strtoul(argv[3], NULL, 16);
-		break;
-	#endif
 	
 	default:
 		goto usage;
@@ -536,55 +515,6 @@
 		printf("completed\n");
 		return 1;
 	}
-		/* logo pic image.. r/w */
-	#ifdef CONFIG_LOGO_DISPLAY
-	if (attribute == 0x30) {
-		//rfs_size = simple_strtoul(argv[5], NULL, 16);
-		int pic_index = simple_strtoul(argv[4], NULL, 16);
-		
-		for (i=0, image = raw_area_control.image; i<15; i++) {
-			if (image[i].attribute == attribute)
-				break;
-		}
-		
-				
-		if(rw == 0)//read case
-		{
-			start_blk = image[i].start_blk + pic_index * image[i].used_blk;
-			blkcnt =image[i].used_blk ; 
-		}
-		else if (rw == 1)//write case
-		{
-			start_blk = image[i].start_blk;
-			blkcnt =image[i].used_blk *CFG_MAX_LOGO_NUM ; 
-		}
-		
-		
-		printf("%s logo.. %ld, %ld ", rw ? "writing":"reading",
-				start_blk, blkcnt);
-		
-		if (1 == fuse_by_fastboot)
-			sprintf(run_cmd, "mmc %s %s 0x%lx 0x%lx 0x%lx",
-					rw ? "write" : "read", dev_number_write ? "1" : "0",
-					addr, start_blk, blkcnt);
-		else
-		{
-			#if 0
-			if (key1_pulldown == 1)
-				sprintf(run_cmd,"mmc %s 1 0x%lx 0x%lx 0x%lx",
-						rw ? "write":"read",
-						addr, start_blk, blkcnt);
-			else
-			#endif
-				sprintf(run_cmd,"mmc %s %d 0x%lx 0x%lx 0x%lx",
-						rw ? "write":"read",boot_dev,
-						addr, start_blk, blkcnt);
-		}
-		run_command(run_cmd, 0);
-		printf("completed\n");
-		return 1;
-	}
-	#endif
 
 usage:
 	printf("Usage:\n%s\n", cmdtp->usage);
diff -urN TC4_uboot/cpu/arm_cortexa9/s5pc210/cpu_init_POP.S iTop4412_uboot/cpu/arm_cortexa9/s5pc210/cpu_init_POP.S
--- TC4_uboot/cpu/arm_cortexa9/s5pc210/cpu_init_POP.S	1969-12-31 16:00:00.000000000 -0800
+++ iTop4412_uboot/cpu/arm_cortexa9/s5pc210/cpu_init_POP.S	2015-11-12 09:59:34.000000000 -0800
@@ -0,0 +1,723 @@
+#include <config.h>
+#include <s5pc210.h>
+
+//#define SET_MIU
+
+@ MIU (Memory Interleaving Unit)
+//#define MIU_LINEAR
+//#define MIU_1BIT_INTERLEAVED
+//#define MIU_2BIT_INTERLEAVED
+
+//#define MIU_1BIT_12_INTERLEAVED
+//#define MIU_1BIT_7_INTERLEAVED
+//#define MIU_2BIT_21_12_INTERLEAVED
+#define MIU_2BIT_21_7_INTERLEAVED
+
+#define MEM_DLL
+
+#ifdef CONFIG_CLK_800_330_165
+#define DRAM_CLK_330
+#endif
+#ifdef CONFIG_CLK_1000_200_200
+#define DRAM_CLK_200
+#endif
+#ifdef CONFIG_CLK_1000_330_165
+#define DRAM_CLK_330
+#endif
+#ifdef CONFIG_CLK_1000_400_200
+#define DRAM_CLK_400
+#endif
+
+	.globl mem_ctrl_asm_init
+mem_ctrl_asm_init:
+
+	/* Async bridge configuration at CPU_core */
+	/* 1: half_sync */
+	/* 0: full_sync */
+	ldr r0, =0x10010350
+	mov r1, #1
+	str r1, [r0]
+	
+/* liyang 20110822 removed it for tc4
+	ldr	r0, =CHIP_ID_BASE
+	ldr	r1, [r0]
+	lsr	r1, r1, #8
+	and	r1, r1, #3
+	cmp	r1, #2
+	bne	v310
+*/
+
+	/* CLK_DIV_DMC0 on iROM DMC=50MHz for Init DMC */
+	ldr	r0, =CMU_BASE	@0x1003_0000
+	ldr	r1, =0x13113113
+	ldr	r2, =CLK_DIV_DMC0_OFFSET
+	str	r1, [r0, r2]
+
+
+#ifdef SET_MIU
+	ldr	r0, =MIU_BASE
+#ifdef CONFIG_EVT1
+	#ifdef MIU_1BIT_12_INTERLEAVED
+	ldr	r1, =0x0000000c
+	str	r1, [r0, #MIU_INTLV_CONFIG]
+	ldr	r1, =0x00000001
+	str	r1, [r0, #MIU_REG_UPDATE]
+	#endif
+	#ifdef MIU_1BIT_7_INTERLEAVED
+	ldr     r1, =0x00000007
+	str     r1, [r0, #MIU_INTLV_CONFIG]
+	ldr     r1, =0x00000001
+	str     r1, [r0, #MIU_REG_UPDATE]
+	#endif
+	#ifdef MIU_2BIT_21_12_INTERLEAVED
+	ldr     r1, =0x2000150C
+	str     r1, [r0, #MIU_INTLV_CONFIG]
+	ldr     r1, =0x00000001
+	str     r1, [r0, #MIU_REG_UPDATE]
+	#endif
+	#ifdef MIU_2BIT_21_7_INTERLEAVED
+	ldr     r1, =0x20001507
+	str     r1, [r0, #MIU_INTLV_CONFIG]
+	ldr     r1, =0x00000001
+	str     r1, [r0, #MIU_REG_UPDATE]
+	#endif
+#else
+
+#ifdef MIU_1BIT_INTERLEAVED
+	ldr	r1, =0x0000000c				
+	str	r1, [r0, #MIU_INTLV_CONFIG]
+	ldr	r1, =0x40000000				
+	str	r1, [r0, #MIU_INTLV_START_ADDR]
+	ldr	r1, =0x5fffffff				
+	str	r1, [r0, #MIU_INTLV_END_ADDR]
+	ldr	r1, =0x00000001          				
+	str	r1, [r0, #MIU_MAPPING_UPDATE]
+#elif MIU_2BIT_INTERLEAVED
+	ldr	r1, =0x2000150c				
+	str	r1, [r0, #MIU_INTLV_CONFIG]
+	ldr	r1, =0x40000000				
+	str	r1, [r0, #MIU_INTLV_START_ADDR]
+	ldr	r1, =0x5fffffff				
+	str	r1, [r0, #MIU_INTLV_END_ADDR]
+	ldr	r1, =0x00000001          				
+	str	r1, [r0, #MIU_MAPPING_UPDATE]
+#else MIU_LINEAR
+	ldr	r1, =0x40000000				
+	str	r1, [r0, #MIU_SINGLE_MAPPING0_START_ADDR]
+	ldr	r1, =0x4fffffff				
+	str	r1, [r0, #MIU_SINGLE_MAPPING0_END_ADDR]
+	ldr	r1, =0x50000000				
+	str	r1, [r0, #MIU_SINGLE_MAPPING1_START_ADDR]
+	ldr	r1, =0x5fffffff          				
+	str	r1, [r0, #MIU_SINGLE_MAPPING1_END_ADDR]
+	ldr	r1, =0x00000006          				
+	str	r1, [r0, #MIU_MAPPING_UPDATE]
+#endif
+#endif
+
+#endif
+
+
+//ly added
+
+	ldr   r0, =0x10040500
+	ldr	r1, =0x00117713				
+	str	r1, [r0]
+
+		ldr   r0, =0x10020A00
+	ldr	r1, =0x00000000				
+	str	r1, [r0]
+
+			ldr   r0, =0x10040A00
+	ldr	r1, =0x00010905				
+	str	r1, [r0]
+
+
+/*****************************************************************/
+/*DREX0***********************************************************/
+/*****************************************************************/
+
+	ldr	r0, =APB_DMC_0_BASE 
+
+	ldr	r1, =0xE3855403 //0xE3855503				
+	str	r1, [r0, #DMC_PHYZQCONTROL]
+
+	ldr	r1, =0x71101008				
+	str	r1, [r0, #DMC_PHYCONTROL0]
+
+	ldr	r1, =0x7110100A				
+	str	r1, [r0, #DMC_PHYCONTROL0]
+
+	ldr	r1, =0x00000084				
+	str	r1, [r0, #DMC_PHYCONTROL1]
+
+	ldr	r1, =0x71101008				
+	str	r1, [r0, #DMC_PHYCONTROL0]
+
+	ldr	r1, =0x0000008C				
+	str	r1, [r0, #DMC_PHYCONTROL1]
+
+	ldr	r1, =0x00000084				
+	str	r1, [r0, #DMC_PHYCONTROL1]
+
+	ldr	r1, =0x0000008C				
+	str	r1, [r0, #DMC_PHYCONTROL1]
+
+	ldr	r1, =0x00000084				
+	str	r1, [r0, #DMC_PHYCONTROL1]
+
+	//ldr	r1, =0x00000000			
+	//str	r1, [r0, #DMC_PHYCONTROL2]
+
+	ldr	r1, =0x0FFF30CA//0x0FFF30da				
+	str	r1, [r0, #DMC_CONCONTROL]
+	ldr	r1, =0x00202500				
+	str	r1, [r0, #DMC_MEMCONTROL]
+	//ldr	r1, =0x20f01223				
+	ldr	r1, =0x40C01323
+	str	r1, [r0, #DMC_MEMCONFIG0]
+
+
+	/*liyang 20110822 Interleave on 512M*/
+	ldr	r1, =0x8000001D				
+	str	r1, [r0, #DMC_IvControl]
+
+	
+	ldr	r1, =0xff000000			
+	str	r1, [r0, #DMC_PRECHCONFIG]
+
+	ldr	r1, =0x0000005D    				
+	str	r1, [r0, #DMC_TIMINGAREF] @TimingAref
+
+#ifdef DRAM_CLK_200
+111
+	ldr	r1, =0x1A254349				
+	str	r1, [r0, #DMC_TIMINGROW]
+	ldr	r1, =0x23230306			
+	str	r1, [r0, #DMC_TIMINGDATA]
+	ldr	r1, =0x281c0235				
+	str	r1, [r0, #DMC_TIMINGPOWER]
+#endif
+#ifdef DRAM_CLK_330
+111
+	ldr	r1, =0x2b47654e				
+	str	r1, [r0, #DMC_TIMINGROW]
+	ldr	r1, =0x35330306			
+	str	r1, [r0, #DMC_TIMINGDATA]
+	ldr	r1, =0x442f0365				
+	str	r1, [r0, #DMC_TIMINGPOWER]
+#endif
+#ifdef DRAM_CLK_400
+
+	ldr	r1, =0x34498691    				
+	str	r1, [r0, #DMC_TIMINGROW] @TimingRow
+	ldr	r1, =0x36330306    				
+	str	r1, [r0, #DMC_TIMINGDATA] @TimingData
+	ldr	r1, =0x50380365    				
+	str	r1, [r0, #DMC_TIMINGPOWER] @TimingPower
+#endif
+
+	mov	r2, #0x100000
+2:	subs	r2, r2, #1
+	bne	2b
+	ldr	r1, =0x07000000       				
+	str	r1, [r0, #DMC_DIRECTCMD] 
+	mov	r2, #0x100000
+3:	subs	r2, r2, #1
+	bne	3b
+	ldr	r1, =0x00071C00       				
+	str	r1, [r0, #DMC_DIRECTCMD] 
+	mov	r2, #0x100000
+4:	subs	r2, r2, #1
+	bne	4b
+
+	ldr	r1, =0x00010BFC       				
+	str	r1, [r0, #DMC_DIRECTCMD] 
+	mov	r2, #0x100000
+5:	subs	r2, r2, #1
+	bne	5b
+	ldr	r1, =0x00000488       				
+	str	r1, [r0, #DMC_DIRECTCMD] 
+	ldr	r1, =0x00000810       				
+	str	r1, [r0, #DMC_DIRECTCMD] 
+	ldr	r1, =0x00000C08       				
+	str	r1, [r0, #DMC_DIRECTCMD] 
+
+#ifdef CONFIG_EVT1__
+	/* get DMC density information */
+	ldr	r1, =0x09010000
+	mov	r3, #10
+6:	str	r1, [r0, #DMC_DIRECTCMD]
+	mov	r2, #0x10000
+7:	subs	r2, r2, #1
+	bne	7b
+	ldr	r6, [r0, #DMC_MRSTATUS]
+	subs	r3, r3, #1
+	bne	6b
+	and	r6, r6, #0x3c
+	lsr	r6, r6, #2
+	cmp	r6, #6
+	ldreq	r1, =0x20e01323
+	ldrne	r1, =0x20f01223   
+	str	r1, [r0, #DMC_MEMCONFIG0]
+#endif
+
+
+
+//#ifdef MEM_1
+
+/*****************************************************************/
+/*DREX1***********************************************************/
+/*****************************************************************/
+	ldr	r0, =APB_DMC_1_BASE 
+	ldr	r1, =0xE3855403 //0xE3855503					
+	str	r1, [r0, #DMC_PHYZQCONTROL]
+
+	ldr	r1, =0x71101008				
+	str	r1, [r0, #DMC_PHYCONTROL0]
+
+	ldr	r1, =0x7110100A				
+	str	r1, [r0, #DMC_PHYCONTROL0]
+
+	ldr	r1, =0x00000084				
+	str	r1, [r0, #DMC_PHYCONTROL1]
+
+	ldr	r1, =0x71101008				
+	str	r1, [r0, #DMC_PHYCONTROL0]
+
+	ldr	r1, =0x0000008C				
+	str	r1, [r0, #DMC_PHYCONTROL1]
+
+	ldr	r1, =0x00000084				
+	str	r1, [r0, #DMC_PHYCONTROL1]
+
+	ldr	r1, =0x0000008C				
+	str	r1, [r0, #DMC_PHYCONTROL1]
+
+	ldr	r1, =0x00000084				
+	str	r1, [r0, #DMC_PHYCONTROL1]
+
+	//ldr	r1, =0x00000000			
+	//str	r1, [r0, #DMC_PHYCONTROL2]
+
+	ldr	r1, =0x0FFF30CA//0x0FFF30da	
+	str	r1, [r0, #DMC_CONCONTROL]
+	ldr	r1, =0x00202500				
+	str	r1, [r0, #DMC_MEMCONTROL]
+	//ldr	r1, =0x20f01223
+	ldr	r1, =0x40C01323
+	str	r1, [r0, #DMC_MEMCONFIG0]
+
+	/*liyang 20110822 Interleave on 512M*/
+	ldr	r1, =0x8000001D				
+	str	r1, [r0, #DMC_IvControl]
+
+
+	
+	ldr	r1, =0xff000000			
+	str	r1, [r0, #DMC_PRECHCONFIG]
+
+	ldr	r1, =0x0000005D    				
+	str	r1, [r0, #DMC_TIMINGAREF] @TimingAref
+
+#ifdef DRAM_CLK_200
+	ldr	r1, =0x1A254349				
+	str	r1, [r0, #DMC_TIMINGROW]
+	ldr	r1, =0x23230306			
+	str	r1, [r0, #DMC_TIMINGDATA]
+	ldr	r1, =0x281c0235				
+	str	r1, [r0, #DMC_TIMINGPOWER]
+#endif
+#ifdef DRAM_CLK_330
+	ldr	r1, =0x2b47654e				
+	str	r1, [r0, #DMC_TIMINGROW]
+	ldr	r1, =0x35330306			
+	str	r1, [r0, #DMC_TIMINGDATA]
+	ldr	r1, =0x442f0365
+	str	r1, [r0, #DMC_TIMINGPOWER]
+#endif
+#ifdef DRAM_CLK_400
+	ldr	r1, =0x34498691    				
+	str	r1, [r0, #DMC_TIMINGROW] @TimingRow
+	ldr	r1, =0x36330306    				
+	str	r1, [r0, #DMC_TIMINGDATA] @TimingData
+	ldr	r1, =0x50380365
+	str	r1, [r0, #DMC_TIMINGPOWER] @TimingPower
+#endif
+
+	mov	r2, #0x100000
+2:	subs	r2, r2, #1
+	bne	2b
+	ldr	r1, =0x07000000       				
+	str	r1, [r0, #DMC_DIRECTCMD] 
+	mov	r2, #0x100000
+3:	subs	r2, r2, #1
+	bne	3b
+	ldr	r1, =0x00071C00       				
+	str	r1, [r0, #DMC_DIRECTCMD] 
+	mov	r2, #0x100000
+4:	subs	r2, r2, #1
+	bne	4b
+
+	ldr	r1, =0x00010BFC       				
+	str	r1, [r0, #DMC_DIRECTCMD] 
+	mov	r2, #0x100000
+5:	subs	r2, r2, #1
+	bne	5b
+	ldr	r1, =0x00000488       				
+	str	r1, [r0, #DMC_DIRECTCMD] 
+	ldr	r1, =0x00000810       				
+	str	r1, [r0, #DMC_DIRECTCMD] 
+	ldr	r1, =0x00000C08
+	str	r1, [r0, #DMC_DIRECTCMD] 
+
+
+#ifdef CONFIG_EVT1__
+	/* get DMC density information */
+	ldr	r1, =0x09010000
+	mov	r3, #10
+6:	str	r1, [r0, #DMC_DIRECTCMD]
+	mov	r2, #0x10000
+7:	subs	r2, r2, #1
+	bne	7b
+	ldr	r7, [r0, #DMC_MRSTATUS]
+	subs	r3, r3, #1
+	bne	6b
+	and	r7, r7, #0x3c
+	lsr	r7, r7, #2
+	cmp	r7, #6
+	ldreq	r1, =0x20e01323
+	ldrne	r1, =0x20f01223   
+	str	r1, [r0, #DMC_MEMCONFIG0]
+#endif
+//#endif //ifdef MEM_1
+
+
+	mov	pc, lr
+
+/*****************************************************/
+v310:
+
+#ifdef SET_MIU
+	ldr	r0, =MIU_BASE
+#ifdef CONFIG_MIU_1BIT_INTERLEAVED
+	ldr	r1, =0x0000000c				
+	str	r1, [r0, #MIU_INTLV_CONFIG]
+	ldr	r1, =0x40000000				
+	str	r1, [r0, #MIU_INTLV_START_ADDR]
+	ldr	r1, =0xbfffffff				
+	str	r1, [r0, #MIU_INTLV_END_ADDR]
+	ldr	r1, =0x00000001          				
+	str	r1, [r0, #MIU_MAPPING_UPDATE]
+#endif
+#ifdef CONFIG_MIU_2BIT_INTERLEAVED
+	ldr	r1, =0x2000150c				
+	str	r1, [r0, #MIU_INTLV_CONFIG]
+	ldr	r1, =0x40000000
+	str	r1, [r0, #MIU_INTLV_START_ADDR]
+	ldr	r1, =0xbfffffff				
+	str	r1, [r0, #MIU_INTLV_END_ADDR]
+	ldr	r1, =0x00000001          				
+	str	r1, [r0, #MIU_MAPPING_UPDATE]
+#endif
+#ifdef CONFIG_MIU_LINEAR
+	ldr	r1, =0x40000000				
+	str	r1, [r0, #MIU_SINGLE_MAPPING0_START_ADDR]
+	ldr	r1, =0x7fffffff				
+	str	r1, [r0, #MIU_SINGLE_MAPPING0_END_ADDR]
+	ldr	r1, =0x80000000				
+	str	r1, [r0, #MIU_SINGLE_MAPPING1_START_ADDR]
+	ldr	r1, =0xbfffffff          				
+	str	r1, [r0, #MIU_SINGLE_MAPPING1_END_ADDR]
+	ldr	r1, =0x00000006          				
+	str	r1, [r0, #MIU_MAPPING_UPDATE]
+#endif
+#endif
+
+/*****************************************************************/
+/*DREX0***********************************************************/
+/*****************************************************************/
+
+	ldr	r0, =APB_DMC_0_BASE
+
+	ldr	r1, =0xe0000086				
+	str	r1, [r0, #DMC_PHYCONTROL1]
+
+	ldr	r1, =0xE3855703				
+	str	r1, [r0, #DMC_PHYZQCONTROL]
+
+	mov	r2, #0x100000
+1:	subs	r2, r2, #1
+	bne	1b
+
+	ldr	r1, =0xe000008e
+	str	r1, [r0, #DMC_PHYCONTROL1]
+	ldr	r1, =0xe0000086				
+	str	r1, [r0, #DMC_PHYCONTROL1]
+
+	ldr	r1, =0x71101008				
+	str	r1, [r0, #DMC_PHYCONTROL0]
+	ldr	r1, =0x7110100A				
+	str	r1, [r0, #DMC_PHYCONTROL0]
+	ldr	r1, =0xe0000086				
+	str	r1, [r0, #DMC_PHYCONTROL1]
+	ldr	r1, =0x7110100B				
+	str	r1, [r0, #DMC_PHYCONTROL0]
+
+	ldr	r1, =0x00000000				
+	str	r1, [r0, #DMC_PHYCONTROL2]
+
+	ldr	r1, =0x0FFF301A
+	str	r1, [r0, #DMC_CONCONTROL]
+	ldr	r1, =0x00312640
+	str	r1, [r0, #DMC_MEMCONTROL]
+
+#ifdef MIU_LINEAR
+	ldr	r1, =0x40e01323
+	str	r1, [r0, #DMC_MEMCONFIG0]
+	ldr	r1, =0x60e01323
+	str	r1, [r0, #DMC_MEMCONFIG1]
+#else	@MIU_1BIT_INTERLEAVED | MIU_2BIT_INTERLEAVED
+	ldr	r1, =0x20e01323
+	str	r1, [r0, #DMC_MEMCONFIG0]
+	ldr	r1, =0x40e01323
+	str	r1, [r0, #DMC_MEMCONFIG1]
+#endif
+
+	ldr	r1, =0xff000000
+	str	r1, [r0, #DMC_PRECHCONFIG]
+
+	ldr	r1, =0x000000BC
+	str	r1, [r0, #DMC_TIMINGAREF] @TimingAref
+
+#ifdef DRAM_CLK_330
+	ldr	r1, =0x3545548d
+	str	r1, [r0, #DMC_TIMINGROW]
+	ldr	r1, =0x45430506
+	str	r1, [r0, #DMC_TIMINGDATA]
+	ldr	r1, =0x46000A3c
+	str	r1, [r0, #DMC_TIMINGPOWER]
+#endif
+#ifdef DRAM_CLK_400
+	ldr	r1, =0x4046654f
+	str	r1, [r0, #DMC_TIMINGROW] @TimingRow
+	ldr	r1, =0x56500506
+	str	r1, [r0, #DMC_TIMINGDATA] @TimingData
+	ldr	r1, =0x5444033d
+	str	r1, [r0, #DMC_TIMINGPOWER] @TimingPower
+#endif
+
+	ldr	r1, =0x07000000
+	str	r1, [r0, #DMC_DIRECTCMD]
+
+	mov	r2, #0x100000
+2:	subs	r2, r2, #1
+	bne	2b
+
+	ldr	r1, =0x00020000
+	str	r1, [r0, #DMC_DIRECTCMD]
+	ldr	r1, =0x00030000
+	str	r1, [r0, #DMC_DIRECTCMD]
+	ldr	r1, =0x00010002
+	str	r1, [r0, #DMC_DIRECTCMD]
+	ldr	r1, =0x00000328
+	str	r1, [r0, #DMC_DIRECTCMD]
+
+	mov	r2, #0x100000
+3:	subs	r2, r2, #1
+	bne	3b
+
+	ldr	r1, =0x0a000000
+	str	r1, [r0, #DMC_DIRECTCMD]
+
+	mov	r2, #0x100000
+4:	subs	r2, r2, #1
+	bne	4b
+
+	ldr	r1, =0x07100000
+	str	r1, [r0, #DMC_DIRECTCMD]
+
+	mov	r2, #0x100000
+5:	subs	r2, r2, #1
+	bne	5b
+
+	ldr	r1, =0x00120000
+	str	r1, [r0, #DMC_DIRECTCMD]
+	ldr	r1, =0x00130000
+	str	r1, [r0, #DMC_DIRECTCMD]
+	ldr	r1, =0x00110002
+	str	r1, [r0, #DMC_DIRECTCMD]
+	ldr	r1, =0x00100328
+	str	r1, [r0, #DMC_DIRECTCMD]
+
+	mov	r2, #0x100000
+6:	subs	r2, r2, #1
+	bne	6b
+
+	ldr	r1, =0x0a100000
+	str	r1, [r0, #DMC_DIRECTCMD]
+
+	mov	r2, #0x100000
+7:	subs	r2, r2, #1
+	bne	7b
+
+	ldr	r1, =0xe000008e
+	str	r1, [r0, #DMC_PHYCONTROL1]
+	ldr	r1, =0xe0000086
+	str	r1, [r0, #DMC_PHYCONTROL1]
+
+	mov	r2, #0x100000
+8:	subs	r2, r2, #1
+	bne	8b
+
+/*****************************************************************/
+/*DREX1***********************************************************/
+/*****************************************************************/
+
+	ldr	r0, =APB_DMC_1_BASE
+
+	ldr	r1, =0xe0000086				
+	str	r1, [r0, #DMC_PHYCONTROL1]
+
+	ldr	r1, =0xE3855703				
+	str	r1, [r0, #DMC_PHYZQCONTROL]
+
+	mov	r2, #0x100000
+1:	subs	r2, r2, #1
+	bne	1b
+
+	ldr	r1, =0xe000008e
+	str	r1, [r0, #DMC_PHYCONTROL1]
+	ldr	r1, =0xe0000086				
+	str	r1, [r0, #DMC_PHYCONTROL1]
+
+	ldr	r1, =0x71101008				
+	str	r1, [r0, #DMC_PHYCONTROL0]
+	ldr	r1, =0x7110100A				
+	str	r1, [r0, #DMC_PHYCONTROL0]
+	ldr	r1, =0xe0000086				
+	str	r1, [r0, #DMC_PHYCONTROL1]
+	ldr	r1, =0x7110100B				
+	str	r1, [r0, #DMC_PHYCONTROL0]
+
+	ldr	r1, =0x00000000				
+	str	r1, [r0, #DMC_PHYCONTROL2]
+
+	ldr	r1, =0x0fff301a
+	str	r1, [r0, #DMC_CONCONTROL]
+	ldr 	r1, =0x00312640
+	str	r1, [r0, #DMC_MEMCONTROL]
+
+#ifdef MIU_LINEAR
+	ldr	r1, =0x40e01323
+	str	r1, [r0, #DMC_MEMCONFIG0]
+	ldr	r1, =0x60e01323
+	str	r1, [r0, #DMC_MEMCONFIG1]
+#else	@MIU_1BIT_INTERLEAVED | MIU_2BIT_INTERLEAVED
+	ldr	r1, =0x20e01323				
+	str	r1, [r0, #DMC_MEMCONFIG0]
+	ldr	r1, =0x40e01323
+	str	r1, [r0, #DMC_MEMCONFIG1]
+#endif
+
+	ldr	r1, =0xff000000			
+	str	r1, [r0, #DMC_PRECHCONFIG]
+
+	ldr	r1, =0x000000BC
+	str	r1, [r0, #DMC_TIMINGAREF] @TimingAref
+
+#ifdef DRAM_CLK_330
+	ldr	r1, =0x3545548d
+	str	r1, [r0, #DMC_TIMINGROW]
+	ldr	r1, =0x45430506
+	str	r1, [r0, #DMC_TIMINGDATA]
+	ldr	r1, =0x4439033c
+	str	r1, [r0, #DMC_TIMINGPOWER]
+#endif
+#ifdef DRAM_CLK_400
+	ldr	r1, =0x4046654f
+	str	r1, [r0, #DMC_TIMINGROW] @TimingRow
+	ldr	r1, =0x56500506
+	str	r1, [r0, #DMC_TIMINGDATA] @TimingData
+	ldr	r1, =0x5444033d
+	str	r1, [r0, #DMC_TIMINGPOWER] @TimingPower
+#endif
+
+	ldr	r1, =0x07000000
+	str	r1, [r0, #DMC_DIRECTCMD]
+
+	mov	r2, #0x100000
+2:	subs	r2, r2, #1
+	bne	2b
+
+	ldr	r1, =0x00020000
+	str	r1, [r0, #DMC_DIRECTCMD]
+	ldr	r1, =0x00030000
+	str	r1, [r0, #DMC_DIRECTCMD]
+	ldr	r1, =0x00010002
+	str	r1, [r0, #DMC_DIRECTCMD]
+	ldr	r1, =0x00000328
+	str	r1, [r0, #DMC_DIRECTCMD]
+
+	mov	r2, #0x100000
+3:	subs	r2, r2, #1
+	bne	3b
+
+	ldr	r1, =0x0a000000
+	str	r1, [r0, #DMC_DIRECTCMD]
+
+	mov	r2, #0x100000
+4:	subs	r2, r2, #1
+	bne	4b
+
+	ldr	r1, =0x07100000
+	str	r1, [r0, #DMC_DIRECTCMD]
+
+	mov	r2, #0x100000
+5:	subs	r2, r2, #1
+	bne	5b
+
+	ldr	r1, =0x00120000
+	str	r1, [r0, #DMC_DIRECTCMD]
+	ldr	r1, =0x00130000
+	str	r1, [r0, #DMC_DIRECTCMD]
+	ldr	r1, =0x00110002
+	str	r1, [r0, #DMC_DIRECTCMD]
+	ldr	r1, =0x00100328
+	str	r1, [r0, #DMC_DIRECTCMD]
+
+	mov	r2, #0x100000
+6:	subs	r2, r2, #1
+	bne	6b
+
+	ldr	r1, =0x0a100000
+	str	r1, [r0, #DMC_DIRECTCMD]
+
+	mov	r2, #0x100000
+7:	subs	r2, r2, #1
+	bne	7b
+
+	ldr	r1, =0xe000008e
+	str	r1, [r0, #DMC_PHYCONTROL1]
+	ldr	r1, =0xe0000086
+	str	r1, [r0, #DMC_PHYCONTROL1]
+
+	mov	r2, #0x100000
+8:	subs	r2, r2, #1
+	bne	8b
+
+/*****************************************************************/
+/* turn on DREX0, DREX1 ******************************************/
+/*****************************************************************/
+
+	ldr	r0, =APB_DMC_0_BASE
+	ldr	r1, =0x0FFF303a
+	str	r1, [r0, #DMC_CONCONTROL]
+
+	ldr	r0, =APB_DMC_1_BASE
+	ldr	r1, =0x0FFF303a
+	str	r1, [r0, #DMC_CONCONTROL]
+
+	mov	pc, lr
+
+
diff -urN TC4_uboot/cpu/arm_cortexa9/s5pc210/cpu_init_SCP.S iTop4412_uboot/cpu/arm_cortexa9/s5pc210/cpu_init_SCP.S
--- TC4_uboot/cpu/arm_cortexa9/s5pc210/cpu_init_SCP.S	1969-12-31 16:00:00.000000000 -0800
+++ iTop4412_uboot/cpu/arm_cortexa9/s5pc210/cpu_init_SCP.S	2015-11-09 00:59:36.000000000 -0800
@@ -0,0 +1,391 @@
+#include <config.h>
+#include <s5pc210.h>
+
+//#define SET_MIU
+
+@ MIU (Memory Interleaving Unit)
+//#define MIU_LINEAR
+//#define MIU_1BIT_INTERLEAVED
+//#define MIU_2BIT_INTERLEAVED
+
+//#define MIU_1BIT_12_INTERLEAVED
+//#define MIU_1BIT_7_INTERLEAVED
+//#define MIU_2BIT_21_12_INTERLEAVED
+#define MIU_2BIT_21_7_INTERLEAVED
+
+#define MEM_DLL
+
+#ifdef CONFIG_CLK_800_330_165
+#define DRAM_CLK_330
+#endif
+#ifdef CONFIG_CLK_1000_200_200
+#define DRAM_CLK_200
+#endif
+#ifdef CONFIG_CLK_1000_330_165
+#define DRAM_CLK_330
+#endif
+#ifdef CONFIG_CLK_1000_400_200
+#define DRAM_CLK_400
+#endif
+
+/* add by cym 20130218 */
+#define DMC_IVCONTROL	0xF0
+wait_phy_state:
+	ldr r1, [r0, #DMC_PHYSTATUS]
+	tst r1, #(1<<2)
+	beq wait_phy_state
+	mov pc, lr
+
+dmc_delay:
+	push {lr}
+1:	subs r2, r2, #1
+	bne 1b
+	pop {pc}
+	
+	.globl mem_ctrl_asm_init_ddr3
+mem_ctrl_asm_init_ddr3:
+	push {lr}
+
+/*****************************************************************/
+/*DREX0***********************************************************/
+/*****************************************************************/
+
+	ldr	r0, =APB_DMC_0_BASE 
+
+	ldr	r1, =0x0
+	str	r1, [r0, #DMC_PHYCONTROL2]
+
+	ldr	r1, =0x0
+	str	r1, [r0, #0x24]
+
+	ldr	r1, =0xE3855503
+	str	r1, [r0, #DMC_PHYZQCONTROL]
+
+	ldr	r1, =0x71101008				
+	str	r1, [r0, #DMC_PHYCONTROL0]
+
+	ldr	r1, =0x7110100A				
+	str	r1, [r0, #DMC_PHYCONTROL0]
+
+	ldr	r1, =0x20000086				
+	str	r1, [r0, #DMC_PHYCONTROL1]
+
+	ldr	r1, =0x71101008				
+	str	r1, [r0, #DMC_PHYCONTROL0]
+
+	ldr	r1, =0x2000008E				
+	str	r1, [r0, #DMC_PHYCONTROL1]
+
+	ldr	r1, =0x20000086				
+	str	r1, [r0, #DMC_PHYCONTROL1]
+
+	ldr	r1, =0x2000008E				
+	str	r1, [r0, #DMC_PHYCONTROL1]
+
+	ldr	r1, =0x20000086				
+	str	r1, [r0, #DMC_PHYCONTROL1]
+
+	ldr	r1, =0x0FFF30CA
+	str	r1, [r0, #DMC_CONCONTROL]
+
+	ldr	r1, =0x00302600				
+	str	r1, [r0, #DMC_MEMCONTROL]
+#if 0
+	ldr	r1, =0x40C01323	
+	str	r1, [r0, #DMC_MEMCONFIG0]
+#else
+	/* 4Gb * 4 */
+	/*
+	ldr r1, =0x40801323
+	str	r1, [r0, #DMC_MEMCONFIG0]
+	*/
+
+	/* 2Gb * 8 */
+
+	ldr r1, =0x40801333
+	str	r1, [r0, #DMC_MEMCONFIG0]
+	
+#endif
+	ldr	r1, =(0x80000000 | CONFIG_IV_SIZE)
+	str	r1, [r0, #DMC_IVCONTROL]
+
+	ldr	r1, =0x64000000			
+	str	r1, [r0, #DMC_PRECHCONFIG]
+
+	ldr	r1, =0x9C4000FF			
+	str	r1, [r0, #DMC_PHYCONTROL0]
+
+	ldr	r1, =0x000000BB
+	str	r1, [r0, #DMC_TIMINGAREF] @TimingAref
+
+#ifdef CONFIG_EVT0_RECOMMEND
+	ldr	r1, =0x34A98691
+#else	
+	ldr	r1, =0x34498691  
+#endif
+
+	ldr	r1, =0x7846654F/*0x4046654F*/
+	str	r1, [r0, #DMC_TIMINGROW] @TimingRow
+	ldr	r1, =0x46400506    				
+	str	r1, [r0, #DMC_TIMINGDATA] @TimingData
+	ldr	r1, =0x52000A3C    				
+	str	r1, [r0, #DMC_TIMINGPOWER] @TimingPower
+
+	/* minimum wait time is 100 nano seconds */
+	/* 0x64: wait 250 nano seconds at ARMCLK 1.5 Ghz */
+	mov	r2, #0x64
+	bl dmc_delay
+
+	ldr	r1, =0x07000000       				
+	str	r1, [r0, #DMC_DIRECTCMD] 
+
+	/* minimum wait time is 200 micro seconds */
+	/* 0x19000: wait 250 micro seconds at ARMCLK 1.5 Ghz */
+	mov	r2, #0x19000
+	bl dmc_delay
+
+	ldr	r1, =0x00020000       				
+	str	r1, [r0, #DMC_DIRECTCMD]
+
+	/* minimum wait time is 20 micro seconds */
+	/* 0x2700: wait 25 micro seconds at ARMCLK 1.5 Ghz */
+	mov	r2, #0x2700
+	bl dmc_delay
+
+	ldr	r1, =0x00030000       				
+	str	r1, [r0, #DMC_DIRECTCMD] 
+
+	/* minimum wait time is 1 micro seconds */
+	/* 0x3f0: wait 2.5 micro seconds at ARMCLK 1.5 Ghz */
+	mov	r2, #0x3f0
+	bl dmc_delay
+
+	ldr	r1, =0x00010000
+	str	r1, [r0, #DMC_DIRECTCMD] 
+	ldr	r1, =0x00000100       				
+	str	r1, [r0, #DMC_DIRECTCMD] 
+
+	mov	r2, #0x3f0
+	bl dmc_delay
+
+	ldr	r1, =0x00000420       				
+	str	r1, [r0, #DMC_DIRECTCMD]
+
+	mov	r2, #0x3f0
+	bl dmc_delay
+
+	ldr	r1, =0x0A000000
+	str	r1, [r0, #DMC_DIRECTCMD]
+
+	mov	r2, #0x3f0
+	bl dmc_delay
+
+/*****************************************************************/
+/*DREX1***********************************************************/
+/*****************************************************************/
+	ldr	r0, =APB_DMC_1_BASE 
+
+	ldr	r1, =0x0
+	str	r1, [r0, #DMC_PHYCONTROL2]
+
+	ldr	r1, =0x0
+	str	r1, [r0, #0x24]
+
+	ldr	r1, =0xE3855503
+	str	r1, [r0, #DMC_PHYZQCONTROL]
+
+	ldr	r1, =0x71101008				
+	str	r1, [r0, #DMC_PHYCONTROL0]
+
+	ldr	r1, =0x7110100A				
+	str	r1, [r0, #DMC_PHYCONTROL0]
+
+	ldr	r1, =0x20000086				
+	str	r1, [r0, #DMC_PHYCONTROL1]
+
+	ldr	r1, =0x71101008				
+	str	r1, [r0, #DMC_PHYCONTROL0]
+
+	ldr	r1, =0x2000008E				
+	str	r1, [r0, #DMC_PHYCONTROL1]
+
+	ldr	r1, =0x20000086				
+	str	r1, [r0, #DMC_PHYCONTROL1]
+
+	ldr	r1, =0x2000008E				
+	str	r1, [r0, #DMC_PHYCONTROL1]
+
+	ldr	r1, =0x20000086				
+	str	r1, [r0, #DMC_PHYCONTROL1]
+
+	ldr	r1, =0x0FFF30CA
+	str	r1, [r0, #DMC_CONCONTROL]
+
+	ldr	r1, =0x00302600				
+	str	r1, [r0, #DMC_MEMCONTROL]
+#if 0
+	ldr	r1, =0x40C01323	
+	str	r1, [r0, #DMC_MEMCONFIG0]
+#else
+	/* 4Gb * 4 */
+	/*
+	ldr r1, =0x40801323
+	str	r1, [r0, #DMC_MEMCONFIG0]
+	*/
+
+	/* 2Gb * 8 */
+	ldr r1, =0x40801333
+	str	r1, [r0, #DMC_MEMCONFIG0]
+
+#endif
+	ldr	r1, =(0x80000000 | CONFIG_IV_SIZE)
+	str	r1, [r0, #DMC_IVCONTROL]
+
+	ldr	r1, =0x64000000			
+	str	r1, [r0, #DMC_PRECHCONFIG]
+
+	ldr	r1, =0x9C4000FF			
+	str	r1, [r0, #DMC_PHYCONTROL0]
+
+	ldr	r1, =0x000000BB
+	str	r1, [r0, #DMC_TIMINGAREF] @TimingAref
+
+#ifdef CONFIG_EVT0_RECOMMEND
+	ldr	r1, =0x34A98691
+#else	
+	ldr	r1, =0x34498691  
+#endif
+
+	ldr	r1, =0x7846654F/*0x4046654F*/
+	str	r1, [r0, #DMC_TIMINGROW] @TimingRow
+	ldr	r1, =0x46400506    				
+	str	r1, [r0, #DMC_TIMINGDATA] @TimingData
+	ldr	r1, =0x52000A3C    				
+	str	r1, [r0, #DMC_TIMINGPOWER] @TimingPower
+
+	/* minimum wait time is 100 nano seconds */
+	/* 0x64: wait 250 nano seconds at ARMCLK 1.5 Ghz */
+	mov	r2, #0x64
+	bl dmc_delay
+
+	ldr	r1, =0x07000000       				
+	str	r1, [r0, #DMC_DIRECTCMD] 
+
+	/* minimum wait time is 200 micro seconds */
+	/* 0x19000: wait 250 micro seconds at ARMCLK 1.5 Ghz */
+	mov	r2, #0x19000
+	bl dmc_delay
+
+	ldr	r1, =0x00020000       				
+	str	r1, [r0, #DMC_DIRECTCMD]
+
+	/* minimum wait time is 20 micro seconds */
+	/* 0x2700: wait 25 micro seconds at ARMCLK 1.5 Ghz */
+	mov	r2, #0x2700
+	bl dmc_delay
+
+	ldr	r1, =0x00030000       				
+	str	r1, [r0, #DMC_DIRECTCMD] 
+
+	/* minimum wait time is 1 micro seconds */
+	/* 0x3f0: wait 2.5 micro seconds at ARMCLK 1.5 Ghz */
+	mov	r2, #0x3f0
+	bl dmc_delay
+
+	ldr	r1, =0x00010000
+	str	r1, [r0, #DMC_DIRECTCMD] 
+	ldr	r1, =0x00000100       				
+	str	r1, [r0, #DMC_DIRECTCMD] 
+
+	mov	r2, #0x3f0
+	bl dmc_delay
+
+	ldr	r1, =0x00000420       				
+	str	r1, [r0, #DMC_DIRECTCMD]
+
+	mov	r2, #0x3f0
+	bl dmc_delay
+
+	ldr	r1, =0x0A000000
+	str	r1, [r0, #DMC_DIRECTCMD]
+
+	mov	r2, #0x3f0
+	bl dmc_delay
+
+
+	ldr	r0, =APB_DMC_0_BASE
+
+	ldr	r1, =0x7110100A
+	ldr	r2, =DMC_PHYCONTROL0
+	str	r1, [r0, r2]
+
+	ldr	r1, =0x20000086
+	ldr	r2, =DMC_PHYCONTROL1
+	str	r1, [r0, r2]
+
+	ldr	r1, =0x7110100B
+	ldr	r2, =DMC_PHYCONTROL0
+	str	r1, [r0, r2]
+
+	bl wait_phy_state
+
+	ldr	r1, =0x2000008E
+	ldr	r2, =DMC_PHYCONTROL1
+	str	r1, [r0, r2]
+	ldr	r1, =0x20000086
+	ldr	r2, =DMC_PHYCONTROL1
+	str	r1, [r0, r2]
+
+	bl wait_phy_state
+
+	ldr	r0, =APB_DMC_1_BASE
+
+	ldr	r1, =0x7110100A
+	ldr	r2, =DMC_PHYCONTROL0
+	str	r1, [r0, r2]
+
+	ldr	r1, =0x20000086
+	ldr	r2, =DMC_PHYCONTROL1
+	str	r1, [r0, r2]
+
+	ldr	r1, =0x7110100B
+	ldr	r2, =DMC_PHYCONTROL0
+	str	r1, [r0, r2]
+
+	bl wait_phy_state
+
+	ldr	r1, =0x2000008E
+	ldr	r2, =DMC_PHYCONTROL1
+	str	r1, [r0, r2]
+	ldr	r1, =0x20000086
+	ldr	r2, =DMC_PHYCONTROL1
+	str	r1, [r0, r2]
+
+	bl wait_phy_state
+
+	ldr	r0, =APB_DMC_0_BASE
+	ldr	r2, =DMC_CONCONTROL
+	ldr	r1, [r0, r2]
+	orr r1, r1, #(1 << 5)
+	str r1, [r0, r2]
+
+	ldr	r0, =APB_DMC_1_BASE
+	ldr	r2, =DMC_CONCONTROL
+	ldr	r1, [r0, r2]
+	orr r1, r1, #(1 << 5)
+	str r1, [r0, r2]
+
+	ldr	r0, =APB_DMC_0_BASE
+	ldr	r2, =DMC_MEMCONTROL
+	ldr	r1, [r0, r2]
+	orr	r1, r1, #((1 << 4) | (1 << 1) | (1 << 0))
+	str	r1, [r0, r2]
+
+	ldr	r0, =APB_DMC_1_BASE
+	ldr	r2, =DMC_MEMCONTROL
+	ldr	r1, [r0, r2]
+	orr	r1, r1, #((1 << 4) | (1 << 1) | (1 << 0))
+	str	r1, [r0, r2]
+
+	pop {pc}
+/* end modify */
diff -urN TC4_uboot/cpu/arm_cortexa9/s5pc210/fimd.c iTop4412_uboot/cpu/arm_cortexa9/s5pc210/fimd.c
--- TC4_uboot/cpu/arm_cortexa9/s5pc210/fimd.c	2012-04-24 01:02:09.000000000 -0700
+++ iTop4412_uboot/cpu/arm_cortexa9/s5pc210/fimd.c	2015-11-09 00:59:36.000000000 -0800
@@ -322,346 +322,7 @@
 /*
  *
  */
-  	
-#define LCD_WIDTH		1024
-#define LCD_HEIGHT		800	
-
-void lcd_gpio_init(void)
-{
-	// 3.3V--10ms-->LVDS PD--200ms-->VLED--10ms-->PWM--10ms-->LED_EN
-
-	//---1) output 3v3
-
-	/* Seting LVDS_PWDN OUTPUT HIGH*/
-	Outp32(GPL1CON, ((Inp32(GPL1CON) & (~(0xf <<0)))|0x01));
-	Outp32(GPL1DAT, (Inp32(GPL1DAT) | (0x1)));
-	//printf("2) Enable LVDS trans!-->GPL1[0]: output high\n");
-	//Delay(200000);
-	/*--Turn on Backlight-->GPC1[2] VLED_EN: output high -->On 12V---------------*/
-	Outp32(GPC1CON,(Inp32(GPC1CON)&(~(0xf << 8)))|(0x1 << 8));
-	Outp32(GPC1DAT,Inp32(GPC1DAT)&(~(0x1 << 2))|(0x1 << 2));
-	//printf("3) Turn on Backlight!-->GPC1[2]: output high -->On 12V\n");
-	//Delay(10000);	
-	/*---->GPC0[1]:VLED_ON output high -->On 12V---------------*/
-	Outp32(GPC0CON,(Inp32(GPC0CON)&(~(0xf << 4)))|(0x1 << 4));
-	Outp32(GPC0DAT,(Inp32(GPC0DAT)&(~(0x1 << 1)))|(0x1 << 1));
-	//printf("4) Turn on Backlight!-->GPC0[1]: output high -->On 12V\n");
-	//Delay(10);	
-	
-	/*Output PWM!-->GPD0[1]: output high -->100%%*/
-	Outp32(GPD0CON,(Inp32(GPD0CON) & (~(0xf<<4)))|(0x1<<4)); //stop timer0
-	Outp32(GPD0DAT,(Inp32(GPD0DAT) & (~(0x1 << 1)))|(0x1 << 1)); // prescaler to 80
-	//Delay(10000);
-	//printf("5) Output PWM!-->GPD0[1]: output high -->100%%\n");
-
-	/*-Enable Backlight!-->GPC1[1] LED_EN18: output high -->enable-*/
-	Outp32(GPC1CON,(Inp32(GPC1CON)&(~(0xf << 4)))|(0x1 << 4));
-	Outp32(GPC1DAT,(Inp32(GPC1DAT)&(~(0x1 << 1)))|(0x1 << 1));
-
-	//printf("6) Enable Backlight!-->GPC1[1]: output high -->enable\n");
-
-	/*---------GPIO CONTROL---------*/
-	Outp32(GPF0CON, (Inp32(GPF0CON) & (~(0xFF<<16)))|0x22002222);	//set GPF0 as LVD_HSYNC,VSYNC,VCLK,VDEN,VD[3:0]
-	//Outp32(0xe0200128,0x0);			//set pull-up,down disable
-	
-	Outp32(GPF1CON, (Inp32(GPF1CON) & (~(0xFF<<16)))|0x22002222);	//set GPF1 as VD[11:4]
-	//Outp32(0xe0200148,0x0);			//set pull-up,down disable
-
-	Outp32(GPF2CON, (Inp32(GPF2CON) & (~(0xFF<<16)))|0x22002222);	//set GPF2 as VD[19:12]
-	//Outp32(0xe0200168,0x0);			//set pull-up,down disable
-
-	Outp32(GPF3CON, (Inp32(GPF3CON) & (~(0xFF<<16)))|0x22002222);	//set GPF3 as VD[23:20]
-	//Outp32(0xe0200188,0x0);			//set pull-up,down disable
-
-	//printf("7) Enable Backlight!-->GPC1[1]: output high -->enable\n");
-	
-	//--------- S5PC110 EVT0 needs MAX drive strength	---------//
-	//Outp32(0xe020012c,0xffffffff);			//set GPF0 drive strength max by WJ.KIM(09.07.17)
-	//Outp32(0xe020014c,0xffffffff);			//set GPF1 drive strength max by WJ.KIM(09.07.17)
-	//Outp32(0xe020016c,0xffffffff);			//set GPF2 drive strength max by WJ.KIM(09.07.17)
-	//Outp32(0xe020018c,0x3ff);					//set GPF3 drive strength max by WJ.KIM(09.07.17)
-
-}
-void fimd_setting(void)
-{
-	u32 uFbAddr = CFG_LCD_FBUFFER;
-
-	u32 i;
-	u32* pBuffer = (u32*)uFbAddr;
-
-/**/Outp32(0x11c00004, 0x60);
-	Outp32(0x11c00010, 0xe0e0305);
-	Outp32(0x11c00014, 0x3103020);
-	Outp32(0x11c00170, 0x0);
-	Outp32(0x11c00018, 0x12bbff);
-	Outp32(0x11c00000, 0x0);
-	Outp32(0x11c00000, 0x254);
-	Outp32(0x11c00130, 0x20);
-
-
-	Outp32(0x11c00020, 0x0);
-	Outp32(0x11c00024, 0x0);
-	Outp32(0x11c00028, 0x0);
-	Outp32(0x11c0002c, 0x0);
-	Outp32(0x11c00030, 0x0);
-	Outp32(0x11c00034, 0x0);
-	Outp32(0x11c00180, 0x0);
-	Outp32(0x11c00184, 0x0);
-	Outp32(0x11c00188, 0x0);
-	Outp32(0x11c0018c, 0x0);
-	Outp32(0x11c00190, 0x0);
-	Outp32(0x11c00140, 0x0);
-	Outp32(0x11c00148, 0x0);
-	Outp32(0x11c00150, 0x0);
-	Outp32(0x11c00158, 0x0);
-	Outp32(0x11c00058, 0x0);
-	Outp32(0x11c00208, 0x0);
-	Outp32(0x11c0020c, 0x0);
-	Outp32(0x11c00068, 0x0);
-	Outp32(0x11c00210, 0x0);
-	Outp32(0x11c00214, 0x0);
-	Outp32(0x11c00078, 0x0);
-	Outp32(0x11c00218, 0x0);
-	Outp32(0x11c0021c, 0x0);
-	Outp32(0x11c00088, 0x0);
-	Outp32(0x11c00220, 0x0);
-	Outp32(0x11c00224, 0x0);
-
-/**/	
-	Outp32(0x11c00260, 0x1);
-	Outp32(0x11c00048, 0x100200);
-	Outp32(0x11c00200, 0xffffff);
-	Outp32(0x11c00204, 0xffffff);
-	Outp32(0x11c00034, 0x0);
-	Outp32(0x11c00020, 0x802c);
-	
-	Outp32(0x11c000a0, uFbAddr + 0x00000000);
-	Outp32(0x11c000d0, uFbAddr + 0x00400800);
-	Outp32(0x11c000a4, uFbAddr + 0x00000000);
-	Outp32(0x11c000d4, uFbAddr + 0x00400800);	
-	Outp32(0x11c020a0, uFbAddr + 0x00000000); 
-	Outp32(0x11c020d0, uFbAddr + 0x00400800);
-
-//=// /**/
-/*******************************************************************/
-	Outp32(0x11c00100, 0x1558);//=// virtual screen offset 
-	Outp32(0x11c00040, 0x0); //window 0 position control a register
-	Outp32(0x11c00044, 0x2aaaff);//Window 0 Position Control B Register//=//
-	Outp32(0x11c00020, 0x802d); //Window 0 Control Register//=//
-	Outp32(0x11c00034, 0x1);//Window Shadow Control Register   bit0: enable channel 0
-	Outp32(0x11c00020, 0x802d);//=//window 0 control register
-	Outp32(0x11c00034, 0x1); // window shadow control register
-//	Outp32(0x11c00000, 0x257);
-//	Outp32(0x11c00000, 0x57); //===> MPLL should be 667 !!!!
-
-	Outp32(0x11c00000, 0x53); //Video Main Control 0 Register
-	//Outp32(0x11c00010, 0x60400); //Video Time Control 0 Register
-	Outp32(0x11c00010, 0xff160b01); //Video Time Control 0 Register
-	Outp32(0x11c001a4, 0x3); //I80 / RGB Trigger Control Register
-/*******************************************************************/	
-
-
-	Outp32(0x10010210,0x3); //syscon output path
-	Outp32(0x1003c234,Inp32(0x1003c234)| 0x6); //clk_src_lcd0 = mpll
-	Outp32(0x1003c534,Inp32(0x1003c534)| 0xB); //clk_src_lcd0 = mpll/12
-	LCD_setprogress(0);
-	//if (flag) LCD_setprogress(0);
-
-}
-void display_setting(void) //alpha setting
-{
-	Outp32(0x10010210,0x3); //syscon output path
-	Outp32(0x1003c234,(Inp32(0x1003c234)&(~0xf))| 0x6); //clk_src_lcd0 = mpll
-	Outp32(0x1003c534,(Inp32(0x1003c534)&(~0xf))| 0xB); //clk_src_lcd0 = mpll/12
-
-	Outp32(rVIDCON0, (0<<30)|(0<<26)|(0<<23)|(0<<20)|(0<<18)|(0<<17)|(0<<16)|(0<<6)|(1<<5)|(0<<1)|(0<<0));
-	Outp32(rVIDCON1, (1<<9)|(1<<7)|(0<<6)|(0<<5)|(0<<4));
-
-	Outp32(rVIDTCON0, (7<<16)|(9<<8)|(7<<0));
-	Outp32(rVIDTCON1, (50<<16)|(60<<8)|(50<<0));
-	Outp32(rVIDTCON2, (799<<11)|(1279<<0));
-	//Outp32(0x11c0001c, 0x0);
-	Outp32(rWINCON0, Inp32(rWINCON0) |(1<<15)|(8<<2)|(1<<1));
-
-	Outp32(rVIDOSD0A, Inp32(rVIDOSD0A) |(0<<11)|(0<<0));
-
-
-	Outp32(rVIDOSD0B, Inp32(rVIDOSD0B) |(1279<<11)|(799<<0));
-
-
-
-	Outp32(rVIDW00ADD0B0, CFG_LCD_FBUFFER);
-
-
-	Outp32(rVIDW00ADD1B0, CFG_LCD_FBUFFER+0x3E8000);
-
-
-
-	Outp32(rVIDW0ALPHA0, 0x0F0F0F);
-
-
-	Outp32(rVIDW0ALPHA1, 0x0F0F0F);
-	
-	Outp32(rSHADOWCON, Inp32(rSHADOWCON) |(0<<5)|(1<<0));
-
-	Outp32(rVIDW00ADD2, 0x1400);
-//---5. Start Output	
-	Outp32(rVIDCON0, Inp32(rVIDCON0) |(3<<0));
-	Outp32(rWINCON0, Inp32(rWINCON0) |(1<<0));
-
-
-}
-void display_color(void	)
-{
-	int i =0 ,j =0 ;
-for(i=0;i<200;i++)
-	{
-		for(j=0;j<1280;j++)
-			*((u32 *)CFG_LCD_FBUFFER+1280*i+j) = 0x3FFFF;	
-	   }
-	for(i=200;i<400;i++)
-	{
-		for(j=0;j<1280;j++)
-			*((u32 *)CFG_LCD_FBUFFER+1280*i+j) = 0x00FC0;	
-	   }
-	for(i=400;i<600;i++)
-	{
-		for(j=0;j<1280;j++)
-			*((u32 *)CFG_LCD_FBUFFER+1280*i+j) = 0x3F000;	
-	   }
-	for(i=600;i<800;i++)
-	{
-		for(j=0;j<1280;j++)
-			*((u32 *)CFG_LCD_FBUFFER+1280*i+j) = 0x0003F;	
-	   }
-}
-#define BOOT_LOGO_BITMAP_WIDTH	320
-#define BOOT_LOGO_BITMAP_HEIGHT	128
-
-void exynos_show_logo (const unsigned char * buf)
-{
-	unsigned long i, j, sx, sy;
-	unsigned long* pBuffer = (unsigned long*)CFG_LCD_FBUFFER;
-	unsigned short* pBitmap = (unsigned short*)buf;
-	unsigned long iBitmapData;
-	//unsigned short* pBitmap_max= pBitmap+PART_SIZE_LOGO;
-
-	//printf(" the map start is:%x, end is %x\n",pBitmap,pBitmap_max);
-	sx = (1280-BOOT_LOGO_BITMAP_WIDTH)>>1;
-	sy = (800-BOOT_LOGO_BITMAP_HEIGHT)>>1;
-
-	for (i=sy; i<sy+BOOT_LOGO_BITMAP_HEIGHT; i++)
-	{
-		for (j=sx; j<sx+BOOT_LOGO_BITMAP_WIDTH; j++)
-		{
-			iBitmapData = 0xFFFC<<18;
-			iBitmapData |= ((*pBitmap)&0xf800)<<2;
-			iBitmapData |= ((*pBitmap)&0x07e0)<<1;
-			iBitmapData |= ((*pBitmap)&0x1f)<<1;
-			*(pBuffer+(i*1280)+j) = iBitmapData;
-			pBitmap++;
-		}
-	}
-
-}
-
-unsigned  char* logo_buf;
-
-void exynos_get_logo(int index)
-{
-	char run_cmd[100];
-	
-	//printf("%s bootlogo[%d] \n ", "reading",index);
-	sprintf(run_cmd,"movi %s logo 0x%x %x","read",logo_buf,index);
-	run_command(run_cmd,0);
-}
-void exynos_display_pic(int index)
-{
-	int i = 0;
-
-	//printf("show boot logo\n");
-
-	logo_buf = (unsigned  char*)malloc(PART_SIZE_LOGO);
-	memset((void*)CFG_LCD_FBUFFER, 0x00, 1280*800*4);
-
-	if(index == 1)
-	{
-		 for(i = 1;i<4;i++)
-		 {
-			exynos_get_logo(i);
-	 		exynos_show_logo(logo_buf);
-			udelay(8000000);
-			udelay(8000000);
-			udelay(8000000);
-		 }
-	}
-	else
-	{
-			exynos_get_logo(index);
-	 		exynos_show_logo(logo_buf);
-	}
-	free(logo_buf);
-
-}
-void LCD_Initialize_NONAME1(void)
-{
-	//memset((void*)CFG_LCD_FBUFFER, 0x00, 1280*800*4);
-	lcd_gpio_init();
-	display_setting();
-	//display_color();
-	memset((void*)CFG_LCD_FBUFFER, 0x00, 1280*800*4);
-
-}
+  
 #else
 // "No LCD Type is defined!"
 #endif
-
-/*
- */
-void Exynos_LCD_turnon(void)
-{
-	//printf("[mjdbg] turn on the lcd \n");
-#if defined(CFG_LCD_TL2796)
-	LCD_Initialize_TL2796();
-#elif defined(CFG_LCD_NONAME1)
-	LCD_Initialize_NONAME1();
-#endif
-}
-
-void Exynose_LCD_setfgcolor(unsigned int color)
-{
-	gFgColor = color;
-}
-
-void Exynose_LCD_setleftcolor(unsigned int color)
-{
-	gLeftColor = color;
-}
-
-void Exynose_LCD_setprogress(int percentage)
-{
-#if defined(CFG_LCD_TL2796) || defined(CFG_LCD_NONAME1)
-	u32 i, j;
-	u32* pBuffer = (u32*)CFG_LCD_FBUFFER;
-
-	for (i=0; i < (LCD_HEIGHT/100)*percentage; i++)
-	{
-		for (j=0; j < LCD_WIDTH; j++)
-		{
-			*pBuffer++ = gFgColor;
-		}
-	}
-
-	for (; i < LCD_HEIGHT; i++)
-	{
-		for (j=0; j < (LCD_WIDTH >> 5); j++)
-		{
-			*pBuffer++ = gLeftColor;
-		}
-		for (; j < LCD_WIDTH; j++)
-		{
-			*pBuffer++ = LCD_BGCOLOR;
-		}
-	}
-#endif
-}
diff -urN TC4_uboot/cpu/arm_cortexa9/s5pc210/pmic.c iTop4412_uboot/cpu/arm_cortexa9/s5pc210/pmic.c
--- TC4_uboot/cpu/arm_cortexa9/s5pc210/pmic.c	2012-04-24 01:02:09.000000000 -0700
+++ iTop4412_uboot/cpu/arm_cortexa9/s5pc210/pmic.c	2015-11-09 01:24:35.000000000 -0800
@@ -6,6 +6,11 @@
 #include "gpio.h"
 #include "i2c.h"
 
+/* add by cym 20141224 */
+#define Inp32(_addr)            readl(_addr)
+#define Outp32(addr, data)      (*(volatile u32 *)(addr) = (data))
+/* end add */
+
 const PMIC_Type_st gVoltage_Type[3] = 
 {
 	
@@ -56,6 +61,15 @@
 	{
 		reg_addr = 0x48;
 	}
+	/* add by cym 20130315 */
+#if  defined(CONFIG_SCP_1GDDR) ||  defined(CONFIG_SCP_2GDDR) || defined(CONFIG_SCP_1GDDR_Ubuntu) || defined(CONFIG_SCP_2GDDR_Ubuntu)  //add by dg
+	else if(7 == eRegNum)
+	{
+		reg_addr = 0x59;
+		ucVolLevel = 0x40;	// 1.55v
+	}
+#endif
+	/* end add */
 	else
 		while(1);
 
@@ -79,6 +93,16 @@
 	I2C_S5M8767_VolSetting(PMIC_BUCK2, CALC_S5M8767_VOLT1(vdd_arm * 1000), 1);
 	I2C_S5M8767_VolSetting(PMIC_BUCK3, CALC_S5M8767_VOLT1(vdd_int * 1000), 1);
 	I2C_S5M8767_VolSetting(PMIC_BUCK4, CALC_S5M8767_VOLT1(vdd_g3d * 1000), 1);
+
+	/* add by cym 20130315 */
+	//I2C_S5M8767_VolSetting(6, CALC_S5M8767_VOLT1(1.5 * 1000), 1);
+
+#if  defined(CONFIG_SCP_1GDDR) ||  defined(CONFIG_SCP_2GDDR) || defined(CONFIG_SCP_1GDDR_Ubuntu) || defined(CONFIG_SCP_2GDDR_Ubuntu)  //add by dg
+	//set Buck8 to 1.5v, because LDO2's out  decide by Buck8
+	I2C_S5M8767_VolSetting(7, CALC_S5M8767_VOLT1(1.55 * 1000), 1);
+#endif
+	/* end add */
+
 }
 
 
@@ -191,7 +215,14 @@
 		printf("S5M8767(VER4.0) \n");
        	 Is_TC4_Dvt = 2;
     }  
-	    else if(id == 0x3)
+	    else if(id == 0x3
+				/*add by cym 20130316 */
+			|| (0x5 == id)
+			/* end add */
+			/* add by cym 20151111 */
+			|| (21 == id)
+			/* end add */
+			)
     {
             
 		printf("S5M8767(VER5.0)\n");
@@ -200,7 +231,14 @@
 
 	else
 	{
+/* modeify by cym 20151111 */
+#if 0
 	  printf("Pls check the i2c @ pmic, id = %d,error\n",id);
+#else
+	printf("S5M8767(VER6.0)\n");
+	Is_TC4_Dvt = 2;
+#endif
+/* end modify */
 	}
 	//PowerOn the LCD In Kernel.
 	//val = 0x7;
@@ -215,43 +253,23 @@
         val = 0x58;
 	   lowlevel_init_max8997(0x5a,&val,1);
      }
+
+/* add by cym 20141125 set LDO18 to 3.3v */
+/* dg change for kinds of coreboard*/
+
+#if  defined(CONFIG_SCP_1GDDR) ||  defined(CONFIG_POP_1GDDR) || defined(CONFIG_SCP_1GDDR_Ubuntu)  || defined(CONFIG_POP_1GDDR_Ubuntu)
+        val = 0x32;
+        lowlevel_init_max8997(0x70, &val, 1);
+#endif
+
+/* end add */
 	}
 	/*---mj configure for emmc ---*/
 	uSendData[0] =0x6f;
 	uSendData[1] =0x68;
 
 	I2C_SendEx(I2C1, 0xcc, NULL, 0, uSendData, 2);
-	//printf("*********EMMC : 2.9V****************\n");
-	#ifdef CONFIG_LOGO_DISPLAY
-	if(Is_TC4_Dvt == 0)
-	{
-		/*---mj configure for LCD in EVT ---*/
 
-		uSendData[0] =0x37;
-		uSendData[1] =0x07;
-
-		I2C_SendEx(I2C1, 0xcc, NULL, 0, uSendData, 2);
-
-		uSendData[0] =0x43;
-		uSendData[1] =0xEC;
-
-		I2C_SendEx(I2C1, 0xcc, NULL, 0, uSendData, 2);
-	}
-	else
-	{
-		/*---mj configure for LCD in DVT ---*/
-
-		uSendData[0] =0x67;
-		uSendData[1] =0x72;
-
-		I2C_SendEx(I2C1, 0xcc, NULL, 0, uSendData, 2);
-
-		//uSendData[0] =0x43;
-		//uSendData[1] =0xEC;
-
-		//I2C_SendEx(I2C1, 0xcc, NULL, 0, uSendData, 2);
-	}
-	#endif
 	#if 0
 	val = readl(GPE3DAT);
 	val &= ~(0x01<<2);
@@ -264,7 +282,15 @@
 	val |= (0x01<<8);// GPE3[2] output, BUCK6EN
 	writel(val, GPE3CON);
 	#endif
-	
+
+	/* add by cym 20141224 for TP_IOCTL GPX0_3 set low */
+	Outp32(GPX0CON,(Inp32(GPX0CON)&(~(0xf << 12)))|(0x1 << 12));
+        Outp32(GPX0DAT,(Inp32(GPX0DAT)&(~(0x1 << 3)))|(0x0 << 3));
+	/* end add */
+
+	/* add by cym 20150701 7 inch screen twinkle when syatem start */
+        Outp32(GPL1DRV,(Inp32(GPL1DRV)&(~(0x3)))|(0x2));
+        /* end add */
 #endif
 }
 
diff -urN TC4_uboot/cpu/arm_cortexa9/s5pc210/recovery.c iTop4412_uboot/cpu/arm_cortexa9/s5pc210/recovery.c
--- TC4_uboot/cpu/arm_cortexa9/s5pc210/recovery.c	2012-06-07 01:50:17.000000000 -0700
+++ iTop4412_uboot/cpu/arm_cortexa9/s5pc210/recovery.c	2015-11-09 00:59:36.000000000 -0800
@@ -9,89 +9,10 @@
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
  */
-//#include <common.h>
 #include <s5pc210.h>
-//#include <asm/io.h>
-//#include <mmc.h>
-//#include <s3c_hsmmc.h>
 #include <command.h>
 #include "recovery.h"
 #include <movi.h>
-/*******************************************************************/
-/* recovery - recovery the system */
-/*******************************************************************/
-#if 1
-#define RECOVERY_IMAGE_MAGIC 0x52444E41
-int recovery_enter = 0;
-int do_recovery (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
-{
-	ulong addr;
-	int magic_num;
-	int recovery_start_addr,recovery_size;
-	int kernel_start_addr,kernel_size;
-	int addr_mode=0; //0 use default addr.  1: use the addr in image header..
-	char run_cmd[100];
-
-
-
-	printf("\n** go to extract the image file.. **\n");
-	addr = simple_strtoul(argv[1], NULL, 16);
-	if (*(ulong *)(addr) == RECOVERY_IMAGE_MAGIC)
-	{
-		//boot_img_hdr *hdr;
-		int size;
-
-		size = sizeof(boot_img_hdr);
-		printf("\n** This is a Valid image file.[%x]. **\n",size);
-		if(0)//(!recovery_enter)
-		{
-				
-		}
-		else
-		{
-			kernel_start_addr = addr+0x800;;
-			kernel_size = *(ulong *)(addr+0x8);   // M
-			printf("kernel_start_addr: 0x%8x\n",kernel_start_addr);
-			printf("kernel_size      : 0x%8x\n",kernel_size);
-			if(kernel_size>PART_SIZE_KERNEL)
-			{
-				printf("[ERROR]The kenerl size is larger than limit[0x%x]\n",PART_SIZE_KERNEL);		
-			}
-			/* copy the kernel img */
-			memcpy (0x40008000, kernel_start_addr, kernel_size); 
-			
-			recovery_start_addr = kernel_start_addr+kernel_size+0x180;//0x40d00000;
-			recovery_size =  *(ulong *)(addr+0x10);
-			
-			printf("recovery_start_addr: 0x%8x\n",recovery_start_addr);
-			printf("recovery_size      : 0x%8x\n",recovery_size);
-
-			/* copy the recovery img */
-			memcpy (0x40d00000, recovery_start_addr, recovery_size); 
-
-			sprintf(run_cmd, "bootm 40008000 40d00000");
-			setenv("bootcmd", run_cmd);
-			return 0;
-			
-		}
-	
-	}
-	else
-	{
-		printf("\n** Invalid  image file.. **\n");
-
-	}
-	return 0;
-}
-
-U_BOOT_CMD(
-	recovery,	2,		2,	do_recovery,
-	"recovey the system ...",
-	"\n"
-	"   \n"
-	" "
-);
-#endif
 
 int factory_reset(int mode)
 {
@@ -140,17 +61,12 @@
 	}
 	return 0;
 }
-extern signed int key1_pulldown, key2_pulldown,power_mode;
-extern void LCD_turnon(void);
 
 int recovery_preboot(void)
 {
 	unsigned int reset_mode;
-	int value  =0 ;
 	reset_mode = INF_REG5_REG;
-	char run_cmd[100];
 		
-	printf("reset_mode: 0x%x\n", reset_mode);
 	if(reset_mode ==FACTORY_RESET_MODE)
 	{
 			printf("SYSTEM ENTER FACTORY RESET MODE[0x%x]\n",reset_mode);	
@@ -161,110 +77,29 @@
 				return -1;
 			}
 			return 0;
-	}
-	else if (reset_mode ==CHARGING_RESET_MODE)
-	{
-			INF_REG5_REG = reset_mode&(~0xff);
-			printf("SYSTEM IN CHARGEING MODE-->GO SLEEP\n");	
-			#ifdef CONFIG_LOGO_DISPLAY
-			exynos_display_pic(BATTERY_LOGO);
-			#endif
-			value = __REG(S5P_PS_HOLD_CONTROL);
-			value = 0x5200;// shutdown
-			__REG(S5P_PS_HOLD_CONTROL)= value;
-	}
-	#if  0
-	else if (recovery_mode ==RECOVERY_MODE)
-	{
-			printf("SYSTEM ENTER RECOVERY MODE[0x%x]\n",recovery_mode);	
-			//char boot_cmd[100];
-			//sprintf(boot_cmd, "movi read kernel 40008000;movi read rootfs 40d00000 100000;bootm 40008000 40d00000");
-			//setenv("bootcmd", boot_cmd);
-			setenv("bootcmd","movi read kernel 40008000;movi read recovery 40d00000 300000;bootm 40008000 40d00000");
-			return 0;
-
-	}
-	#endif
+	}	
 	else
-	{		
-			
-			value = __REG(GPX2DAT);
-			key1_pulldown =((value & 0x1) == 0x1);
-			key2_pulldown =((value & 0x2) == 0x2);
-			printf("KEY_DET!%d, %d, %x\n",key1_pulldown,key2_pulldown,value);
-			
-			if(key1_pulldown) //mj for temp...
-			{	
-				printf("SYSTEM ENTER RECOVERY MODE1[0x%x]\n",reset_mode);	
-				if(1)
-				{
-					#ifdef CONFIG_LOGO_DISPLAY
-					exynos_display_pic(RECOVERY_LOGO);
-					#endif
-					
-					setenv("bootcmd","movi read kernel 40008000;movi read Recovery 40d00000 300000;bootm 40008000 40d00000");
-				}
-				else
-				{
-					sprintf(run_cmd, "movi read Recovery 41000000 600000;recovery 41000000");
-					//sprintf(run_cmd, "movi read Recovery 41000000 600000");
-					run_command(run_cmd,0);
-				}
+	{
+		/* add by cym 20141211 GPX1_1 */
+		int value = 0;
 
-			}
-			else if (key2_pulldown)
-			{
-				printf("SYSTEM ENTER Updating MODE1[0x%x]\n",reset_mode);	
-				sprintf(run_cmd, "sdfuse flashall");
-				run_command(run_cmd, 0);			
-			}
-			else
-			{
-				if(power_mode == 0)
-				{
-					printf("SYSTEM ENTER NORMAL BOOT MODE[BATTERY]\n");	
-					#ifdef CONFIG_LOGO_DISPLAY
-					exynos_display_pic(BOOT_LOGO);
-					#endif
-				}
-				else if(power_mode == 2) //SHORT PUSH .GO TO CHARGING
-				{
-						printf("SYSTEM IN CHARGEING MODE-->GO CHARGING IN POWER OFF MODE\n");	
+		char run_cmd[50];
 
-						#ifdef CONFIG_LOGO_DISPLAY
-						exynos_display_pic(BATTERY_LOGO);
-						value = __REG(S5P_PS_HOLD_CONTROL);
-						value = 0x5200;// shutdown
-						__REG(S5P_PS_HOLD_CONTROL)= value;
-						#endif
+		value = __REG(GPX1DAT);
 
-				}
-				else if(power_mode == 3)
-				{	
-					printf("SYSTEM ENTER NORMAL BOOT MODE[CHARGING]\n");	
-					#ifdef CONFIG_LOGO_DISPLAY
-					exynos_display_pic(BOOT_LOGO);
-					#endif
-				}
-				else if (power_mode == 1)
-				{
-						#ifdef CONFIG_LOGO_DISPLAY
-						printf("[ERROR]SYSTEM IN UNKNOWN POWER MODE\n");
-						#else
-						printf("SYSTEM ENTER NORMAL BOOT MODE1[CHARGING]\n");	
-						#endif
-						//value = __REG(S5P_PS_HOLD_CONTROL);
-						//value = 0x5200;// shutdown
-						//__REG(S5P_PS_HOLD_CONTROL)= value;
-				}
-				else
-				{
-						printf("[ERROR]SYSTEM IN UNKNOWN POWER MODE1\n");
-				}
-			}
-			
-			return 0;
-	}
+		if(0x2 == (value & 0x2))//not press
+		{
+			printf("SYSTEM ENTER NORMAL BOOT MODE\n");
+		}
+		else	//press
+		{
+			printf("SYSTEM ENTER Updating MODE\n");
 
+			sprintf(run_cmd, "sdfuse flashall");
+			run_command(run_cmd, 0);
+		}
+		/* end add */
 
+		return 0;
+	}
 }
diff -urN TC4_uboot/drivers/mmc/mmc.c iTop4412_uboot/drivers/mmc/mmc.c
--- TC4_uboot/drivers/mmc/mmc.c	2012-04-24 01:02:09.000000000 -0700
+++ iTop4412_uboot/drivers/mmc/mmc.c	2015-11-09 00:59:36.000000000 -0800
@@ -854,7 +854,13 @@
 	ext_csd_struct = ext_csd[EXT_CSD_REV];
 	host->ext_csd.boot_size_multi = ext_csd[BOOT_SIZE_MULTI];//mj
 	
+	/* modify by cym 20140416 */
+#if 0
 	if (ext_csd_struct > 5) {
+#else
+	if ((ext_csd_struct > 5) && (7 != ext_csd_struct)) {
+#endif
+	/* end modify */
 		printf("unrecognised EXT_CSD structure "
 			"version %d\n", ext_csd_struct);
 		err = -1;
diff -urN TC4_uboot/drivers/mmc/s5p_mshc.c iTop4412_uboot/drivers/mmc/s5p_mshc.c
--- TC4_uboot/drivers/mmc/s5p_mshc.c	2012-04-24 01:02:09.000000000 -0700
+++ iTop4412_uboot/drivers/mmc/s5p_mshc.c	2015-11-09 00:59:36.000000000 -0800
@@ -110,7 +110,8 @@
 	writel(ier, host->ioaddr + MSHCI_CTRL);
 	while (readl(host->ioaddr + MSHCI_CTRL) & DMA_RESET) {
 		if (timeout == 0) {
-			printf("Reset DMA never completed.\n");
+			printf("Reset DMA never completed.\n"
+);
 			return;
 		}
 		timeout--;
@@ -132,6 +133,9 @@
 		if (count == 0) {
 			printf("Controller never released \
 				data0 before reset ciu.\n");
+
+			do_reset (NULL, 0, 0, NULL);
+			
 			return -1;
 		}
 		count--;
diff -urN TC4_uboot/include/configs/itop_4412_android.h iTop4412_uboot/include/configs/itop_4412_android.h
--- TC4_uboot/include/configs/itop_4412_android.h	1969-12-31 16:00:00.000000000 -0800
+++ iTop4412_uboot/include/configs/itop_4412_android.h	2015-11-09 00:59:36.000000000 -0800
@@ -0,0 +1,632 @@
+/*
+ *
+ * Configuation settings for the iTOP-4412 board.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+#define CONFIG_S5PC210      1       /* in a SAMSUNG S5PC210 SoC */
+#define CONFIG_SMDKC210     1
+#define CONFIG_DEVICE_STRING    "iTOP-4412"
+
+#define CONFIG_EVT1     1       /* EVT1 */
+
+#define TC4_PLUS		
+/*----CPU ID Defination----*/
+#define SMDK4212_ID 		0x43220000
+#define SMDK4212_AP11_ID 	0x43220210 //mj
+#define SMDK4212_AP10_ID 	0x43220200 //mj
+
+#define SMDK4412_ID 		0xE4412000
+#define SMDK4412_AP11_ID 	0xE4412211 //mj
+#define SMDK4412_AP10_ID 	0xE4412210 //mj
+
+
+/*
+ * SECURE BOOT
+ * */
+//#define CONFIG_SECURE
+
+#ifdef CONFIG_SECURE
+
+/* BL1 size */
+#ifdef CONFIG_EVT1
+#define CONFIG_SECURE_BL1_SIZE			0x2000
+#define CONFIG_SECURE_BL1_ONLY
+//#define CONFIG_SECURE_BOOT			/* Signed Kernel, RFS */
+#else
+#define CONFIG_SECURE_BL1_SIZE			0x4000
+#endif
+
+#ifdef CONFIG_SECURE_BOOT
+#define CONFIG_S5PC210S
+#define CONFIG_SECURE_ROOTFS
+#define CONFIG_SECURE_KERNEL_BASE       0xC0008000
+#define CONFIG_SECURE_KERNEL_SIZE       0x300000
+#define CONFIG_SECURE_ROOTFS_BASE       0xC0800000
+#define CONFIG_SECURE_ROOTFS_SIZE       0x100000
+#endif
+
+#endif
+
+
+#if  defined(CONFIG_SCP_1GDDR) ||  defined(CONFIG_SCP_2GDDR) || defined(CONFIG_SCP_1GDDR_Ubuntu) || defined(CONFIG_SCP_2GDDR_Ubuntu)  //add by dg
+
+/* add by cym 20130218 */
+/* IV_SIZE: 128 byte, 2 port(1 Gbyte), open page, trrd: 4 */
+#define CONFIG_EVT0_PERFORMANCE
+/* IV_SIZE: 512 Mbyte, 1 port(512 Mbyte), open page, trrd: 4 */
+//#define CONFIG_EVT0_STABLE
+/* IV_SIZE: 128 byte, 2 port(1 Gbyte), close page, trrd: 0xA */
+//#define CONFIG_EVT0_RECOMMEND
+
+/* (Memory Interleaving Size = 1 << IV_SIZE) */
+#ifdef CONFIG_EVT0_STABLE
+#define CONFIG_IV_SIZE 0x1D
+#else
+#define CONFIG_IV_SIZE 0x7
+#endif
+
+#define S5PV310_POWER_BASE	0x10020000
+
+/*
+ * CLOCK
+ */
+#define ELFIN_CLOCK_BASE		0x10030000
+
+#define CLK_SRC_LEFTBUS_OFFSET		0x04200
+#define CLK_MUX_STAT_LEFTBUS_OFFSET	0x04400
+#define CLK_DIV_LEFTBUS_OFFSET		0x04500
+
+#define CLK_SRC_RIGHTBUS_OFFSET		0x08200
+#define CLK_MUX_STAT_RIGHTBUS_OFFSET	0x08400
+#define CLK_DIV_RIGHTBUS_OFFSET		0x08500
+
+#define EPLL_LOCK_OFFSET		0x0C010
+#define VPLL_LOCK_OFFSET		0x0C020
+#define EPLL_CON0_OFFSET		0x0C110
+#define EPLL_CON1_OFFSET		0x0C114
+#ifdef CONFIG_SMDKC220
+#define EPLL_CON2_OFFSET		0x0C118
+#endif
+#define VPLL_CON0_OFFSET		0x0C120
+#define VPLL_CON1_OFFSET		0x0C124
+#ifdef CONFIG_SMDKC220
+#define VPLL_CON2_OFFSET		0x0C128
+#endif
+
+#define CLK_SRC_TOP0_OFFSET		0x0C210
+#define CLK_SRC_TOP1_OFFSET		0x0C214
+#define CLK_SRC_FSYS_OFFSET		0x0C240
+#define CLK_SRC_PERIL0_OFFSET		0x0C250
+#define CLK_MUX_STAT_TOP_OFFSET		0x0C410
+#define CLK_MUX_STAT_TOP1_OFFSET	0x0C414
+#define CLK_DIV_TOP_OFFSET		0x0C510
+#define CLK_DIV_FSYS1_OFFSET		0x0C544
+#define CLK_DIV_FSYS2_OFFSET		0x0C548
+#define CLK_DIV_FSYS3_OFFSET		0x0C54C
+#define CLK_DIV_PERIL0_OFFSET		0x0C550
+
+#define CLK_SRC_DMC_OFFSET		0x10200
+#define CLK_MUX_STAT_DMC_OFFSET		0x10400
+#define CLK_DIV_DMC0_OFFSET		0x10500
+#define CLK_DIV_DMC1_OFFSET		0x10504
+
+#define CLK_GATE_IP_DMC_OFFSET		0x10900
+
+#if defined(CONFIG_SMDKC220) || defined(CONFIG_EXYNOS4412)
+#define CLK_GATE_IP_PERIR_OFFSET	0x08960
+#elif defined(CONFIG_SMDKC210)
+#define CLK_GATE_IP_PERIR_OFFSET	0x0C960
+#endif
+
+#define APLL_LOCK_OFFSET		0x14000
+#define APLL_CON0_OFFSET		0x14100
+#define APLL_CON1_OFFSET		0x14104
+
+#if defined(CONFIG_SMDKC220) || defined(CONFIG_EXYNOS4412)
+#define MPLL_LOCK_OFFSET		0x10008
+#define MPLL_CON0_OFFSET		0x10108
+#define MPLL_CON1_OFFSET		0x1010C
+#elif defined(CONFIG_SMDKC210)
+#define MPLL_LOCK_OFFSET		0x14008
+#define MPLL_CON0_OFFSET		0x14108
+#define MPLL_CON1_OFFSET		0x1410C
+#endif
+
+#define CLK_SRC_CPU_OFFSET		0x14200
+#define CLK_MUX_STAT_CPU_OFFSET		0x14400
+#define CLK_DIV_CPU0_OFFSET		0x14500
+#define CLK_DIV_CPU1_OFFSET		0x14504
+
+#define CLK_SRC_FSYS		__REG(ELFIN_CLOCK_BASE+CLK_SRC_FSYS_OFFSET)
+#define CLK_DIV_FSYS1		__REG(ELFIN_CLOCK_BASE+CLK_DIV_FSYS1_OFFSET)
+#define CLK_DIV_FSYS2		__REG(ELFIN_CLOCK_BASE+CLK_DIV_FSYS2_OFFSET)
+#define CLK_DIV_FSYS3		__REG(ELFIN_CLOCK_BASE+CLK_DIV_FSYS3_OFFSET)
+#define APLL_CON0_REG		__REG(ELFIN_CLOCK_BASE+APLL_CON0_OFFSET)
+#define MPLL_CON0_REG		__REG(ELFIN_CLOCK_BASE+MPLL_CON0_OFFSET)
+#define EPLL_CON0_REG		__REG(ELFIN_CLOCK_BASE+EPLL_CON0_OFFSET)
+#define VPLL_CON0_REG		__REG(ELFIN_CLOCK_BASE+VPLL_CON0_OFFSET)
+
+#define USB_PHY_CONTROL_OFFSET		0x0704
+#define USB_PHY_CONTROL            (0x10020000+USB_PHY_CONTROL_OFFSET)//(ELFIN_CLOCK_POWER_BASE+USB_PHY_CONTROL_OFFSET)
+
+
+/* end add */
+#endif //end SCP Type Boards
+
+
+
+/*********************************************
+ *  Configure clock
+ *********************************************/
+/* APLL : 800Mhz	*/
+//#define CONFIG_CLK_800_330_165
+/* APLL : 1GHz	*/
+#define CONFIG_CLK_1000_400_200
+
+
+#define CONFIG_SPARSEMEM	1		/* Sparsemem for 32 kernel */
+
+#define BOOT_ONENAND	0x1
+#define BOOT_NAND		0x40000
+#define BOOT_MMCSD		0x3
+#define BOOT_NOR		0x4
+#define BOOT_SEC_DEV	0x5
+#define BOOT_EMMC43		0x6
+#define BOOT_EMMC441	0x7
+
+
+#define CONFIG_BOOTM_LINUX      1
+
+/* skip to load BL2 */
+#define FAST_BOOT		1
+
+#define CONFIG_SYS_NO_FLASH
+#define MEMORY_BASE_ADDRESS	0x40000000
+
+/* input clock of PLL */
+#define CONFIG_SYS_CLK_FREQ	24000000	/* the SMDKC210 has 24MHz input clock */
+
+/* MMU Setting  */
+#define CONFIG_ENABLE_MMU
+
+#ifdef CONFIG_ENABLE_MMU
+#define virt_to_phys(x)	virt_to_phy_smdkc210(x)
+#else
+#define virt_to_phys(x)	(x)
+#endif
+
+#define CONFIG_MEMORY_UPPER_CODE
+
+#undef CONFIG_USE_IRQ				/* we don't need IRQ/FIQ stuff */
+
+#define CONFIG_INCLUDE_TEST
+
+#define CONFIG_ZIMAGE_BOOT
+#define CONFIG_IMAGE_BOOT
+
+#define BOARD_LATE_INIT
+
+#define CONFIG_SETUP_MEMORY_TAGS
+#define CONFIG_CMDLINE_TAG
+#define CONFIG_INITRD_TAG
+
+/*
+ * Architecture magic and machine type
+ */
+
+#define MACH_TYPE		2838//(S5PC210:2838, S5PV310:2925)
+#define UBOOT_MAGIC		(0x43090000 | MACH_TYPE)
+#define CHIP_ID_BASE            0x10000000
+#define PKG_ID_BASE		0x10000004
+
+/* Power Management is enabled */
+#define CONFIG_PM
+
+#define CONFIG_TA4
+
+//#define CONFIG_SD_UPDATE
+#define CONFIG_SD_AUTOUPDATE
+
+#ifdef CONFIG_SD_AUTOUPDATE
+#define CONFIG_SD_UPDATE
+#endif
+
+//@@Robin
+#ifndef CONFIG_TA4
+
+#ifdef CONFIG_CLK_800_300_150
+#define CONFIG_PM_11V   /* ARM 1.1v, INT 1.1v */
+#else   /* default or CONFIG_CLK_1000_400_200 */
+//#define CONFIG_PM_12V   /* ARM 1.2v, INT 1.2v */
+#define CONFIG_PM_13V_12V	/* ARM 1.3v, INT 1.2v */
+#endif
+//@@Robin
+#endif
+
+#define CONFIG_DISPLAY_CPUINFO
+#define CONFIG_DISPLAY_BOARDINFO
+
+#undef CONFIG_SKIP_RELOCATE_UBOOT
+#undef CONFIG_USE_NOR_BOOT
+
+/*
+ * Size of malloc() pool
+ */
+#define CONFIG_SYS_MALLOC_LEN		(CONFIG_ENV_SIZE + 1024*1024)
+#define CFG_GBL_DATA_SIZE	128	/* size in bytes reserved for initial data */
+
+#define CFG_STACK_SIZE		512*1024
+
+/*
+ * select serial console configuration
+ */
+#ifndef CONFIG_TA4
+#define CONFIG_SERIAL2          1	/* we use UART1 on SMDKC210 */
+#else
+#define CONFIG_SERIAL3          1	/* we use UART2 on TA4 */
+#endif
+//#define CONFIG_SERIAL4		1
+
+#define CFG_HUSH_PARSER			/* use "hush" command parser	*/
+#ifdef CFG_HUSH_PARSER
+#define CFG_PROMPT_HUSH_PS2	"> "
+#endif
+
+#define CONFIG_CMDLINE_EDITING
+
+#undef CONFIG_S3C64XX_I2C		/* this board has H/W I2C */
+#ifdef CONFIG_S3C64XX_I2C
+#define CONFIG_HARD_I2C		1
+#define CFG_I2C_SPEED		50000
+#define CFG_I2C_SLAVE		0xFE
+#endif
+
+#define CONFIG_DOS_PARTITION
+#define CONFIG_SUPPORT_VFAT
+
+#define CONFIG_USB_OHCI
+#undef CONFIG_USB_STORAGE
+#define CONFIG_S3C_USBD
+
+#define USBD_DOWN_ADDR		0xc0000000
+
+/************************************************************
+ * RTC
+ ************************************************************/
+/* allow to overwrite serial and ethaddr */
+#define CONFIG_ENV_OVERWRITE
+
+#define CONFIG_BAUDRATE		115200
+
+/***********************************************************
+ * Command definition
+ ***********************************************************/
+//#define CONFIG_CMD_CACHE
+//#define CONFIG_CMD_USB
+//#define CONFIG_CMD_REGINFO
+
+//#define	CONFIG_CMD_NAND
+//#define	CONFIG_CMD_FLASH
+
+//#define CONFIG_CMD_ONENAND
+#define CONFIG_CMD_MOVINAND
+
+//#define CONFIG_CMD_PING
+//#define CONFIG_CMD_DATE
+
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_ELF
+//#define CONFIG_CMD_I2C
+
+#define CONFIG_CMD_EXT2
+#define CONFIG_CMD_EXT4
+#define CONFIG_CMD_FAT
+
+#if defined(CONFIG_CMD_KGDB)
+#define CONFIG_KGDB_BAUDRATE	115200		/* speed to run kgdb serial port */
+/* what's this ? it's not used anywhere */
+#define CONFIG_KGDB_SER_INDEX	1		/* which serial port to use */
+#endif
+
+/*
+ * Miscellaneous configurable options
+ */
+#define CONFIG_SYS_LONGHELP                             /* undef to save memory         */
+#define CONFIG_SYS_PROMPT              "iTOP-4412 # "    /* Monitor Command Prompt       */
+
+#define CONFIG_SYS_CBSIZE		256		/* Console I/O Buffer Size	*/
+#define CONFIG_SYS_PBSIZE		384		/* Print Buffer Size */
+#define CONFIG_SYS_MAXARGS		16		/* max number of command args	*/
+#define CONFIG_SYS_BARGSIZE		CONFIG_SYS_CBSIZE	/* Boot Argument Buffer Size	*/
+
+#define CONFIG_SYS_MEMTEST_START	MEMORY_BASE_ADDRESS	/* memtest works on	*/
+
+#define CONFIG_SYS_MEMTEST_END		MEMORY_BASE_ADDRESS + 0x3E00000		/* 256 MB in DRAM	*/
+
+#undef CFG_CLKS_IN_HZ		/* everything, incl board info, in Hz */
+
+#define CONFIG_SYS_LOAD_ADDR		MEMORY_BASE_ADDRESS + 0x00100000	/* default load address	*/
+
+/* the PWM TImer 4 uses a counter of 41687 for 10 ms, so we need */
+/* it to wrap 100 times (total 4168750) to get 1 sec. */
+#define CONFIG_SYS_HZ			4168750		// at PCLK 66MHz
+
+/* valid baudrates */
+#define CONFIG_SYS_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+/*-----------------------------------------------------------------------
+ * Stack sizes
+ *
+ * The stack sizes are set up in start.S using the settings below
+ */
+
+/* MIU Setting  */
+//#define CONFIG_MIU_1BIT_INTERLEAVED
+
+#define CONFIG_STACKSIZE	0x40000		/* regular stack 256KB */
+#ifdef CONFIG_USE_IRQ
+#define CONFIG_STACKSIZE_IRQ	(4*1024)	/* IRQ stack */
+#define CONFIG_STACKSIZE_FIQ	(4*1024)	/* FIQ stack */
+#endif
+
+// SMDKC210 POP-A(512MB)   : 2 banks
+// SMDKC210 POP-B(1024MB)  : 4 banks
+#define CONFIG_NR_DRAM_BANKS    8          	/* 8 banks of DRAM at maximum */
+
+//dg change for kinds of coreboard 2015-08-04
+#ifdef CONFIG_SCP_1GDDR
+   #define SDRAM_BANK_SIZE            0x10000000/2	/* each bank has 128 MB */
+
+#elif defined(CONFIG_SCP_2GDDR)
+   #define SDRAM_BANK_SIZE            0x10000000	/* each bank has 256 MB */
+
+#elif defined(CONFIG_POP_1GDDR)
+   #define SDRAM_BANK_SIZE            0x10000000	/* each bank has 256 MB */
+
+#elif defined(CONFIG_POP_2GDDR)
+   #define SDRAM_BANK_SIZE            0x10000000	/* each bank has 256 MB */
+#endif
+
+
+#define PHYS_SDRAM_1            (unsigned long)MEMORY_BASE_ADDRESS /* SDRAM Bank #1 */
+#define PHYS_SDRAM_1_SIZE       (unsigned long)SDRAM_BANK_SIZE
+#define PHYS_SDRAM_2            (unsigned long)(MEMORY_BASE_ADDRESS + SDRAM_BANK_SIZE) /* SDRAM Bank #2 */
+#define PHYS_SDRAM_2_SIZE       (unsigned long)SDRAM_BANK_SIZE
+#define PHYS_SDRAM_3            (unsigned long)(MEMORY_BASE_ADDRESS + 2 * SDRAM_BANK_SIZE) /* SDRAM Bank #2 */
+#define PHYS_SDRAM_3_SIZE       (unsigned long)SDRAM_BANK_SIZE
+#define PHYS_SDRAM_4            (unsigned long)(MEMORY_BASE_ADDRESS + 3 * SDRAM_BANK_SIZE) /* SDRAM Bank #2 */
+#define PHYS_SDRAM_4_SIZE       (unsigned long)SDRAM_BANK_SIZE
+#define PHYS_SDRAM_5            (unsigned long)(MEMORY_BASE_ADDRESS + 4 * SDRAM_BANK_SIZE) /* SDRAM Bank #2 */
+#define PHYS_SDRAM_5_SIZE       (unsigned long)SDRAM_BANK_SIZE
+#define PHYS_SDRAM_6            (unsigned long)(MEMORY_BASE_ADDRESS + 5 * SDRAM_BANK_SIZE) /* SDRAM Bank #2 */
+#define PHYS_SDRAM_6_SIZE       (unsigned long)SDRAM_BANK_SIZE
+#define PHYS_SDRAM_7            (unsigned long)(MEMORY_BASE_ADDRESS + 6 * SDRAM_BANK_SIZE) /* SDRAM Bank #2 */
+#define PHYS_SDRAM_7_SIZE       (unsigned long)SDRAM_BANK_SIZE
+#define PHYS_SDRAM_8            (unsigned long)(MEMORY_BASE_ADDRESS + 7 * SDRAM_BANK_SIZE) /* SDRAM Bank #2 */
+#define PHYS_SDRAM_8_SIZE       (unsigned long)SDRAM_BANK_SIZE
+
+
+
+
+#define CFG_FLASH_BASE		0x80000000
+
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#define CONFIG_MX_LV640EB		/* MX29LV640EB */
+//#define CONFIG_AMD_LV800		/* AM29LV800BB */
+
+#define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks */
+
+#if	defined(CONFIG_MX_LV640EB)
+#define CFG_MAX_FLASH_SECT	135
+#define PHYS_FLASH_SIZE		0x800000	/* 8MB */
+#elif	defined(CONFIG_AMD_LV800)
+#define CFG_MAX_FLASH_SECT	19
+#define PHYS_FLASH_SIZE		0x100000	/* 1MB */
+#else
+#define CFG_MAX_FLASH_SECT	512
+#define PHYS_FLASH_SIZE		0x100000	/* 1MB */
+#endif
+
+#define CFG_FLASH_LEGACY_512Kx16
+//#define CONFIG_FLASH_CFI_LEGACY
+#define CFG_FLASH_CFI
+
+/* timeout values are in ticks */
+#define CFG_FLASH_ERASE_TOUT	(5*CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(5*CFG_HZ) /* Timeout for Flash Write */
+
+#define CFG_ENV_ADDR		0
+#define CONFIG_ENV_SIZE		0x4000	/* Total Size of Environment Sector */
+
+/*
+ * SMDKC210 board specific data
+ */
+
+#define CONFIG_IDENT_STRING	" for iTOP-4412 Android"
+
+/* total memory required by uboot */
+#define CFG_UBOOT_SIZE		(2*1024*1024)
+
+ /* base address for uboot */
+//#ifdef CONFIG_ENABLE_MMU
+//#define CFG_UBOOT_BASE		0xc3e00000
+//#else
+#define CFG_UBOOT_BASE		0x43e00000
+//#endif
+
+#define CFG_PHY_UBOOT_BASE	MEMORY_BASE_ADDRESS + 0x3e00000
+#define CFG_PHY_KERNEL_BASE	MEMORY_BASE_ADDRESS + 0x8000
+
+#define CONFIG_ENV_OFFSET	0x0007C000
+
+/* nand copy size from nand to DRAM.*/
+#define	COPY_BL2_SIZE		0x80000
+
+/* NAND configuration */
+#define CONFIG_SYS_MAX_NAND_DEVICE     1
+#define CONFIG_SYS_NAND_BASE           (0x0CE00000)
+#define NAND_MAX_CHIPS          1
+
+#define NAND_DISABLE_CE()	(NFCONT_REG |= (1 << 1))
+#define NAND_ENABLE_CE()	(NFCONT_REG &= ~(1 << 1))
+#define NF_TRANSRnB()		do { while(!(NFSTAT_REG & (1 << 0))); } while(0)
+
+#define CFG_NAND_SKIP_BAD_DOT_I	1  /* ".i" read skips bad blocks   */
+#define	CFG_NAND_WP		1
+#define CFG_NAND_YAFFS_WRITE	1  /* support yaffs write */
+
+#define CFG_NAND_HWECC
+#undef	CFG_NAND_FLASH_BBT
+
+/* IROM specific data */
+#define SDMMC_BLK_SIZE        (0xD003A500)
+#define COPY_SDMMC_TO_MEM     (0xD003E008)
+
+/*
+ *  Fast Boot 
+*/
+/* Fastboot variables */
+#define CFG_FASTBOOT_TRANSFER_BUFFER            (0x48000000)//(0x50000000)
+#define CFG_FASTBOOT_TRANSFER_BUFFER_SIZE       (0x36000000)//(0x10000000)   /* 256MB */
+#define CFG_FASTBOOT_ADDR_KERNEL                (0x40008000)
+#define CFG_FASTBOOT_ADDR_RAMDISK               (0x40800000)
+#define CFG_FASTBOOT_PAGESIZE                   (2048)  // Page size of booting device
+#define CFG_FASTBOOT_SDMMC_BLOCKSIZE            (512)   // Block size of sdmmc
+
+/* Just one BSP type should be defined. */
+#if defined(CONFIG_CMD_ONENAND) | defined(CONFIG_CMD_NAND) | defined(CONFIG_CMD_MOVINAND)
+#define CONFIG_FASTBOOT
+#endif
+
+#if defined(CONFIG_CMD_NAND)
+#define CFG_FASTBOOT_NANDBSP
+#endif
+#if defined(CONFIG_CMD_ONENAND)
+#define CFG_FASTBOOT_ONENANDBSP
+#endif
+#if defined(CONFIG_CMD_MOVINAND)
+#define CFG_FASTBOOT_SDMMCBSP
+#endif
+
+#if defined(CONFIG_CMD_MOVINAND)
+/* SD/MMC configuration */
+#define CONFIG_MMC
+#define CONFIG_CMD_MMC
+#define CONFIG_GENERIC_MMC
+ 
+
+#ifdef CONFIG_EVT1
+//Select one among 3 mode, default is CONFIG_SDMMC_CH2
+#define CONFIG_SDMMC_CH2 //SDMMC_CH2 (OMPIN[5:1] = 2
+//#define CONFIG_EMMC43_CH0 //eMMC43_CH0 (OMPIN[5:1] = 3)
+#define CONFIG_EMMC44_CH4 //eMMC44_CH4 (OMPIN[5:1] = 4)
+
+#ifdef CONFIG_SDMMC_CH2
+#define CONFIG_S3C_HSMMC
+#undef DEBUG_S3C_HSMMC
+#define USE_MMC2  
+#endif
+
+#ifdef CONFIG_EMMC44_CH4
+#define CONFIG_S5P_MSHC
+#define CONFIG_EMMC		1		
+#define USE_MMC4  
+//#define CONFIG_EMMC_8Bit
+#define CONFIG_EMMC_EMERGENCY
+#endif
+
+#endif //config_evt1
+
+#define MMC_MAX_CHANNEL                5
+ 
+#endif
+
+#define CONFIG_FASTBOOT_SDFUSE 
+
+/*
+ * SD/MMC detection takes a little long time
+ * So, you can ignore detection process for SD/MMC card
+ */
+#undef	CONFIG_NO_SDMMC_DETECTION
+
+#define CONFIG_MTDPARTITION	"80000 400000 3000000"
+#define CONFIG_BOOTDELAY	2
+
+//#if defined (CONFIG_CMD_MOVINAND)
+//#define CONFIG_BOOTCOMMAND      "movi read kernel 40008000;movi read rootfs 40800000 100000;bootm 40008000 40800000"
+//#else
+#define CONFIG_BOOTCOMMAND	"onenand read 40008000 600000 300000;onenand read 40800000 b00000 100000;bootm 40008000 40800000"//"movi read kernel c0008000;bootm c0008000"
+//#endif
+
+/* OneNAND configuration */
+#define CFG_ONENAND_BASE 	(0x0C000000)
+#define CFG_ONENANDXL_BASE      (0x0C600000)
+#define CFG_MAX_ONENAND_DEVICE	1
+#define CONFIG_SYS_ONENAND_BASE CFG_ONENAND_BASE
+   
+#define CONFIG_BOOT_ONENAND_IROM
+//#define CONFIG_NAND
+//#define CONFIG_BOOT_NAND
+#define CONFIG_ONENAND
+#define ONENAND_REG_DBS_DFS_WIDTH 	(0x160)
+#define ONENAND_REG_FLASH_AUX_CNTRL     (0x300)
+
+#define GPNCON_OFFSET		0x830
+#define GPNDAT_OFFSET		0x834
+#define GPNPUD_OFFSET		0x838
+
+#define CONFIG_ENV_IS_IN_AUTO
+//#define CONFIG_ENV_IS_IN_NAND
+
+
+#define CONFIG_4212_AP10_BOOTLOADER "u-boot-exynos4212-evt0-nonfused.bin"
+#define CONFIG_4212_AP11_BOOTLOADER "u-boot-exynos4212-evt1-efused.bin"
+#define CONFIG_4412_BOOTLOADER "u-boot-iTOP-4412.bin"
+#define CONFIG_4412_DVT_BOOTLOADER "u-boot-iTOP-4412.bin"
+
+#define CONFIG_RECOVERY
+#define FACTORY_RESET_MODE 	0xC1	
+#define CHARGING_RESET_MODE	0xC2 
+//#define RECOVERY_MODE 		0xC3
+
+#define CONFIG_TRUSTZONE
+
+#define DEBUG_TC4
+#undef DEBUG_TC4
+#ifdef DEBUG_TC4
+
+#define emmcdbg(fmt,args...) printf(fmt ,##args) //for emmc dbg
+#define sddbg(fmt,args...) printf(fmt ,##args) //for emmc dbg
+#else
+#define emmcdbg(fmt,args...)
+#define sddbg(fmt,args...)
+#endif
+#endif	/* __CONFIG_H */
diff -urN TC4_uboot/include/configs/itop_4412_ubuntu.h iTop4412_uboot/include/configs/itop_4412_ubuntu.h
--- TC4_uboot/include/configs/itop_4412_ubuntu.h	1969-12-31 16:00:00.000000000 -0800
+++ iTop4412_uboot/include/configs/itop_4412_ubuntu.h	2015-11-09 00:59:36.000000000 -0800
@@ -0,0 +1,627 @@
+/*
+ *
+ * Configuation settings for the iTOP-4412 board.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+#define CONFIG_S5PC210      1       /* in a SAMSUNG S5PC210 SoC */
+#define CONFIG_SMDKC210     1
+#define CONFIG_DEVICE_STRING    "iTOP-4412"
+
+#define CONFIG_EVT1     1       /* EVT1 */
+
+#define TC4_PLUS		
+/*----CPU ID Defination----*/
+#define SMDK4212_ID 		0x43220000
+#define SMDK4212_AP11_ID 	0x43220210 //mj
+#define SMDK4212_AP10_ID 	0x43220200 //mj
+
+#define SMDK4412_ID 		0xE4412000
+#define SMDK4412_AP11_ID 	0xE4412211 //mj
+#define SMDK4412_AP10_ID 	0xE4412210 //mj
+
+/* add by cym 20131206 */
+#define SMDK4412_SUPPORT_UBUNTU	1
+/* end add */
+
+/*
+ * SECURE BOOT
+ * */
+//#define CONFIG_SECURE
+
+#ifdef CONFIG_SECURE
+
+/* BL1 size */
+#ifdef CONFIG_EVT1
+#define CONFIG_SECURE_BL1_SIZE			0x2000
+#define CONFIG_SECURE_BL1_ONLY
+//#define CONFIG_SECURE_BOOT			/* Signed Kernel, RFS */
+#else
+#define CONFIG_SECURE_BL1_SIZE			0x4000
+#endif
+
+#ifdef CONFIG_SECURE_BOOT
+#define CONFIG_S5PC210S
+#define CONFIG_SECURE_ROOTFS
+#define CONFIG_SECURE_KERNEL_BASE       0xC0008000
+#define CONFIG_SECURE_KERNEL_SIZE       0x300000
+#define CONFIG_SECURE_ROOTFS_BASE       0xC0800000
+#define CONFIG_SECURE_ROOTFS_SIZE       0x100000
+#endif
+
+#endif
+
+/* add by cym 20130218 */
+/* IV_SIZE: 128 byte, 2 port(1 Gbyte), open page, trrd: 4 */
+#define CONFIG_EVT0_PERFORMANCE
+/* IV_SIZE: 512 Mbyte, 1 port(512 Mbyte), open page, trrd: 4 */
+//#define CONFIG_EVT0_STABLE
+/* IV_SIZE: 128 byte, 2 port(1 Gbyte), close page, trrd: 0xA */
+//#define CONFIG_EVT0_RECOMMEND
+
+/* (Memory Interleaving Size = 1 << IV_SIZE) */
+#ifdef CONFIG_EVT0_STABLE
+#define CONFIG_IV_SIZE 0x1D
+#else
+#define CONFIG_IV_SIZE 0x7
+#endif
+
+#define S5PV310_POWER_BASE	0x10020000
+
+/*
+ * CLOCK
+ */
+#define ELFIN_CLOCK_BASE		0x10030000
+
+#define CLK_SRC_LEFTBUS_OFFSET		0x04200
+#define CLK_MUX_STAT_LEFTBUS_OFFSET	0x04400
+#define CLK_DIV_LEFTBUS_OFFSET		0x04500
+
+#define CLK_SRC_RIGHTBUS_OFFSET		0x08200
+#define CLK_MUX_STAT_RIGHTBUS_OFFSET	0x08400
+#define CLK_DIV_RIGHTBUS_OFFSET		0x08500
+
+#define EPLL_LOCK_OFFSET		0x0C010
+#define VPLL_LOCK_OFFSET		0x0C020
+#define EPLL_CON0_OFFSET		0x0C110
+#define EPLL_CON1_OFFSET		0x0C114
+#ifdef CONFIG_SMDKC220
+#define EPLL_CON2_OFFSET		0x0C118
+#endif
+#define VPLL_CON0_OFFSET		0x0C120
+#define VPLL_CON1_OFFSET		0x0C124
+#ifdef CONFIG_SMDKC220
+#define VPLL_CON2_OFFSET		0x0C128
+#endif
+
+#define CLK_SRC_TOP0_OFFSET		0x0C210
+#define CLK_SRC_TOP1_OFFSET		0x0C214
+#define CLK_SRC_FSYS_OFFSET		0x0C240
+#define CLK_SRC_PERIL0_OFFSET		0x0C250
+#define CLK_MUX_STAT_TOP_OFFSET		0x0C410
+#define CLK_MUX_STAT_TOP1_OFFSET	0x0C414
+#define CLK_DIV_TOP_OFFSET		0x0C510
+#define CLK_DIV_FSYS1_OFFSET		0x0C544
+#define CLK_DIV_FSYS2_OFFSET		0x0C548
+#define CLK_DIV_FSYS3_OFFSET		0x0C54C
+#define CLK_DIV_PERIL0_OFFSET		0x0C550
+
+#define CLK_SRC_DMC_OFFSET		0x10200
+#define CLK_MUX_STAT_DMC_OFFSET		0x10400
+#define CLK_DIV_DMC0_OFFSET		0x10500
+#define CLK_DIV_DMC1_OFFSET		0x10504
+
+#define CLK_GATE_IP_DMC_OFFSET		0x10900
+
+#if defined(CONFIG_SMDKC220) || defined(CONFIG_EXYNOS4412)
+#define CLK_GATE_IP_PERIR_OFFSET	0x08960
+#elif defined(CONFIG_SMDKC210)
+#define CLK_GATE_IP_PERIR_OFFSET	0x0C960
+#endif
+
+#define APLL_LOCK_OFFSET		0x14000
+#define APLL_CON0_OFFSET		0x14100
+#define APLL_CON1_OFFSET		0x14104
+
+#if defined(CONFIG_SMDKC220) || defined(CONFIG_EXYNOS4412)
+#define MPLL_LOCK_OFFSET		0x10008
+#define MPLL_CON0_OFFSET		0x10108
+#define MPLL_CON1_OFFSET		0x1010C
+#elif defined(CONFIG_SMDKC210)
+#define MPLL_LOCK_OFFSET		0x14008
+#define MPLL_CON0_OFFSET		0x14108
+#define MPLL_CON1_OFFSET		0x1410C
+#endif
+
+#define CLK_SRC_CPU_OFFSET		0x14200
+#define CLK_MUX_STAT_CPU_OFFSET		0x14400
+#define CLK_DIV_CPU0_OFFSET		0x14500
+#define CLK_DIV_CPU1_OFFSET		0x14504
+
+#define CLK_SRC_FSYS		__REG(ELFIN_CLOCK_BASE+CLK_SRC_FSYS_OFFSET)
+#define CLK_DIV_FSYS1		__REG(ELFIN_CLOCK_BASE+CLK_DIV_FSYS1_OFFSET)
+#define CLK_DIV_FSYS2		__REG(ELFIN_CLOCK_BASE+CLK_DIV_FSYS2_OFFSET)
+#define CLK_DIV_FSYS3		__REG(ELFIN_CLOCK_BASE+CLK_DIV_FSYS3_OFFSET)
+#define APLL_CON0_REG		__REG(ELFIN_CLOCK_BASE+APLL_CON0_OFFSET)
+#define MPLL_CON0_REG		__REG(ELFIN_CLOCK_BASE+MPLL_CON0_OFFSET)
+#define EPLL_CON0_REG		__REG(ELFIN_CLOCK_BASE+EPLL_CON0_OFFSET)
+#define VPLL_CON0_REG		__REG(ELFIN_CLOCK_BASE+VPLL_CON0_OFFSET)
+
+#define USB_PHY_CONTROL_OFFSET		0x0704
+#define USB_PHY_CONTROL            (0x10020000+USB_PHY_CONTROL_OFFSET)//(ELFIN_CLOCK_POWER_BASE+USB_PHY_CONTROL_OFFSET)
+
+/* end add */
+
+/*********************************************
+ *  Configure clock
+ *********************************************/
+/* APLL : 800Mhz	*/
+//#define CONFIG_CLK_800_330_165
+/* APLL : 1GHz	*/
+#define CONFIG_CLK_1000_400_200
+
+
+#define CONFIG_SPARSEMEM	1		/* Sparsemem for 32 kernel */
+
+#define BOOT_ONENAND	0x1
+#define BOOT_NAND		0x40000
+#define BOOT_MMCSD		0x3
+#define BOOT_NOR		0x4
+#define BOOT_SEC_DEV	0x5
+#define BOOT_EMMC43		0x6
+#define BOOT_EMMC441	0x7
+
+
+#define CONFIG_BOOTM_LINUX      1
+
+/* skip to load BL2 */
+#define FAST_BOOT		1
+
+#define CONFIG_SYS_NO_FLASH
+#define MEMORY_BASE_ADDRESS	0x40000000
+
+/* input clock of PLL */
+#define CONFIG_SYS_CLK_FREQ	24000000	/* the SMDKC210 has 24MHz input clock */
+
+/* MMU Setting  */
+#define CONFIG_ENABLE_MMU
+
+#ifdef CONFIG_ENABLE_MMU
+#define virt_to_phys(x)	virt_to_phy_smdkc210(x)
+#else
+#define virt_to_phys(x)	(x)
+#endif
+
+#define CONFIG_MEMORY_UPPER_CODE
+
+#undef CONFIG_USE_IRQ				/* we don't need IRQ/FIQ stuff */
+
+#define CONFIG_INCLUDE_TEST
+
+#define CONFIG_ZIMAGE_BOOT
+#define CONFIG_IMAGE_BOOT
+
+#define BOARD_LATE_INIT
+
+#define CONFIG_SETUP_MEMORY_TAGS
+#define CONFIG_CMDLINE_TAG
+#define CONFIG_INITRD_TAG
+
+/*
+ * Architecture magic and machine type
+ */
+
+#define MACH_TYPE		2838//(S5PC210:2838, S5PV310:2925)
+#define UBOOT_MAGIC		(0x43090000 | MACH_TYPE)
+#define CHIP_ID_BASE            0x10000000
+#define PKG_ID_BASE		0x10000004
+
+/* Power Management is enabled */
+#define CONFIG_PM
+
+#define CONFIG_TA4
+
+//#define CONFIG_SD_UPDATE
+#define CONFIG_SD_AUTOUPDATE
+
+#ifdef CONFIG_SD_AUTOUPDATE
+#define CONFIG_SD_UPDATE
+#endif
+
+//@@Robin
+#ifndef CONFIG_TA4
+
+#ifdef CONFIG_CLK_800_300_150
+#define CONFIG_PM_11V   /* ARM 1.1v, INT 1.1v */
+#else   /* default or CONFIG_CLK_1000_400_200 */
+//#define CONFIG_PM_12V   /* ARM 1.2v, INT 1.2v */
+#define CONFIG_PM_13V_12V	/* ARM 1.3v, INT 1.2v */
+#endif
+//@@Robin
+#endif
+
+#define CONFIG_DISPLAY_CPUINFO
+#define CONFIG_DISPLAY_BOARDINFO
+
+#undef CONFIG_SKIP_RELOCATE_UBOOT
+#undef CONFIG_USE_NOR_BOOT
+
+/*
+ * Size of malloc() pool
+ */
+#define CONFIG_SYS_MALLOC_LEN		(CONFIG_ENV_SIZE + 1024*1024)
+#define CFG_GBL_DATA_SIZE	128	/* size in bytes reserved for initial data */
+
+#define CFG_STACK_SIZE		512*1024
+
+/*
+ * select serial console configuration
+ */
+#ifndef CONFIG_TA4
+#define CONFIG_SERIAL2          1	/* we use UART1 on SMDKC210 */
+#else
+#define CONFIG_SERIAL3          1	/* we use UART2 on TA4 */
+#endif
+//#define CONFIG_SERIAL4		1
+
+#define CFG_HUSH_PARSER			/* use "hush" command parser	*/
+#ifdef CFG_HUSH_PARSER
+#define CFG_PROMPT_HUSH_PS2	"> "
+#endif
+
+#define CONFIG_CMDLINE_EDITING
+
+#undef CONFIG_S3C64XX_I2C		/* this board has H/W I2C */
+#ifdef CONFIG_S3C64XX_I2C
+#define CONFIG_HARD_I2C		1
+#define CFG_I2C_SPEED		50000
+#define CFG_I2C_SLAVE		0xFE
+#endif
+
+#define CONFIG_DOS_PARTITION
+#define CONFIG_SUPPORT_VFAT
+
+#define CONFIG_USB_OHCI
+#undef CONFIG_USB_STORAGE
+#define CONFIG_S3C_USBD
+
+#define USBD_DOWN_ADDR		0xc0000000
+
+/************************************************************
+ * RTC
+ ************************************************************/
+/* allow to overwrite serial and ethaddr */
+#define CONFIG_ENV_OVERWRITE
+
+#define CONFIG_BAUDRATE		115200
+
+/***********************************************************
+ * Command definition
+ ***********************************************************/
+//#define CONFIG_CMD_CACHE
+//#define CONFIG_CMD_USB
+//#define CONFIG_CMD_REGINFO
+
+//#define	CONFIG_CMD_NAND
+//#define	CONFIG_CMD_FLASH
+
+//#define CONFIG_CMD_ONENAND
+#define CONFIG_CMD_MOVINAND
+
+//#define CONFIG_CMD_PING
+//#define CONFIG_CMD_DATE
+
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_ELF
+//#define CONFIG_CMD_I2C
+
+#define CONFIG_CMD_EXT2
+#define CONFIG_CMD_EXT4
+#define CONFIG_CMD_FAT
+
+#if defined(CONFIG_CMD_KGDB)
+#define CONFIG_KGDB_BAUDRATE	115200		/* speed to run kgdb serial port */
+/* what's this ? it's not used anywhere */
+#define CONFIG_KGDB_SER_INDEX	1		/* which serial port to use */
+#endif
+
+/*
+ * Miscellaneous configurable options
+ */
+#define CONFIG_SYS_LONGHELP                             /* undef to save memory         */
+#define CONFIG_SYS_PROMPT              "iTOP-4412 # "    /* Monitor Command Prompt       */
+
+#define CONFIG_SYS_CBSIZE		256		/* Console I/O Buffer Size	*/
+#define CONFIG_SYS_PBSIZE		384		/* Print Buffer Size */
+#define CONFIG_SYS_MAXARGS		16		/* max number of command args	*/
+#define CONFIG_SYS_BARGSIZE		CONFIG_SYS_CBSIZE	/* Boot Argument Buffer Size	*/
+
+#define CONFIG_SYS_MEMTEST_START	MEMORY_BASE_ADDRESS	/* memtest works on	*/
+
+#define CONFIG_SYS_MEMTEST_END		MEMORY_BASE_ADDRESS + 0x3E00000		/* 256 MB in DRAM	*/
+
+#undef CFG_CLKS_IN_HZ		/* everything, incl board info, in Hz */
+
+#define CONFIG_SYS_LOAD_ADDR		MEMORY_BASE_ADDRESS + 0x00100000	/* default load address	*/
+
+/* the PWM TImer 4 uses a counter of 41687 for 10 ms, so we need */
+/* it to wrap 100 times (total 4168750) to get 1 sec. */
+#define CONFIG_SYS_HZ			4168750		// at PCLK 66MHz
+
+/* valid baudrates */
+#define CONFIG_SYS_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+/*-----------------------------------------------------------------------
+ * Stack sizes
+ *
+ * The stack sizes are set up in start.S using the settings below
+ */
+
+/* MIU Setting  */
+//#define CONFIG_MIU_1BIT_INTERLEAVED
+
+#define CONFIG_STACKSIZE	0x40000		/* regular stack 256KB */
+#ifdef CONFIG_USE_IRQ
+#define CONFIG_STACKSIZE_IRQ	(4*1024)	/* IRQ stack */
+#define CONFIG_STACKSIZE_FIQ	(4*1024)	/* FIQ stack */
+#endif
+
+// SMDKC210 POP-A(512MB)   : 2 banks
+// SMDKC210 POP-B(1024MB)  : 4 banks
+#define CONFIG_NR_DRAM_BANKS    8          	/* 8 banks of DRAM at maximum */
+
+//dg change for kinds of coreboard 2015-08-04
+#if  defined(CONFIG_SCP_1GDDR_Ubuntu) || defined(CONFIG_POP_2GDDR_Ubuntu)
+   #define SDRAM_BANK_SIZE            0x10000000/2	/* each bank has 128 MB */
+
+#elif defined(CONFIG_SCP_2GDDR_Ubuntu) ||  defined(CONFIG_POP_1GDDR_Ubuntu)
+   #define SDRAM_BANK_SIZE           0x10000000	/* each bank has 256 MB */
+
+#endif
+
+
+
+
+
+
+#define PHYS_SDRAM_1            (unsigned long)MEMORY_BASE_ADDRESS /* SDRAM Bank #1 */
+#define PHYS_SDRAM_1_SIZE       (unsigned long)SDRAM_BANK_SIZE
+#define PHYS_SDRAM_2            (unsigned long)(MEMORY_BASE_ADDRESS + SDRAM_BANK_SIZE) /* SDRAM Bank #2 */
+#define PHYS_SDRAM_2_SIZE       (unsigned long)SDRAM_BANK_SIZE
+#define PHYS_SDRAM_3            (unsigned long)(MEMORY_BASE_ADDRESS + 2 * SDRAM_BANK_SIZE) /* SDRAM Bank #2 */
+#define PHYS_SDRAM_3_SIZE       (unsigned long)SDRAM_BANK_SIZE
+#define PHYS_SDRAM_4            (unsigned long)(MEMORY_BASE_ADDRESS + 3 * SDRAM_BANK_SIZE) /* SDRAM Bank #2 */
+#define PHYS_SDRAM_4_SIZE       (unsigned long)SDRAM_BANK_SIZE
+#define PHYS_SDRAM_5            (unsigned long)(MEMORY_BASE_ADDRESS + 4 * SDRAM_BANK_SIZE) /* SDRAM Bank #2 */
+#define PHYS_SDRAM_5_SIZE       (unsigned long)SDRAM_BANK_SIZE
+#define PHYS_SDRAM_6            (unsigned long)(MEMORY_BASE_ADDRESS + 5 * SDRAM_BANK_SIZE) /* SDRAM Bank #2 */
+#define PHYS_SDRAM_6_SIZE       (unsigned long)SDRAM_BANK_SIZE
+#define PHYS_SDRAM_7            (unsigned long)(MEMORY_BASE_ADDRESS + 6 * SDRAM_BANK_SIZE) /* SDRAM Bank #2 */
+#define PHYS_SDRAM_7_SIZE       (unsigned long)SDRAM_BANK_SIZE
+#define PHYS_SDRAM_8            (unsigned long)(MEMORY_BASE_ADDRESS + 7 * SDRAM_BANK_SIZE) /* SDRAM Bank #2 */
+#define PHYS_SDRAM_8_SIZE       (unsigned long)SDRAM_BANK_SIZE
+
+
+
+
+#define CFG_FLASH_BASE		0x80000000
+
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#define CONFIG_MX_LV640EB		/* MX29LV640EB */
+//#define CONFIG_AMD_LV800		/* AM29LV800BB */
+
+#define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks */
+
+#if	defined(CONFIG_MX_LV640EB)
+#define CFG_MAX_FLASH_SECT	135
+#define PHYS_FLASH_SIZE		0x800000	/* 8MB */
+#elif	defined(CONFIG_AMD_LV800)
+#define CFG_MAX_FLASH_SECT	19
+#define PHYS_FLASH_SIZE		0x100000	/* 1MB */
+#else
+#define CFG_MAX_FLASH_SECT	512
+#define PHYS_FLASH_SIZE		0x100000	/* 1MB */
+#endif
+
+#define CFG_FLASH_LEGACY_512Kx16
+//#define CONFIG_FLASH_CFI_LEGACY
+#define CFG_FLASH_CFI
+
+/* timeout values are in ticks */
+#define CFG_FLASH_ERASE_TOUT	(5*CFG_HZ) /* Timeout for Flash Erase */
+#define CFG_FLASH_WRITE_TOUT	(5*CFG_HZ) /* Timeout for Flash Write */
+
+#define CFG_ENV_ADDR		0
+#define CONFIG_ENV_SIZE		0x4000	/* Total Size of Environment Sector */
+
+/*
+ * SMDKC210 board specific data
+ */
+
+#define CONFIG_IDENT_STRING	" for iTOP-4412 Android"
+
+/* total memory required by uboot */
+#define CFG_UBOOT_SIZE		(2*1024*1024)
+
+ /* base address for uboot */
+//#ifdef CONFIG_ENABLE_MMU
+//#define CFG_UBOOT_BASE		0xc3e00000
+//#else
+#define CFG_UBOOT_BASE		0x43e00000
+//#endif
+
+#define CFG_PHY_UBOOT_BASE	MEMORY_BASE_ADDRESS + 0x3e00000
+#define CFG_PHY_KERNEL_BASE	MEMORY_BASE_ADDRESS + 0x8000
+
+#define CONFIG_ENV_OFFSET	0x0007C000
+
+/* nand copy size from nand to DRAM.*/
+#define	COPY_BL2_SIZE		0x80000
+
+/* NAND configuration */
+#define CONFIG_SYS_MAX_NAND_DEVICE     1
+#define CONFIG_SYS_NAND_BASE           (0x0CE00000)
+#define NAND_MAX_CHIPS          1
+
+#define NAND_DISABLE_CE()	(NFCONT_REG |= (1 << 1))
+#define NAND_ENABLE_CE()	(NFCONT_REG &= ~(1 << 1))
+#define NF_TRANSRnB()		do { while(!(NFSTAT_REG & (1 << 0))); } while(0)
+
+#define CFG_NAND_SKIP_BAD_DOT_I	1  /* ".i" read skips bad blocks   */
+#define	CFG_NAND_WP		1
+#define CFG_NAND_YAFFS_WRITE	1  /* support yaffs write */
+
+#define CFG_NAND_HWECC
+#undef	CFG_NAND_FLASH_BBT
+
+/* IROM specific data */
+#define SDMMC_BLK_SIZE        (0xD003A500)
+#define COPY_SDMMC_TO_MEM     (0xD003E008)
+
+/*
+ *  Fast Boot 
+*/
+/* Fastboot variables */
+#define CFG_FASTBOOT_TRANSFER_BUFFER            (0x48000000)//(0x50000000)
+#define CFG_FASTBOOT_TRANSFER_BUFFER_SIZE       (0x36000000)//(0x10000000)   /* 256MB */
+#define CFG_FASTBOOT_ADDR_KERNEL                (0x40008000)
+#define CFG_FASTBOOT_ADDR_RAMDISK               (0x40800000)
+#define CFG_FASTBOOT_PAGESIZE                   (2048)  // Page size of booting device
+#define CFG_FASTBOOT_SDMMC_BLOCKSIZE            (512)   // Block size of sdmmc
+
+/* Just one BSP type should be defined. */
+#if defined(CONFIG_CMD_ONENAND) | defined(CONFIG_CMD_NAND) | defined(CONFIG_CMD_MOVINAND)
+#define CONFIG_FASTBOOT
+#endif
+
+#if defined(CONFIG_CMD_NAND)
+#define CFG_FASTBOOT_NANDBSP
+#endif
+#if defined(CONFIG_CMD_ONENAND)
+#define CFG_FASTBOOT_ONENANDBSP
+#endif
+#if defined(CONFIG_CMD_MOVINAND)
+#define CFG_FASTBOOT_SDMMCBSP
+#endif
+
+#if defined(CONFIG_CMD_MOVINAND)
+/* SD/MMC configuration */
+#define CONFIG_MMC
+#define CONFIG_CMD_MMC
+#define CONFIG_GENERIC_MMC
+ 
+
+#ifdef CONFIG_EVT1
+//Select one among 3 mode, default is CONFIG_SDMMC_CH2
+#define CONFIG_SDMMC_CH2 //SDMMC_CH2 (OMPIN[5:1] = 2
+//#define CONFIG_EMMC43_CH0 //eMMC43_CH0 (OMPIN[5:1] = 3)
+#define CONFIG_EMMC44_CH4 //eMMC44_CH4 (OMPIN[5:1] = 4)
+
+#ifdef CONFIG_SDMMC_CH2
+#define CONFIG_S3C_HSMMC
+#undef DEBUG_S3C_HSMMC
+#define USE_MMC2  
+#endif
+
+#ifdef CONFIG_EMMC44_CH4
+#define CONFIG_S5P_MSHC
+#define CONFIG_EMMC		1		
+#define USE_MMC4  
+//#define CONFIG_EMMC_8Bit
+#define CONFIG_EMMC_EMERGENCY
+#endif
+
+#endif //config_evt1
+
+#define MMC_MAX_CHANNEL                5
+ 
+#endif
+
+#define CONFIG_FASTBOOT_SDFUSE 
+
+/*
+ * SD/MMC detection takes a little long time
+ * So, you can ignore detection process for SD/MMC card
+ */
+#undef	CONFIG_NO_SDMMC_DETECTION
+
+#define CONFIG_MTDPARTITION	"80000 400000 3000000"
+#define CONFIG_BOOTDELAY	2
+
+//#if defined (CONFIG_CMD_MOVINAND)
+//#define CONFIG_BOOTCOMMAND      "movi read kernel 40008000;movi read rootfs 40800000 100000;bootm 40008000 40800000"
+//#else
+#define CONFIG_BOOTCOMMAND	"onenand read 40008000 600000 300000;onenand read 40800000 b00000 100000;bootm 40008000 40800000"//"movi read kernel c0008000;bootm c0008000"
+//#endif
+
+/* OneNAND configuration */
+#define CFG_ONENAND_BASE 	(0x0C000000)
+#define CFG_ONENANDXL_BASE      (0x0C600000)
+#define CFG_MAX_ONENAND_DEVICE	1
+#define CONFIG_SYS_ONENAND_BASE CFG_ONENAND_BASE
+   
+#define CONFIG_BOOT_ONENAND_IROM
+//#define CONFIG_NAND
+//#define CONFIG_BOOT_NAND
+#define CONFIG_ONENAND
+#define ONENAND_REG_DBS_DFS_WIDTH 	(0x160)
+#define ONENAND_REG_FLASH_AUX_CNTRL     (0x300)
+
+#define GPNCON_OFFSET		0x830
+#define GPNDAT_OFFSET		0x834
+#define GPNPUD_OFFSET		0x838
+
+#define CONFIG_ENV_IS_IN_AUTO
+//#define CONFIG_ENV_IS_IN_NAND
+
+
+#define CONFIG_4212_AP10_BOOTLOADER "u-boot-exynos4212-evt0-nonfused.bin"
+#define CONFIG_4212_AP11_BOOTLOADER "u-boot-exynos4212-evt1-efused.bin"
+#define CONFIG_4412_BOOTLOADER "u-boot-iTOP-4412.bin"
+#define CONFIG_4412_DVT_BOOTLOADER "u-boot-iTOP-4412.bin"
+
+#define CONFIG_RECOVERY
+#define FACTORY_RESET_MODE 	0xC1	
+#define CHARGING_RESET_MODE	0xC2 
+//#define RECOVERY_MODE 		0xC3
+
+#define CONFIG_TRUSTZONE
+
+#define DEBUG_TC4
+#undef DEBUG_TC4
+#ifdef DEBUG_TC4
+
+#define emmcdbg(fmt,args...) printf(fmt ,##args) //for emmc dbg
+#define sddbg(fmt,args...) printf(fmt ,##args) //for emmc dbg
+#else
+#define emmcdbg(fmt,args...)
+#define sddbg(fmt,args...)
+#endif
+#endif	/* __CONFIG_H */
diff -urN TC4_uboot/include/configs/tc4_android.h iTop4412_uboot/include/configs/tc4_android.h
--- TC4_uboot/include/configs/tc4_android.h	2012-04-24 01:02:09.000000000 -0700
+++ iTop4412_uboot/include/configs/tc4_android.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,526 +0,0 @@
-/*
- *
- * Configuation settings for the SAMSUNG TC4 board.
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#ifndef __CONFIG_H
-#define __CONFIG_H
-
-/*
- * High Level Configuration Options
- * (easy to change)
- */
-#define CONFIG_S5PC210      1       /* in a SAMSUNG S5PC210 SoC */
-#define CONFIG_SMDKC210     1
-#define CONFIG_DEVICE_STRING    "TC4-"
-
-#define CONFIG_EVT1     1       /* EVT1 */
-
-
-/*----CPU ID Defination----*/
-#define SMDK4212_ID 		0x43220000
-#define SMDK4212_AP11_ID 	0x43220210 //mj
-#define SMDK4212_AP10_ID 	0x43220200 //mj
-
-#define SMDK4412_ID 		0xE4412000
-#define SMDK4412_AP11_ID 	0xE4412211 //mj
-#define SMDK4412_AP10_ID 	0xE4412210 //mj
-
-
-/*
- * SECURE BOOT
- * */
-//#define CONFIG_SECURE
-
-#ifdef CONFIG_SECURE
-
-/* BL1 size */
-#ifdef CONFIG_EVT1
-#define CONFIG_SECURE_BL1_SIZE			0x2000
-#define CONFIG_SECURE_BL1_ONLY
-//#define CONFIG_SECURE_BOOT			/* Signed Kernel, RFS */
-#else
-#define CONFIG_SECURE_BL1_SIZE			0x4000
-#endif
-
-#ifdef CONFIG_SECURE_BOOT
-#define CONFIG_S5PC210S
-#define CONFIG_SECURE_ROOTFS
-#define CONFIG_SECURE_KERNEL_BASE       0xC0008000
-#define CONFIG_SECURE_KERNEL_SIZE       0x300000
-#define CONFIG_SECURE_ROOTFS_BASE       0xC0800000
-#define CONFIG_SECURE_ROOTFS_SIZE       0x100000
-#endif
-
-#endif
-
-
-/*********************************************
- *  Configure clock
- *********************************************/
-/* APLL : 800Mhz	*/
-//#define CONFIG_CLK_800_330_165
-/* APLL : 1GHz	*/
-#define CONFIG_CLK_1000_400_200
-
-
-#define CONFIG_SPARSEMEM	1		/* Sparsemem for 32 kernel */
-
-#define BOOT_ONENAND	0x1
-#define BOOT_NAND		0x40000
-#define BOOT_MMCSD		0x3
-#define BOOT_NOR		0x4
-#define BOOT_SEC_DEV	0x5
-#define BOOT_EMMC43		0x6
-#define BOOT_EMMC441	0x7
-
-
-#define CONFIG_BOOTM_LINUX      1
-
-/* skip to load BL2 */
-#define FAST_BOOT		1
-
-#define CONFIG_SYS_NO_FLASH
-#define MEMORY_BASE_ADDRESS	0x40000000
-
-/* input clock of PLL */
-#define CONFIG_SYS_CLK_FREQ	24000000	/* the SMDKC210 has 24MHz input clock */
-
-/* MMU Setting  */
-#define CONFIG_ENABLE_MMU
-
-#ifdef CONFIG_ENABLE_MMU
-#define virt_to_phys(x)	virt_to_phy_smdkc210(x)
-#else
-#define virt_to_phys(x)	(x)
-#endif
-
-#define CONFIG_MEMORY_UPPER_CODE
-
-#undef CONFIG_USE_IRQ				/* we don't need IRQ/FIQ stuff */
-
-#define CONFIG_INCLUDE_TEST
-
-#define CONFIG_ZIMAGE_BOOT
-#define CONFIG_IMAGE_BOOT
-
-#define BOARD_LATE_INIT
-
-#define CONFIG_SETUP_MEMORY_TAGS
-#define CONFIG_CMDLINE_TAG
-#define CONFIG_INITRD_TAG
-
-/*
- * Architecture magic and machine type
- */
-
-#define MACH_TYPE		2838//(S5PC210:2838, S5PV310:2925)
-#define UBOOT_MAGIC		(0x43090000 | MACH_TYPE)
-#define CHIP_ID_BASE            0x10000000
-#define PKG_ID_BASE		0x10000004
-
-/* Power Management is enabled */
-#define CONFIG_PM
-
-#define CONFIG_TA4
-
-//#define CONFIG_SD_UPDATE
-#define CONFIG_SD_AUTOUPDATE
-
-#ifdef CONFIG_SD_AUTOUPDATE
-#define CONFIG_SD_UPDATE
-#endif
-
-//@@Robin
-#ifndef CONFIG_TA4
-
-#ifdef CONFIG_CLK_800_300_150
-#define CONFIG_PM_11V   /* ARM 1.1v, INT 1.1v */
-#else   /* default or CONFIG_CLK_1000_400_200 */
-//#define CONFIG_PM_12V   /* ARM 1.2v, INT 1.2v */
-#define CONFIG_PM_13V_12V	/* ARM 1.3v, INT 1.2v */
-#endif
-//@@Robin
-#endif
-
-#define CONFIG_DISPLAY_CPUINFO
-#define CONFIG_DISPLAY_BOARDINFO
-
-#undef CONFIG_SKIP_RELOCATE_UBOOT
-#undef CONFIG_USE_NOR_BOOT
-
-/*
- * Size of malloc() pool
- */
-#define CONFIG_SYS_MALLOC_LEN		(CONFIG_ENV_SIZE + 1024*1024)
-#define CFG_GBL_DATA_SIZE	128	/* size in bytes reserved for initial data */
-
-#define CFG_STACK_SIZE		512*1024
-
-/*
- * select serial console configuration
- */
-#ifndef CONFIG_TA4
-#define CONFIG_SERIAL2          1	/* we use UART1 on SMDKC210 */
-#else
-#define CONFIG_SERIAL3          1	/* we use UART2 on TA4 */
-#endif
-//#define CONFIG_SERIAL4		1
-
-#define CFG_HUSH_PARSER			/* use "hush" command parser	*/
-#ifdef CFG_HUSH_PARSER
-#define CFG_PROMPT_HUSH_PS2	"> "
-#endif
-
-#define CONFIG_CMDLINE_EDITING
-
-#undef CONFIG_S3C64XX_I2C		/* this board has H/W I2C */
-#ifdef CONFIG_S3C64XX_I2C
-#define CONFIG_HARD_I2C		1
-#define CFG_I2C_SPEED		50000
-#define CFG_I2C_SLAVE		0xFE
-#endif
-
-#define CONFIG_DOS_PARTITION
-#define CONFIG_SUPPORT_VFAT
-
-#define CONFIG_USB_OHCI
-#undef CONFIG_USB_STORAGE
-#define CONFIG_S3C_USBD
-
-#define USBD_DOWN_ADDR		0xc0000000
-
-/************************************************************
- * RTC
- ************************************************************/
-/* allow to overwrite serial and ethaddr */
-#define CONFIG_ENV_OVERWRITE
-
-#define CONFIG_BAUDRATE		115200
-
-/***********************************************************
- * Command definition
- ***********************************************************/
-//#define CONFIG_CMD_CACHE
-//#define CONFIG_CMD_USB
-//#define CONFIG_CMD_REGINFO
-
-//#define	CONFIG_CMD_NAND
-//#define	CONFIG_CMD_FLASH
-
-//#define CONFIG_CMD_ONENAND
-#define CONFIG_CMD_MOVINAND
-
-//#define CONFIG_CMD_PING
-//#define CONFIG_CMD_DATE
-
-#include <config_cmd_default.h>
-
-#define CONFIG_CMD_ELF
-//#define CONFIG_CMD_I2C
-
-#define CONFIG_CMD_EXT2
-#define CONFIG_CMD_EXT4
-#define CONFIG_CMD_FAT
-
-#if defined(CONFIG_CMD_KGDB)
-#define CONFIG_KGDB_BAUDRATE	115200		/* speed to run kgdb serial port */
-/* what's this ? it's not used anywhere */
-#define CONFIG_KGDB_SER_INDEX	1		/* which serial port to use */
-#endif
-
-/*
- * Miscellaneous configurable options
- */
-#define CONFIG_SYS_LONGHELP                             /* undef to save memory         */
-#define CONFIG_SYS_PROMPT              "TC4 # "    /* Monitor Command Prompt       */
-
-#define CONFIG_SYS_CBSIZE		256		/* Console I/O Buffer Size	*/
-#define CONFIG_SYS_PBSIZE		384		/* Print Buffer Size */
-#define CONFIG_SYS_MAXARGS		16		/* max number of command args	*/
-#define CONFIG_SYS_BARGSIZE		CONFIG_SYS_CBSIZE	/* Boot Argument Buffer Size	*/
-
-#define CONFIG_SYS_MEMTEST_START	MEMORY_BASE_ADDRESS	/* memtest works on	*/
-
-#define CONFIG_SYS_MEMTEST_END		MEMORY_BASE_ADDRESS + 0x3E00000		/* 256 MB in DRAM	*/
-
-#undef CFG_CLKS_IN_HZ		/* everything, incl board info, in Hz */
-
-#define CONFIG_SYS_LOAD_ADDR		MEMORY_BASE_ADDRESS + 0x00100000	/* default load address	*/
-
-/* the PWM TImer 4 uses a counter of 41687 for 10 ms, so we need */
-/* it to wrap 100 times (total 4168750) to get 1 sec. */
-#define CONFIG_SYS_HZ			4168750		// at PCLK 66MHz
-
-/* valid baudrates */
-#define CONFIG_SYS_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
-
-/*-----------------------------------------------------------------------
- * Stack sizes
- *
- * The stack sizes are set up in start.S using the settings below
- */
-
-/* MIU Setting  */
-//#define CONFIG_MIU_1BIT_INTERLEAVED
-
-#define CONFIG_STACKSIZE	0x40000		/* regular stack 256KB */
-#ifdef CONFIG_USE_IRQ
-#define CONFIG_STACKSIZE_IRQ	(4*1024)	/* IRQ stack */
-#define CONFIG_STACKSIZE_FIQ	(4*1024)	/* FIQ stack */
-#endif
-
-// SMDKC210 POP-A(512MB)   : 2 banks
-// SMDKC210 POP-B(1024MB)  : 4 banks
-#define CONFIG_NR_DRAM_BANKS    8          	/* 8 banks of DRAM at maximum */
-#define SDRAM_BANK_SIZE         0x10000000	/* each bank has 256 MB */
-#define PHYS_SDRAM_1            (unsigned long)MEMORY_BASE_ADDRESS /* SDRAM Bank #1 */
-#define PHYS_SDRAM_1_SIZE       (unsigned long)SDRAM_BANK_SIZE
-#define PHYS_SDRAM_2            (unsigned long)(MEMORY_BASE_ADDRESS + SDRAM_BANK_SIZE) /* SDRAM Bank #2 */
-#define PHYS_SDRAM_2_SIZE       (unsigned long)SDRAM_BANK_SIZE
-#define PHYS_SDRAM_3            (unsigned long)(MEMORY_BASE_ADDRESS + 2 * SDRAM_BANK_SIZE) /* SDRAM Bank #2 */
-#define PHYS_SDRAM_3_SIZE       (unsigned long)SDRAM_BANK_SIZE
-#define PHYS_SDRAM_4            (unsigned long)(MEMORY_BASE_ADDRESS + 3 * SDRAM_BANK_SIZE) /* SDRAM Bank #2 */
-#define PHYS_SDRAM_4_SIZE       (unsigned long)SDRAM_BANK_SIZE
-#define PHYS_SDRAM_5            (unsigned long)(MEMORY_BASE_ADDRESS + 4 * SDRAM_BANK_SIZE) /* SDRAM Bank #2 */
-#define PHYS_SDRAM_5_SIZE       (unsigned long)SDRAM_BANK_SIZE
-#define PHYS_SDRAM_6            (unsigned long)(MEMORY_BASE_ADDRESS + 5 * SDRAM_BANK_SIZE) /* SDRAM Bank #2 */
-#define PHYS_SDRAM_6_SIZE       (unsigned long)SDRAM_BANK_SIZE
-#define PHYS_SDRAM_7            (unsigned long)(MEMORY_BASE_ADDRESS + 6 * SDRAM_BANK_SIZE) /* SDRAM Bank #2 */
-#define PHYS_SDRAM_7_SIZE       (unsigned long)SDRAM_BANK_SIZE
-#define PHYS_SDRAM_8            (unsigned long)(MEMORY_BASE_ADDRESS + 7 * SDRAM_BANK_SIZE) /* SDRAM Bank #2 */
-#define PHYS_SDRAM_8_SIZE       (unsigned long)SDRAM_BANK_SIZE
-
-
-
-
-#define CFG_FLASH_BASE		0x80000000
-
-/*-----------------------------------------------------------------------
- * FLASH and environment organization
- */
-#define CONFIG_MX_LV640EB		/* MX29LV640EB */
-//#define CONFIG_AMD_LV800		/* AM29LV800BB */
-
-#define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks */
-
-#if	defined(CONFIG_MX_LV640EB)
-#define CFG_MAX_FLASH_SECT	135
-#define PHYS_FLASH_SIZE		0x800000	/* 8MB */
-#elif	defined(CONFIG_AMD_LV800)
-#define CFG_MAX_FLASH_SECT	19
-#define PHYS_FLASH_SIZE		0x100000	/* 1MB */
-#else
-#define CFG_MAX_FLASH_SECT	512
-#define PHYS_FLASH_SIZE		0x100000	/* 1MB */
-#endif
-
-#define CFG_FLASH_LEGACY_512Kx16
-//#define CONFIG_FLASH_CFI_LEGACY
-#define CFG_FLASH_CFI
-
-/* timeout values are in ticks */
-#define CFG_FLASH_ERASE_TOUT	(5*CFG_HZ) /* Timeout for Flash Erase */
-#define CFG_FLASH_WRITE_TOUT	(5*CFG_HZ) /* Timeout for Flash Write */
-
-#define CFG_ENV_ADDR		0
-#define CONFIG_ENV_SIZE		0x4000	/* Total Size of Environment Sector */
-
-/*
- * SMDKC210 board specific data
- */
-
-#define CONFIG_IDENT_STRING	" for TC4 Android"
-
-/* total memory required by uboot */
-#define CFG_UBOOT_SIZE		(2*1024*1024)
-
- /* base address for uboot */
-//#ifdef CONFIG_ENABLE_MMU
-//#define CFG_UBOOT_BASE		0xc3e00000
-//#else
-#define CFG_UBOOT_BASE		0x43e00000
-//#endif
-
-#define CFG_PHY_UBOOT_BASE	MEMORY_BASE_ADDRESS + 0x3e00000
-#define CFG_PHY_KERNEL_BASE	MEMORY_BASE_ADDRESS + 0x8000
-
-#define CONFIG_ENV_OFFSET	0x0007C000
-
-/* nand copy size from nand to DRAM.*/
-#define	COPY_BL2_SIZE		0x80000
-
-/* NAND configuration */
-#define CONFIG_SYS_MAX_NAND_DEVICE     1
-#define CONFIG_SYS_NAND_BASE           (0x0CE00000)
-#define NAND_MAX_CHIPS          1
-
-#define NAND_DISABLE_CE()	(NFCONT_REG |= (1 << 1))
-#define NAND_ENABLE_CE()	(NFCONT_REG &= ~(1 << 1))
-#define NF_TRANSRnB()		do { while(!(NFSTAT_REG & (1 << 0))); } while(0)
-
-#define CFG_NAND_SKIP_BAD_DOT_I	1  /* ".i" read skips bad blocks   */
-#define	CFG_NAND_WP		1
-#define CFG_NAND_YAFFS_WRITE	1  /* support yaffs write */
-
-#define CFG_NAND_HWECC
-#undef	CFG_NAND_FLASH_BBT
-
-/* IROM specific data */
-#define SDMMC_BLK_SIZE        (0xD003A500)
-#define COPY_SDMMC_TO_MEM     (0xD003E008)
-
-/*
- *  Fast Boot 
-*/
-/* Fastboot variables */
-#define CFG_FASTBOOT_TRANSFER_BUFFER            (0x50000000)
-#define CFG_FASTBOOT_TRANSFER_BUFFER_SIZE       (0x10000000)   /* 256MB */
-#define CFG_FASTBOOT_ADDR_KERNEL                (0x40008000)
-#define CFG_FASTBOOT_ADDR_RAMDISK               (0x40800000)
-#define CFG_FASTBOOT_PAGESIZE                   (2048)  // Page size of booting device
-#define CFG_FASTBOOT_SDMMC_BLOCKSIZE            (512)   // Block size of sdmmc
-
-/* Just one BSP type should be defined. */
-#if defined(CONFIG_CMD_ONENAND) | defined(CONFIG_CMD_NAND) | defined(CONFIG_CMD_MOVINAND)
-#define CONFIG_FASTBOOT
-#endif
-
-#if defined(CONFIG_CMD_NAND)
-#define CFG_FASTBOOT_NANDBSP
-#endif
-#if defined(CONFIG_CMD_ONENAND)
-#define CFG_FASTBOOT_ONENANDBSP
-#endif
-#if defined(CONFIG_CMD_MOVINAND)
-#define CFG_FASTBOOT_SDMMCBSP
-#endif
-
-#if defined(CONFIG_CMD_MOVINAND)
-/* SD/MMC configuration */
-#define CONFIG_MMC
-#define CONFIG_CMD_MMC
-#define CONFIG_GENERIC_MMC
- 
-
-#ifdef CONFIG_EVT1
-//Select one among 3 mode, default is CONFIG_SDMMC_CH2
-#define CONFIG_SDMMC_CH2 //SDMMC_CH2 (OMPIN[5:1] = 2
-//#define CONFIG_EMMC43_CH0 //eMMC43_CH0 (OMPIN[5:1] = 3)
-#define CONFIG_EMMC44_CH4 //eMMC44_CH4 (OMPIN[5:1] = 4)
-
-#ifdef CONFIG_SDMMC_CH2
-#define CONFIG_S3C_HSMMC
-#undef DEBUG_S3C_HSMMC
-#define USE_MMC2  
-#endif
-
-#ifdef CONFIG_EMMC44_CH4
-#define CONFIG_S5P_MSHC
-#define CONFIG_EMMC		1		
-#define USE_MMC4  
-//#define CONFIG_EMMC_8Bit
-#define CONFIG_EMMC_EMERGENCY
-#endif
-
-#endif //config_evt1
-
-#define MMC_MAX_CHANNEL                5
- 
-#endif
-
-#define CONFIG_FASTBOOT_SDFUSE 
-
-/*
- * SD/MMC detection takes a little long time
- * So, you can ignore detection process for SD/MMC card
- */
-#undef	CONFIG_NO_SDMMC_DETECTION
-
-#define CONFIG_MTDPARTITION	"80000 400000 3000000"
-#define CONFIG_BOOTDELAY	3
-
-//#if defined (CONFIG_CMD_MOVINAND)
-//#define CONFIG_BOOTCOMMAND      "movi read kernel 40008000;movi read rootfs 40800000 100000;bootm 40008000 40800000"
-//#else
-#define CONFIG_BOOTCOMMAND	"onenand read 40008000 600000 300000;onenand read 40800000 b00000 100000;bootm 40008000 40800000"//"movi read kernel c0008000;bootm c0008000"
-//#endif
-
-/* OneNAND configuration */
-#define CFG_ONENAND_BASE 	(0x0C000000)
-#define CFG_ONENANDXL_BASE      (0x0C600000)
-#define CFG_MAX_ONENAND_DEVICE	1
-#define CONFIG_SYS_ONENAND_BASE CFG_ONENAND_BASE
-   
-#define CONFIG_BOOT_ONENAND_IROM
-//#define CONFIG_NAND
-//#define CONFIG_BOOT_NAND
-#define CONFIG_ONENAND
-#define ONENAND_REG_DBS_DFS_WIDTH 	(0x160)
-#define ONENAND_REG_FLASH_AUX_CNTRL     (0x300)
-
-#define GPNCON_OFFSET		0x830
-#define GPNDAT_OFFSET		0x834
-#define GPNPUD_OFFSET		0x838
-
-#define CONFIG_ENV_IS_IN_AUTO
-//#define CONFIG_ENV_IS_IN_NAND
-
-
-#define CONFIG_4212_AP10_BOOTLOADER "u-boot-exynos4212-evt0-nonfused.bin"
-#define CONFIG_4212_AP11_BOOTLOADER "u-boot-exynos4212-evt1-efused.bin"
-#define CONFIG_4412_BOOTLOADER "u-boot-exynos4412-evt0-nonfused.bin"
-#define CONFIG_4412_DVT_BOOTLOADER "u-boot-exynos4412-evt1-efused.bin"
-
-#define CONFIG_RECOVERY
-#define FACTORY_RESET_MODE 	0xC1	
-#define CHARGING_RESET_MODE	0xC2 
-//#define RECOVERY_MODE 		0xC3
-
-/*-----LCD---------*/
-//#define CONFIG_LOGO_DISPLAY
-
-#ifdef CONFIG_LOGO_DISPLAY
-#define CFG_LCD_NONAME1
-#define CFG_LCD_FBUFFER				(0x4c000000)
-#define PART_SIZE_LOGO		(80*1024) // 80KB
-#define CFG_MAX_LOGO_NUM			6 // 6 pic to show
-#define LOGO_PARTITION_START (14*1024*1024) 
-
-#define BOOT_LOGO 		0  	
-#define BATTERY_LOGO 	1
-#define	RECOVERY_LOGO 	4  
-#define UPDATING_LOGO 	5
-
-#endif
-#define CONFIG_TRUSTZONE
-
-#define DEBUG_TC4
-#undef DEBUG_TC4
-#ifdef DEBUG_TC4
-
-#define emmcdbg(fmt,args...) printf(fmt ,##args) //for emmc dbg
-#define sddbg(fmt,args...) printf(fmt ,##args) //for emmc dbg
-#else
-#define emmcdbg(fmt,args...)
-#define sddbg(fmt,args...)
-#endif
-#endif	/* __CONFIG_H */
diff -urN TC4_uboot/include/configs/tc4_plus_android.h iTop4412_uboot/include/configs/tc4_plus_android.h
--- TC4_uboot/include/configs/tc4_plus_android.h	2012-04-24 01:02:09.000000000 -0700
+++ iTop4412_uboot/include/configs/tc4_plus_android.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,526 +0,0 @@
-/*
- *
- * Configuation settings for the SAMSUNG TC4 board.
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#ifndef __CONFIG_H
-#define __CONFIG_H
-
-/*
- * High Level Configuration Options
- * (easy to change)
- */
-#define CONFIG_S5PC210      1       /* in a SAMSUNG S5PC210 SoC */
-#define CONFIG_SMDKC210     1
-#define CONFIG_DEVICE_STRING    "TC4-"
-
-#define CONFIG_EVT1     1       /* EVT1 */
-
-#define TC4_PLUS		
-/*----CPU ID Defination----*/
-#define SMDK4212_ID 		0x43220000
-#define SMDK4212_AP11_ID 	0x43220210 //mj
-#define SMDK4212_AP10_ID 	0x43220200 //mj
-
-#define SMDK4412_ID 		0xE4412000
-#define SMDK4412_AP11_ID 	0xE4412211 //mj
-#define SMDK4412_AP10_ID 	0xE4412210 //mj
-
-
-/*
- * SECURE BOOT
- * */
-//#define CONFIG_SECURE
-
-#ifdef CONFIG_SECURE
-
-/* BL1 size */
-#ifdef CONFIG_EVT1
-#define CONFIG_SECURE_BL1_SIZE			0x2000
-#define CONFIG_SECURE_BL1_ONLY
-//#define CONFIG_SECURE_BOOT			/* Signed Kernel, RFS */
-#else
-#define CONFIG_SECURE_BL1_SIZE			0x4000
-#endif
-
-#ifdef CONFIG_SECURE_BOOT
-#define CONFIG_S5PC210S
-#define CONFIG_SECURE_ROOTFS
-#define CONFIG_SECURE_KERNEL_BASE       0xC0008000
-#define CONFIG_SECURE_KERNEL_SIZE       0x300000
-#define CONFIG_SECURE_ROOTFS_BASE       0xC0800000
-#define CONFIG_SECURE_ROOTFS_SIZE       0x100000
-#endif
-
-#endif
-
-
-/*********************************************
- *  Configure clock
- *********************************************/
-/* APLL : 800Mhz	*/
-//#define CONFIG_CLK_800_330_165
-/* APLL : 1GHz	*/
-#define CONFIG_CLK_1000_400_200
-
-
-#define CONFIG_SPARSEMEM	1		/* Sparsemem for 32 kernel */
-
-#define BOOT_ONENAND	0x1
-#define BOOT_NAND		0x40000
-#define BOOT_MMCSD		0x3
-#define BOOT_NOR		0x4
-#define BOOT_SEC_DEV	0x5
-#define BOOT_EMMC43		0x6
-#define BOOT_EMMC441	0x7
-
-
-#define CONFIG_BOOTM_LINUX      1
-
-/* skip to load BL2 */
-#define FAST_BOOT		1
-
-#define CONFIG_SYS_NO_FLASH
-#define MEMORY_BASE_ADDRESS	0x40000000
-
-/* input clock of PLL */
-#define CONFIG_SYS_CLK_FREQ	24000000	/* the SMDKC210 has 24MHz input clock */
-
-/* MMU Setting  */
-#define CONFIG_ENABLE_MMU
-
-#ifdef CONFIG_ENABLE_MMU
-#define virt_to_phys(x)	virt_to_phy_smdkc210(x)
-#else
-#define virt_to_phys(x)	(x)
-#endif
-
-#define CONFIG_MEMORY_UPPER_CODE
-
-#undef CONFIG_USE_IRQ				/* we don't need IRQ/FIQ stuff */
-
-#define CONFIG_INCLUDE_TEST
-
-#define CONFIG_ZIMAGE_BOOT
-#define CONFIG_IMAGE_BOOT
-
-#define BOARD_LATE_INIT
-
-#define CONFIG_SETUP_MEMORY_TAGS
-#define CONFIG_CMDLINE_TAG
-#define CONFIG_INITRD_TAG
-
-/*
- * Architecture magic and machine type
- */
-
-#define MACH_TYPE		2838//(S5PC210:2838, S5PV310:2925)
-#define UBOOT_MAGIC		(0x43090000 | MACH_TYPE)
-#define CHIP_ID_BASE            0x10000000
-#define PKG_ID_BASE		0x10000004
-
-/* Power Management is enabled */
-#define CONFIG_PM
-
-#define CONFIG_TA4
-
-//#define CONFIG_SD_UPDATE
-#define CONFIG_SD_AUTOUPDATE
-
-#ifdef CONFIG_SD_AUTOUPDATE
-#define CONFIG_SD_UPDATE
-#endif
-
-//@@Robin
-#ifndef CONFIG_TA4
-
-#ifdef CONFIG_CLK_800_300_150
-#define CONFIG_PM_11V   /* ARM 1.1v, INT 1.1v */
-#else   /* default or CONFIG_CLK_1000_400_200 */
-//#define CONFIG_PM_12V   /* ARM 1.2v, INT 1.2v */
-#define CONFIG_PM_13V_12V	/* ARM 1.3v, INT 1.2v */
-#endif
-//@@Robin
-#endif
-
-#define CONFIG_DISPLAY_CPUINFO
-#define CONFIG_DISPLAY_BOARDINFO
-
-#undef CONFIG_SKIP_RELOCATE_UBOOT
-#undef CONFIG_USE_NOR_BOOT
-
-/*
- * Size of malloc() pool
- */
-#define CONFIG_SYS_MALLOC_LEN		(CONFIG_ENV_SIZE + 1024*1024)
-#define CFG_GBL_DATA_SIZE	128	/* size in bytes reserved for initial data */
-
-#define CFG_STACK_SIZE		512*1024
-
-/*
- * select serial console configuration
- */
-#ifndef CONFIG_TA4
-#define CONFIG_SERIAL2          1	/* we use UART1 on SMDKC210 */
-#else
-#define CONFIG_SERIAL3          1	/* we use UART2 on TA4 */
-#endif
-//#define CONFIG_SERIAL4		1
-
-#define CFG_HUSH_PARSER			/* use "hush" command parser	*/
-#ifdef CFG_HUSH_PARSER
-#define CFG_PROMPT_HUSH_PS2	"> "
-#endif
-
-#define CONFIG_CMDLINE_EDITING
-
-#undef CONFIG_S3C64XX_I2C		/* this board has H/W I2C */
-#ifdef CONFIG_S3C64XX_I2C
-#define CONFIG_HARD_I2C		1
-#define CFG_I2C_SPEED		50000
-#define CFG_I2C_SLAVE		0xFE
-#endif
-
-#define CONFIG_DOS_PARTITION
-#define CONFIG_SUPPORT_VFAT
-
-#define CONFIG_USB_OHCI
-#undef CONFIG_USB_STORAGE
-#define CONFIG_S3C_USBD
-
-#define USBD_DOWN_ADDR		0xc0000000
-
-/************************************************************
- * RTC
- ************************************************************/
-/* allow to overwrite serial and ethaddr */
-#define CONFIG_ENV_OVERWRITE
-
-#define CONFIG_BAUDRATE		115200
-
-/***********************************************************
- * Command definition
- ***********************************************************/
-//#define CONFIG_CMD_CACHE
-//#define CONFIG_CMD_USB
-//#define CONFIG_CMD_REGINFO
-
-//#define	CONFIG_CMD_NAND
-//#define	CONFIG_CMD_FLASH
-
-//#define CONFIG_CMD_ONENAND
-#define CONFIG_CMD_MOVINAND
-
-//#define CONFIG_CMD_PING
-//#define CONFIG_CMD_DATE
-
-#include <config_cmd_default.h>
-
-#define CONFIG_CMD_ELF
-//#define CONFIG_CMD_I2C
-
-#define CONFIG_CMD_EXT2
-#define CONFIG_CMD_EXT4
-#define CONFIG_CMD_FAT
-
-#if defined(CONFIG_CMD_KGDB)
-#define CONFIG_KGDB_BAUDRATE	115200		/* speed to run kgdb serial port */
-/* what's this ? it's not used anywhere */
-#define CONFIG_KGDB_SER_INDEX	1		/* which serial port to use */
-#endif
-
-/*
- * Miscellaneous configurable options
- */
-#define CONFIG_SYS_LONGHELP                             /* undef to save memory         */
-#define CONFIG_SYS_PROMPT              "TC4 # "    /* Monitor Command Prompt       */
-
-#define CONFIG_SYS_CBSIZE		256		/* Console I/O Buffer Size	*/
-#define CONFIG_SYS_PBSIZE		384		/* Print Buffer Size */
-#define CONFIG_SYS_MAXARGS		16		/* max number of command args	*/
-#define CONFIG_SYS_BARGSIZE		CONFIG_SYS_CBSIZE	/* Boot Argument Buffer Size	*/
-
-#define CONFIG_SYS_MEMTEST_START	MEMORY_BASE_ADDRESS	/* memtest works on	*/
-
-#define CONFIG_SYS_MEMTEST_END		MEMORY_BASE_ADDRESS + 0x3E00000		/* 256 MB in DRAM	*/
-
-#undef CFG_CLKS_IN_HZ		/* everything, incl board info, in Hz */
-
-#define CONFIG_SYS_LOAD_ADDR		MEMORY_BASE_ADDRESS + 0x00100000	/* default load address	*/
-
-/* the PWM TImer 4 uses a counter of 41687 for 10 ms, so we need */
-/* it to wrap 100 times (total 4168750) to get 1 sec. */
-#define CONFIG_SYS_HZ			4168750		// at PCLK 66MHz
-
-/* valid baudrates */
-#define CONFIG_SYS_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
-
-/*-----------------------------------------------------------------------
- * Stack sizes
- *
- * The stack sizes are set up in start.S using the settings below
- */
-
-/* MIU Setting  */
-//#define CONFIG_MIU_1BIT_INTERLEAVED
-
-#define CONFIG_STACKSIZE	0x40000		/* regular stack 256KB */
-#ifdef CONFIG_USE_IRQ
-#define CONFIG_STACKSIZE_IRQ	(4*1024)	/* IRQ stack */
-#define CONFIG_STACKSIZE_FIQ	(4*1024)	/* FIQ stack */
-#endif
-
-// SMDKC210 POP-A(512MB)   : 2 banks
-// SMDKC210 POP-B(1024MB)  : 4 banks
-#define CONFIG_NR_DRAM_BANKS    8          	/* 8 banks of DRAM at maximum */
-#define SDRAM_BANK_SIZE         0x10000000	/* each bank has 256 MB */
-#define PHYS_SDRAM_1            (unsigned long)MEMORY_BASE_ADDRESS /* SDRAM Bank #1 */
-#define PHYS_SDRAM_1_SIZE       (unsigned long)SDRAM_BANK_SIZE
-#define PHYS_SDRAM_2            (unsigned long)(MEMORY_BASE_ADDRESS + SDRAM_BANK_SIZE) /* SDRAM Bank #2 */
-#define PHYS_SDRAM_2_SIZE       (unsigned long)SDRAM_BANK_SIZE
-#define PHYS_SDRAM_3            (unsigned long)(MEMORY_BASE_ADDRESS + 2 * SDRAM_BANK_SIZE) /* SDRAM Bank #2 */
-#define PHYS_SDRAM_3_SIZE       (unsigned long)SDRAM_BANK_SIZE
-#define PHYS_SDRAM_4            (unsigned long)(MEMORY_BASE_ADDRESS + 3 * SDRAM_BANK_SIZE) /* SDRAM Bank #2 */
-#define PHYS_SDRAM_4_SIZE       (unsigned long)SDRAM_BANK_SIZE
-#define PHYS_SDRAM_5            (unsigned long)(MEMORY_BASE_ADDRESS + 4 * SDRAM_BANK_SIZE) /* SDRAM Bank #2 */
-#define PHYS_SDRAM_5_SIZE       (unsigned long)SDRAM_BANK_SIZE
-#define PHYS_SDRAM_6            (unsigned long)(MEMORY_BASE_ADDRESS + 5 * SDRAM_BANK_SIZE) /* SDRAM Bank #2 */
-#define PHYS_SDRAM_6_SIZE       (unsigned long)SDRAM_BANK_SIZE
-#define PHYS_SDRAM_7            (unsigned long)(MEMORY_BASE_ADDRESS + 6 * SDRAM_BANK_SIZE) /* SDRAM Bank #2 */
-#define PHYS_SDRAM_7_SIZE       (unsigned long)SDRAM_BANK_SIZE
-#define PHYS_SDRAM_8            (unsigned long)(MEMORY_BASE_ADDRESS + 7 * SDRAM_BANK_SIZE) /* SDRAM Bank #2 */
-#define PHYS_SDRAM_8_SIZE       (unsigned long)SDRAM_BANK_SIZE
-
-
-
-
-#define CFG_FLASH_BASE		0x80000000
-
-/*-----------------------------------------------------------------------
- * FLASH and environment organization
- */
-#define CONFIG_MX_LV640EB		/* MX29LV640EB */
-//#define CONFIG_AMD_LV800		/* AM29LV800BB */
-
-#define CFG_MAX_FLASH_BANKS	1	/* max number of memory banks */
-
-#if	defined(CONFIG_MX_LV640EB)
-#define CFG_MAX_FLASH_SECT	135
-#define PHYS_FLASH_SIZE		0x800000	/* 8MB */
-#elif	defined(CONFIG_AMD_LV800)
-#define CFG_MAX_FLASH_SECT	19
-#define PHYS_FLASH_SIZE		0x100000	/* 1MB */
-#else
-#define CFG_MAX_FLASH_SECT	512
-#define PHYS_FLASH_SIZE		0x100000	/* 1MB */
-#endif
-
-#define CFG_FLASH_LEGACY_512Kx16
-//#define CONFIG_FLASH_CFI_LEGACY
-#define CFG_FLASH_CFI
-
-/* timeout values are in ticks */
-#define CFG_FLASH_ERASE_TOUT	(5*CFG_HZ) /* Timeout for Flash Erase */
-#define CFG_FLASH_WRITE_TOUT	(5*CFG_HZ) /* Timeout for Flash Write */
-
-#define CFG_ENV_ADDR		0
-#define CONFIG_ENV_SIZE		0x4000	/* Total Size of Environment Sector */
-
-/*
- * SMDKC210 board specific data
- */
-
-#define CONFIG_IDENT_STRING	" for TC4 Android"
-
-/* total memory required by uboot */
-#define CFG_UBOOT_SIZE		(2*1024*1024)
-
- /* base address for uboot */
-//#ifdef CONFIG_ENABLE_MMU
-//#define CFG_UBOOT_BASE		0xc3e00000
-//#else
-#define CFG_UBOOT_BASE		0x43e00000
-//#endif
-
-#define CFG_PHY_UBOOT_BASE	MEMORY_BASE_ADDRESS + 0x3e00000
-#define CFG_PHY_KERNEL_BASE	MEMORY_BASE_ADDRESS + 0x8000
-
-#define CONFIG_ENV_OFFSET	0x0007C000
-
-/* nand copy size from nand to DRAM.*/
-#define	COPY_BL2_SIZE		0x80000
-
-/* NAND configuration */
-#define CONFIG_SYS_MAX_NAND_DEVICE     1
-#define CONFIG_SYS_NAND_BASE           (0x0CE00000)
-#define NAND_MAX_CHIPS          1
-
-#define NAND_DISABLE_CE()	(NFCONT_REG |= (1 << 1))
-#define NAND_ENABLE_CE()	(NFCONT_REG &= ~(1 << 1))
-#define NF_TRANSRnB()		do { while(!(NFSTAT_REG & (1 << 0))); } while(0)
-
-#define CFG_NAND_SKIP_BAD_DOT_I	1  /* ".i" read skips bad blocks   */
-#define	CFG_NAND_WP		1
-#define CFG_NAND_YAFFS_WRITE	1  /* support yaffs write */
-
-#define CFG_NAND_HWECC
-#undef	CFG_NAND_FLASH_BBT
-
-/* IROM specific data */
-#define SDMMC_BLK_SIZE        (0xD003A500)
-#define COPY_SDMMC_TO_MEM     (0xD003E008)
-
-/*
- *  Fast Boot 
-*/
-/* Fastboot variables */
-#define CFG_FASTBOOT_TRANSFER_BUFFER            (0x50000000)
-#define CFG_FASTBOOT_TRANSFER_BUFFER_SIZE       (0x10000000)   /* 256MB */
-#define CFG_FASTBOOT_ADDR_KERNEL                (0x40008000)
-#define CFG_FASTBOOT_ADDR_RAMDISK               (0x40800000)
-#define CFG_FASTBOOT_PAGESIZE                   (2048)  // Page size of booting device
-#define CFG_FASTBOOT_SDMMC_BLOCKSIZE            (512)   // Block size of sdmmc
-
-/* Just one BSP type should be defined. */
-#if defined(CONFIG_CMD_ONENAND) | defined(CONFIG_CMD_NAND) | defined(CONFIG_CMD_MOVINAND)
-#define CONFIG_FASTBOOT
-#endif
-
-#if defined(CONFIG_CMD_NAND)
-#define CFG_FASTBOOT_NANDBSP
-#endif
-#if defined(CONFIG_CMD_ONENAND)
-#define CFG_FASTBOOT_ONENANDBSP
-#endif
-#if defined(CONFIG_CMD_MOVINAND)
-#define CFG_FASTBOOT_SDMMCBSP
-#endif
-
-#if defined(CONFIG_CMD_MOVINAND)
-/* SD/MMC configuration */
-#define CONFIG_MMC
-#define CONFIG_CMD_MMC
-#define CONFIG_GENERIC_MMC
- 
-
-#ifdef CONFIG_EVT1
-//Select one among 3 mode, default is CONFIG_SDMMC_CH2
-#define CONFIG_SDMMC_CH2 //SDMMC_CH2 (OMPIN[5:1] = 2
-//#define CONFIG_EMMC43_CH0 //eMMC43_CH0 (OMPIN[5:1] = 3)
-#define CONFIG_EMMC44_CH4 //eMMC44_CH4 (OMPIN[5:1] = 4)
-
-#ifdef CONFIG_SDMMC_CH2
-#define CONFIG_S3C_HSMMC
-#undef DEBUG_S3C_HSMMC
-#define USE_MMC2  
-#endif
-
-#ifdef CONFIG_EMMC44_CH4
-#define CONFIG_S5P_MSHC
-#define CONFIG_EMMC		1		
-#define USE_MMC4  
-//#define CONFIG_EMMC_8Bit
-#define CONFIG_EMMC_EMERGENCY
-#endif
-
-#endif //config_evt1
-
-#define MMC_MAX_CHANNEL                5
- 
-#endif
-
-#define CONFIG_FASTBOOT_SDFUSE 
-
-/*
- * SD/MMC detection takes a little long time
- * So, you can ignore detection process for SD/MMC card
- */
-#undef	CONFIG_NO_SDMMC_DETECTION
-
-#define CONFIG_MTDPARTITION	"80000 400000 3000000"
-#define CONFIG_BOOTDELAY	3
-
-//#if defined (CONFIG_CMD_MOVINAND)
-//#define CONFIG_BOOTCOMMAND      "movi read kernel 40008000;movi read rootfs 40800000 100000;bootm 40008000 40800000"
-//#else
-#define CONFIG_BOOTCOMMAND	"onenand read 40008000 600000 300000;onenand read 40800000 b00000 100000;bootm 40008000 40800000"//"movi read kernel c0008000;bootm c0008000"
-//#endif
-
-/* OneNAND configuration */
-#define CFG_ONENAND_BASE 	(0x0C000000)
-#define CFG_ONENANDXL_BASE      (0x0C600000)
-#define CFG_MAX_ONENAND_DEVICE	1
-#define CONFIG_SYS_ONENAND_BASE CFG_ONENAND_BASE
-   
-#define CONFIG_BOOT_ONENAND_IROM
-//#define CONFIG_NAND
-//#define CONFIG_BOOT_NAND
-#define CONFIG_ONENAND
-#define ONENAND_REG_DBS_DFS_WIDTH 	(0x160)
-#define ONENAND_REG_FLASH_AUX_CNTRL     (0x300)
-
-#define GPNCON_OFFSET		0x830
-#define GPNDAT_OFFSET		0x834
-#define GPNPUD_OFFSET		0x838
-
-#define CONFIG_ENV_IS_IN_AUTO
-//#define CONFIG_ENV_IS_IN_NAND
-
-
-#define CONFIG_4212_AP10_BOOTLOADER "u-boot-exynos4212-evt0-nonfused.bin"
-#define CONFIG_4212_AP11_BOOTLOADER "u-boot-exynos4212-evt1-efused.bin"
-#define CONFIG_4412_BOOTLOADER "u-boot-exynos4412-evt0-nonfused.bin"
-#define CONFIG_4412_DVT_BOOTLOADER "u-boot-exynos4412-evt1-efused.bin"
-
-#define CONFIG_RECOVERY
-#define FACTORY_RESET_MODE 	0xC1	
-#define CHARGING_RESET_MODE	0xC2 
-//#define RECOVERY_MODE 		0xC3
-
-/*-----LCD---------*/
-//#define CONFIG_LOGO_DISPLAY
-
-#ifdef CONFIG_LOGO_DISPLAY
-#define CFG_LCD_NONAME1
-#define CFG_LCD_FBUFFER				(0x4c000000)
-#define PART_SIZE_LOGO		(80*1024) // 80KB
-#define CFG_MAX_LOGO_NUM			6 // 6 pic to show
-#define LOGO_PARTITION_START (14*1024*1024) 
-
-#define BOOT_LOGO 		0  	
-#define BATTERY_LOGO 	1
-#define	RECOVERY_LOGO 	4  
-#define UPDATING_LOGO 	5
-
-#endif
-#define CONFIG_TRUSTZONE
-
-#define DEBUG_TC4
-#undef DEBUG_TC4
-#ifdef DEBUG_TC4
-
-#define emmcdbg(fmt,args...) printf(fmt ,##args) //for emmc dbg
-#define sddbg(fmt,args...) printf(fmt ,##args) //for emmc dbg
-#else
-#define emmcdbg(fmt,args...)
-#define sddbg(fmt,args...)
-#endif
-#endif	/* __CONFIG_H */
diff -urN TC4_uboot/include/movi.h iTop4412_uboot/include/movi.h
--- TC4_uboot/include/movi.h	2012-04-24 01:02:09.000000000 -0700
+++ iTop4412_uboot/include/movi.h	2015-11-09 00:59:36.000000000 -0800
@@ -14,8 +14,8 @@
 #define BL2_SIZE		(16 * 1024)//uboot BL1 16KB
 
 /* partition information */
-#define PART_SIZE_UBOOT		(480 * 1024)
-#define PART_SIZE_KERNEL	(4 * 1024 * 1024)
+#define PART_SIZE_UBOOT		(495 * 1024)
+#define PART_SIZE_KERNEL	(6 * 1024 * 1024)	//modify by cym 20140217
 
 #define PART_SIZE_ROOTFS	(2 * 1024 * 1024)//  2M
 #define RAW_AREA_SIZE		(16 * 1024 * 1024)// 16MB
diff -urN TC4_uboot/lib_arm/board.c iTop4412_uboot/lib_arm/board.c
--- TC4_uboot/lib_arm/board.c	2012-06-07 01:50:17.000000000 -0700
+++ iTop4412_uboot/lib_arm/board.c	2015-11-09 00:59:36.000000000 -0800
@@ -73,7 +73,6 @@
 DECLARE_GLOBAL_DATA_PTR;
 
 ulong monitor_flash_len;
-unsigned int key1_pulldown, key2_pulldown, power_mode;
 
 #ifdef CONFIG_HAS_DATAFLASH
 extern int  AT91F_DataflashInit(void);
@@ -142,30 +141,13 @@
 
 	return (0);
 }
-//Robin Wang: 2011-06-02,add for device power off
-//The charger will implement later....
-static void phone_off(void)
-{
-	int value;
-	value = readl(S5P_PS_HOLD_CONTROL);
-	value = 0x5200;// shutdown
-	writel(value, S5P_PS_HOLD_CONTROL);
-	while(1);//wait for power off to be done
-}
 
 static int off_charge(void)
 {
 	volatile int value = 0;
-	int dok, uok,cok, ONKEY_DET;
 	int i,j;
 	int val;
-#if 0
-	int charge_finish = 0;
-	uint64_t btime,etime;
-	int light = 0;
-#endif
 
-	printf("\n\n\n");
 	/*---only evt use this---*/
 	val = readl(GPX2PUD);
 	val &= ~(0x3<<12); //dok,pullup/down disable
@@ -203,208 +185,7 @@
 	val = readl(GPX0PUD);
 	val &= ~(0x3<<4); //on_key,pullup/down disable
 	writel(val,GPX0PUD);
-
-	udelay(100000);
-	
-	value = readl(GPX1DAT);
-	uok = !!(value & (0x01<<5));
-	
-	value = readl(GPX2DAT);
-	dok = !!(value & (0x01<<6));
 	
-	value = readl(GPX2DAT);
-	cok = (value>>7)&0x1 ;
-	
-	printf("uok:%d, dok:%d, cok:%d\n",uok,dok,cok);
-	
-
-	
-
-	#if 1
-	if(cok)
-	#else
-	if(dok && uok)// no charger
-	#endif
-	{
-		printf("Power Mode:[Battery]\n");
-		power_mode = 0;
-		// ADC for Battery
-		j = 0;
-		do
-		{
-			writel(0xff, TSDLY0);
-			writel(0, ADCMUX);// Channel 0
-			writel((0x1<<16 | 0x1<<14 | 49<<6 | 0x1<<0), TSADCCON0);// Start
-			i = 0;
-			do
-			{
-				value = (readl(TSADCCON0) >> 15) & 0x1;// Conversion end
-				if(value == 1)
-				{
-                    value = readl(GPX2DAT);
-				    key1_pulldown =((value & 0x1) == 0x1);
-				    key2_pulldown =((value & 0x2) == 0x2);
-					//keyon_pulldown = 0;
-					writel((0x1<<16 | 0x1<<14 | 0xff<<6), TSADCCON0);// Stop
-					value = readl(TSDATX0) & 0x0fff;
-					j = 10;
-					printf("Battery ADC:%d\n",value);
-					break;
-				}
-				if(i++ > 100)
-					break;
-			} while(1);
-			if(j++ >= 3)// Retry 3 times
-				break;
-			udelay(1000000);
-		} while(1);
-
-/*	zhangdong 1103 power down under ultra low power 	
-		if(value>0 && value<=2090)// battery voltage < 3.4V
-		{
-			printf("voltage < 3.4V, power off\n");
-			phone_off();
-		}
-*/
-		if((value>0) && (value<=2890))// battery voltage < 3.5V 
-		{
-			printf("voltage < 3.5V, power off\n");
-			phone_off();
-		}
-		else
-		{
-		   //writel(0x0,0xE1A00004);
-			//return 0;
-		}
-	}
-	else //if(0 == dok || 0 == uok)// charger
-	{
-		printf("Power Mode:[Charging]\n");
-		#if 0
-		if(0 == dok && 0 == uok)
-			printf("Power Mode:[AC+USB]\n");
-		else if(0 == dok )
-			printf("Power Mode:[AC]\n");
-		else if (0 == uok)
-			printf("Power Mode:[USB]\n");
-		#endif
-
-		power_mode = 1; //charing mode
-#if 0
-	#ifdef TC4_PLUS
-	     // printf("It's TC4 plus, Do Not Need ON_KEY.");
-		 // keyon_pulldown = 1; //key on is prssed down
-	#else
-		//printf("off-charging...\n");
-		//printf("press ON_KEY to bootup, plug out the charger to shutdown\n");
-	
-		do {
-			//udelay(1000000);// delay 1s
-
-			value = readl(GPX1DAT);
-			uok = !!(value & (0x01<<5));
-			value = readl(GPX2DAT);
-			dok = !!(value & (0x01<<6));
-
-			if(dok && uok)
-			{
-				printf("charger plug out\n");
-				phone_off();
-			}
-
-			value = readl(GPX0DAT);
-			ONKEY_DET = !!(value & (0x01<<2));
-			if(0 == ONKEY_DET)
-			{
-				value = readl(GPX2DAT);
-				key1_pulldown =((value & 0x1) == 0x1);
-				key2_pulldown =((value & 0x2) == 0x2);
-				//keyon_pulldown = 1; //key on is prssed down
-				printf("ONKEY_DET!\n");
-				break;
-			}
-		} while (1);
-	#endif
-#endif
-	}
-	return 0;
-}
-
-static int smm6260_gpio_init(void)
-{
-	int val;
-/*
-power on modem bofore booting
-#define HSIC_HOST_ACTIVE	EXYNOS4_GPC0(3)
-#define HSIC_SLAVE_WAKEUP	EXYNOS4_GPC0(4)
-#define HSIC_HOST_WAKEUP	EXYNOS4_GPX2(5)
-#define HSIC_HOST_SUSREQ	EXYNOS4_GPX1(6)
-#define GPIO_MD_PWON    EXYNOS4_GPC0 (0)
-#define GPIO_MD_RSTN    EXYNOS4_GPC0(2)
-#define GPIO_MD_RESETBB EXYNOS4_GPL2(1)
-
-*/
-//poweron low: GPC0 (0)
-	val = readl(GPC0CON);
-	val &= ~(0xf<<0); 
-	val |= (0x1<<0); 
-	writel(val,GPC0CON);
-
-	val = readl(GPC0DAT);
-	val &= ~(0x1<<0); 
-	writel(val,GPC0DAT);
-	udelay(50000);
-
-//resetBB low:  GPL2(1)
-	val = readl(GPL2CON);
-	val &= ~(0xf<<4); 
-	val |= (0x1<<4); 
-	writel(val,GPL2CON);
-
-	val = readl(GPL2DAT);
-	val &= ~(0x1<<1); 
-	writel(val,GPL2DAT);
-	udelay(1000);
-
-//rstn low:  GPC0(2)
-	val = readl(GPC0CON);
-	val &= ~(0xf<<8); 
-	val |= (0x1<<8); 
-	writel(val,GPC0CON);
-
-	val = readl(GPC0DAT);
-	val &= ~(0x1<<2); 
-	writel(val,GPC0DAT);
-	udelay(50000);
-
-//host_active low: gpc03
-	val = readl(GPC0CON);
-	val &= ~(0xf<<12); 
-	val |= (0x1<<12); 
-	writel(val,GPC0CON);
-
-	val = readl(GPC0DAT);
-	val &= ~(0x1<<3); 
-	writel(val,GPC0DAT);
-	udelay(50000);
-#if 0
-//resetBB high:  GPL2(1)
-	val = readl(GPL2DAT);
-	val |= (0x1<<1); 
-	writel(val,GPL2DAT);
-	udelay(1000);
-
-//rstn high:  GPC0(2)
-	val = readl(GPC0DAT);
-	val |= (0x1<<2); 
-	writel(val,GPC0DAT);
-	udelay(50000);
-
-//poweron high: GPC0 (0)
-	val = readl(GPC0DAT);
-	val |= (0x1<<0); 
-	writel(val,GPC0DAT);
-#endif
 	return 0;
 }
 
@@ -448,9 +229,20 @@
 	for (i=0; i<CONFIG_NR_DRAM_BANKS; i++) {
 		size += gd->bd->bi_dram[i].size;
 	}
-	puts("DRAM:	");
+
+#if  defined(CONFIG_SCP_1GDDR) ||  defined(CONFIG_SCP_2GDDR) || defined(CONFIG_SCP_1GDDR_Ubuntu) || defined(CONFIG_SCP_2GDDR_Ubuntu)  //add by dg
+
+	size += 0x100000;
+#endif
+
+#if defined(CONFIG_POP_2GDDR) || defined(CONFIG_POP_2GDDR_Ubuntu) 
+	puts("DRAM: ");
+    puts("2G\n");
+#else
+  	puts("DRAM:	");
 	print_size(size, "\n");
 #endif
+#endif
 
 	return (0);
 }
@@ -526,9 +318,7 @@
 	serial_init,		/* serial communications setup */
 	console_init_f,		/* stage 1 init of console */
 	off_charge,		// xiebin.wang @ 20110531,for charger&power off device.
-//#ifndef TC4_PLUS
-	//smm6260_gpio_init,	// liang
-//#endif
+
 	display_banner,		/* say that we are here */
 #if defined(CONFIG_DISPLAY_CPUINFO)
 	print_cpuinfo,		/* display cpu info (and speed) */
@@ -547,30 +337,6 @@
 	NULL,
 };
 
-void key_detect(void)
-{
-	int value = 0;
-
-	if(!power_mode)
-		return;
-		
-	//udelay(1000000);// delay 1s
-	value = __REG(GPX0DAT);
-	printf("GPX0:%x\n",value);	
-	if((value>>2) &0x1)
-	{
-	
-			printf("key_on is up.%x.\n",value);	
-			power_mode = 2; //short push
-			
-	}
-	else
-	{	
-		printf("Power on key down.%x.\n",value);	
-		power_mode = 3; //long push
-	}
-
-}
 void start_armboot (void)
 {
 	init_fnc_t **init_fnc_ptr;
@@ -598,11 +364,6 @@
 			hang ();
 		}
 	}
-	#ifdef CONFIG_LOGO_DISPLAY
-	Exynos_LCD_turnon();
-	key_detect();
-	#endif
-
 	
 	/* armboot_start is defined in the board-specific linker script */
 	mem_malloc_init (_armboot_start - CONFIG_SYS_MALLOC_LEN,
Binary files TC4_uboot/lib_arm/stM5USnZ and iTop4412_uboot/lib_arm/stM5USnZ differ
Binary files TC4_uboot/logo_resource.bin and iTop4412_uboot/logo_resource.bin differ
diff -urN TC4_uboot/Makefile iTop4412_uboot/Makefile
--- TC4_uboot/Makefile	2012-04-24 01:02:09.000000000 -0700
+++ iTop4412_uboot/Makefile	2015-11-09 00:59:35.000000000 -0800
@@ -350,18 +350,6 @@
 		@./sdfuse_q/add_padding
 		@rm bl2a*
 		
-		##For Dual-core, non-secure boot
-		
-		@cat E4212 checksum_bl2_14k.bin all00_padding.bin u-boot.bin > u-boot-exynos4212-evt0-nonfused.bin
-		
-		##For Quad-core, non-secure boot
-		
-		@cat E4412_N.bl1.bin checksum_bl2_14k.bin all00_padding.bin u-boot.bin > u-boot-exynos4412-evt0-nonfused.bin
-		@echo u-boot-exynos4212-evt0-nonfused.bin generated for dual core non secure boot,use this one to fuse exyons 4212.
-		@echo Please use sd_fusing.sh in sdfuse directory with su permission for programming the u-boot to SD card. Ex: ./sd_fusing.sh /dev/sdd
-		@echo
-		@echo u-boot-exynos4412-evt0-nonfused.bin generated for Quad core non secure boot,use this one to fuse exyons 4412 evt0.
-		@echo Please use sd_fusing.sh in sdfuse_q directory with su permission for programming the u-boot to SD card. Ex: ./sd_fusing.sh /dev/sdd
 		@echo
 
 $(obj)u-boot.ldr:	$(obj)u-boot
@@ -3251,12 +3239,29 @@
 smdkc210_android_config:	unconfig
 	@$(MKCONFIG) $(@:_config=) arm arm_cortexa9 smdkc210 samsung s5pc210
 
-tc4_android_config:	unconfig
-	@$(MKCONFIG) $(@:_config=) arm arm_cortexa9 smdkc210 samsung s5pc210
+#add by dg 2015-08-04 for android ,linux 
+itop_4412_android_config_scp_1GDDR:		unconfig
+	@$(MKCONFIG) $(@:_config=) arm arm_cortexa9 smdkc210 samsung s5pc210 SCP_1GDDR
+itop_4412_android_config_scp_2GDDR:		unconfig
+	@$(MKCONFIG) $(@:_config=) arm arm_cortexa9 smdkc210 samsung s5pc210 SCP_2GDDR
+itop_4412_android_config_pop_1GDDR:		unconfig
+	@$(MKCONFIG) $(@:_config=) arm arm_cortexa9 smdkc210 samsung s5pc210 POP_1GDDR
+itop_4412_android_config_pop_2GDDR:		unconfig
+	@$(MKCONFIG) $(@:_config=) arm arm_cortexa9 smdkc210 samsung s5pc210 POP_2GDDR
+
+#add by cym 20131206,change by dg 2015-08-04 for ubuntu
+itop_4412_ubuntu_config_scp_1GDDR:	unconfig
+	@$(MKCONFIG) $(@:_config=) arm arm_cortexa9 smdkc210 samsung s5pc210 SCP_1GDDR_Ubuntu
+itop_4412_ubuntu_config_scp_2GDDR:	unconfig
+	@$(MKCONFIG) $(@:_config=) arm arm_cortexa9 smdkc210 samsung s5pc210 SCP_2GDDR_Ubuntu
+itop_4412_ubuntu_config_pop_1GDDR:	unconfig
+	@$(MKCONFIG) $(@:_config=) arm arm_cortexa9 smdkc210 samsung s5pc210 POP_1GDDR_Ubuntu
+
+#Ubuntu on POP2G DDR,use POP1G DDR Version.
+itop_4412_ubuntu_config_pop_2GDDR:	unconfig
+	@$(MKCONFIG) $(@:_config=) arm arm_cortexa9 smdkc210 samsung s5pc210 POP_1GDDR_Ubuntu
+#end add
 
-tc4_plus_android_config:	unconfig
-	@$(MKCONFIG) $(@:_config=) arm arm_cortexa9 smdkc210 samsung s5pc210
-	
 smdkv310_android_config:	unconfig
 	@$(MKCONFIG) $(@:_config=) arm arm_cortexa9 smdkc210 samsung s5pc210
 #########################################################################
Binary files TC4_uboot/mkbl2 and iTop4412_uboot/mkbl2 differ
diff -urN TC4_uboot/mkconfig iTop4412_uboot/mkconfig
--- TC4_uboot/mkconfig	2012-04-24 01:02:09.000000000 -0700
+++ iTop4412_uboot/mkconfig	2015-11-09 00:59:36.000000000 -0800
@@ -9,14 +9,29 @@
 #
 
 APPEND=no	# Default: Create new config file
-BOARD_NAME=""	# Name to print in make output
+#BOARD_NAME=""	# Name to print in make output
 TARGETS=""
 
+echo "CoreBoard  is $7...... "
+
+if   [ "$7" = "SCP_1GDDR" ]  ||   [ "$7" = "SCP_2GDDR" ] || [ "$7" = "POP_1GDDR" ]  ||   [ "$7" = "POP_2GDDR" ]
+then 
+      BOARD_NAME="itop_4412_android"
+      echo "CoreBoard OS is android or linux...... "
+
+elif [ "$7" = "SCP_1GDDR_Ubuntu" ]  ||  [ "$7" = "SCP_2GDDR_Ubuntu" ] || [ "$7" = "POP_1GDDR_Ubuntu" ] ||  [ "$7" = "POP_2GDDR_Ubuntu" ]
+then
+      BOARD_NAME="itop_4412_ubuntu"
+      echo "CoreBoard OS is Ubuntu...... "
+else
+      echo "unknown coreboard type and os type......"
+fi
+	
 while [ $# -gt 0 ] ; do
 	case "$1" in
 	--) shift ; break ;;
 	-a) shift ; APPEND=yes ;;
-	-n) shift ; BOARD_NAME="${1%%_config}" ; shift ;;
+#	-n) shift ; BOARD_NAME="${1%%_config}" ; shift ;;
 	-t) shift ; TARGETS="`echo $1 | sed 's:_: :g'` ${TARGETS}" ; shift ;;
 	*)  break ;;
 	esac
@@ -25,7 +40,7 @@
 [ "${BOARD_NAME}" ] || BOARD_NAME="$1"
 
 [ $# -lt 4 ] && exit 1
-[ $# -gt 6 ] && exit 1
+[ $# -gt 7 ] && exit 1
 
 if [ "${ARCH}" -a "${ARCH}" != "$2" ]; then
 	echo "Failed: \$ARCH=${ARCH}, should be '$2' for ${BOARD_NAME}" 1>&2
@@ -86,6 +101,26 @@
     BOARDDIR=$5/$4
 fi
 
+
+
+#add by dg for kinds of coreboard
+if   [ "$7" = "SCP_1GDDR" ] ||   [ "$7" = "SCP_2GDDR" ] || [ "$7" = "SCP_1GDDR_Ubuntu" ] ||   [ "$7" = "SCP_2GDDR_Ubuntu" ]
+then 
+     echo "CORE   =  SCP" >> config.mk
+     ln -sf ${SRCTREE}/board/samsung/smdkc210/lowlevel_init_SCP.S  ${SRCTREE}/board/samsung/smdkc210/lowlevel_init.S	
+     ln -sf ${SRCTREE}/cpu/arm_cortexa9/s5pc210/cpu_init_SCP.S     ${SRCTREE}/cpu/arm_cortexa9/s5pc210/cpu_init.S
+
+elif [ "$7" = "POP_1GDDR" ]  ||  [ "$7" = "POP_2GDDR" ] || [ "$7" = "POP_1GDDR_Ubuntu" ] ||  [ "$7" = "POP_2GDDR_Ubuntu" ]
+then
+     echo "CORE   =  POP" >>  config.mk
+     ln -sf ${SRCTREE}/board/samsung/smdkc210/lowlevel_init_POP.S  ${SRCTREE}/board/samsung/smdkc210/lowlevel_init.S	
+     ln -sf ${SRCTREE}/cpu/arm_cortexa9/s5pc210/cpu_init_POP.S     ${SRCTREE}/cpu/arm_cortexa9/s5pc210/cpu_init.S
+else
+      echo "make config error,please use correct params......"
+      exit 0
+fi
+
+
 #
 # Create board specific header file
 #
@@ -101,10 +136,14 @@
 	echo "#define CONFIG_MK_${i} 1" >>config.h ;
 done
 
+#add by dg for all itop4412 type boards
+
+[ "$7" ] && [ "$7" != "NULL" ] && echo "#define CONFIG_$7" >> config.h
+
 cat << EOF >> config.h
 #define CONFIG_BOARDDIR board/$BOARDDIR
 #include <config_defaults.h>
-#include <configs/$1.h>
+#include <configs/$BOARD_NAME.h>
 #include <asm/config.h>
 EOF
 
diff -urN TC4_uboot/mkuboot iTop4412_uboot/mkuboot
--- TC4_uboot/mkuboot	2012-05-17 00:45:15.000000000 -0700
+++ iTop4412_uboot/mkuboot	2015-11-09 00:59:36.000000000 -0800
@@ -1,84 +1,20 @@
 
 #!/bin/bash
 
-# jun.ma@samsung.com
+#
 # This script will create a u-boot binary for movinand/mmc boot
 #
 
-option1="4212"
-option2="4212s"
-option3="4212tz"
-option4="4412"
-option5="4412s"
-option6="4412tz"
-
 chmod 777 sdfuse_q -R
-if [ -z $1 ]
-then
-		split -b 14336 u-boot.bin bl2
-		make -C sdfuse_q/
-		#cp u-boot.bin u-boot-4212.bin
-		#cp u-boot.bin u-boot-4412.bin
-		#./sdfuse_q/add_sign
-		./sdfuse_q/chksum
-		
-		##For Dual-core, non-secure boot
-		
-		cat E4212 checksum_bl2_14k.bin all00_padding.bin u-boot.bin > u-boot-exynos4212-evt0-nonfused.bin
 		
-		##For Quad-core, non-secure boot
-		
-		cat E4412_N.bl1.bin checksum_bl2_14k.bin all00_padding.bin u-boot.bin > u-boot-exynos4412-evt0-nonfused.bin
-		echo u-boot-exynos4212-evt0-nonfused.bin generated for dual core non secure boot,use this one to fuse exyons 4212.
-		echo Please use sd_fusing.sh in sdfuse directory with su permission for programming the u-boot to SD card. Ex: ./sd_fusing.sh /dev/sdd
-		echo
-		echo u-boot-exynos4412-evt0-nonfused.bin generated for Quad core non secure boot,use this one to fuse exyons 4412 evt0.
-		echo Please use sd_fusing.sh in sdfuse_q directory with su permission for programming the u-boot to SD card. Ex: ./sd_fusing.sh /dev/sdd
-		echo
+echo "Fuse iTOP-4412 trustzone uboot file into SD card"
+cd ./sdfuse_q
 
-		rm bl2a*
-		#rm checksum_bl2*
-		
-elif [ $1 = $option1 ]
-then 
-	echo "Fuse 4212 non-secure uboot file into SD card"
-	cd ./sdfuse_q
-	./sd_fusing_exynos4x12.sh $2 u-boot-exynos4212-evt0-nonfused.bin
-	cd ..
-elif [ $1 = $option2 ]
-then 
-	echo "Fuse 4212 secure uboot file into SD card"
-	cd ./sdfuse_q
-	./sd_fusing_exynos4x12.sh $2 u-boot-exynos4212-evt1-efused.bin
-	cd ..
-elif [ $1 = $option3 ]
-then 
-	echo "Fuse 4212 trustzone uboot file into SD card"
-	cd ./sdfuse_q
-	./sd_fusing_exynos4x12.sh $2 u-boot-exynos4212-evt1-efused-tz.bin
-	cd ..
-elif [ $1 = $option4 ]
-then 
-	echo "Fuse 4412 non-secure uboot file into SD card"
-	cd ./sdfuse_q
-	./sd_fusing_exynos4x12.sh $2 u-boot-exynos4412-evt0-nonfused.bin
-	cd ..
-elif [ $1 = $option5 ]
-then 
-	echo "Fuse 4412 secure uboot file into SD card"
-	cd ./sdfuse_q
-	./sd_fusing_exynos4x12.sh $2 u-boot-exynos4412-evt1-efused.bin 
-	cd ..
-elif [ $1 = $option6 ]
-then 
-	echo "Fuse 4412 trustzone uboot file into SD card"
-	cd ./sdfuse_q
-	./sd_fusing_exynos4x12.sh $2 u-boot-exynos4412-evt1-efused-tz.bin
-	cd ..
+if [ -z $1 ]
+then
+	./sd_fusing_exynos4x12.sh /dev/sdb u-boot-iTOP-4412.bin
 else
-	echo ">>>Usage: please refer the manual:"
-    	exit 0
+	./sd_fusing_exynos4x12.sh $1 u-boot-iTOP-4412.bin
 fi
 
-
-
+cd ..
Binary files TC4_uboot/sdfuse_q/add_padding and iTop4412_uboot/sdfuse_q/add_padding differ
Binary files TC4_uboot/sdfuse_q/add_sign and iTop4412_uboot/sdfuse_q/add_sign differ
Binary files TC4_uboot/sdfuse_q/chksum and iTop4412_uboot/sdfuse_q/chksum differ
diff -urN TC4_uboot/uboot_readme.txt iTop4412_uboot/uboot_readme.txt
--- TC4_uboot/uboot_readme.txt	2012-06-07 01:50:17.000000000 -0700
+++ iTop4412_uboot/uboot_readme.txt	2015-11-09 00:59:36.000000000 -0800
@@ -1,3 +1,12 @@
+2015-08-12
+1 Merge POP 2G DDR Uboot version to Main Version
+2 Build Method: ./build_uboot.sh POP_2GDDR  for linux&Android OS,  ./build_uboot.sh POP_2GDDR_Ubuntu for Ubuntu12.04 ARM Version.
+
+2015-08-05:DiGuang
+1 Merge kinds of uboot version to only one 
+2 use new build : ./build_uboot.sh  XXX_YYY_ZZZ .  XXX is SCP or POP,YYY is 1GDDR or 2GDDR,ZZZ is Ubuntu or none(linux and android)
+
+
 2012-6-6: Zhang Dong
         1): Modify phone_off to wait for power off to de done
         Modified files:
