diff -urN u-boot-2017.11/arch/arm/dts/exynos4412-itop4412.dts u-boot-2017.11-itop4412/arch/arm/dts/exynos4412-itop4412.dts
--- u-boot-2017.11/arch/arm/dts/exynos4412-itop4412.dts	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-2017.11-itop4412/arch/arm/dts/exynos4412-itop4412.dts	2019-02-16 09:21:17.000000000 +0800
@@ -0,0 +1,86 @@
+/*
+ * TOPEET's Exynos4412 based itop board device tree source
+ *
+ * Copyright (c) 2018 Samsung Electronics Co., Ltd.
+ *		http://www.samsung.com
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+/dts-v1/;
+#include "exynos4412.dtsi"
+
+/ {
+	model = "TOPEET iTop 4412 Elite board based on Exynos4412";
+	compatible = "topeet,itop4412-elite", "samsung,exynos4412";
+
+	aliases {
+		i2c0 = "/i2c@13860000";
+		i2c1 = "/i2c@13870000";
+		i2c2 = "/i2c@13880000";
+		i2c3 = "/i2c@13890000";
+		i2c4 = "/i2c@138a0000";
+		i2c5 = "/i2c@138b0000";
+		i2c6 = "/i2c@138c0000";
+		i2c7 = "/i2c@138d0000";
+		serial0 = "/serial@13820000";
+		console = "/serial@13820000";
+		mmc0 = &mshc_0;
+		mmc1 = &sdhci2;
+	};
+
+	chosen {
+		stdout-path = "serial2:115200n8";
+	};
+
+	memory@40000000 {
+		device_type = "memory";
+		reg = <0x40000000 0x40000000>;
+	};
+
+	serial@13820000 {
+		status = "okay";
+	};
+
+	ehci@12580000 {
+		compatible = "samsung,exynos-ehci";
+		reg = <0x12580000 0x100>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+		status = "okay";
+		/* In order to reset USB ethernet */
+		samsung,vbus-gpio = <&gpc0 1 0>;
+		phy {
+			compatible = "samsung,exynos-usb-phy";
+			reg = <0x125B0000 0x100>;
+		};
+	};
+
+	emmc-reset {
+		compatible = "samsung,emmc-reset";
+		reset-gpio = <&gpk1 2 0>;
+	};
+
+/*
+	usb-phy-reset {
+		compatible = "smsc,usb-phy-reset";
+		reset-gpio = <&gpm2 4 GPIO_ACTIVE_LOW>;
+	};*/
+};
+
+&sdhci2 {
+	samsung,bus-width = <4>;
+	/* cd-gpios = <&gpx0 7 0>; */
+	cd-gpios = <&gpk2 2 0>;
+	status = "okay";
+};
+
+&mshc_0 {
+	samsung,bus-width = <4>;
+	samsung,timing = <2 1 0>;
+	fifoth_val = <0x203f0040>;
+	bus_hz = <400000000>;
+	div = <0x3>;
+	index = <4>;
+	status = "okay";
+};
diff -urN u-boot-2017.11/board/samsung/itop4412/itop4412.c u-boot-2017.11-itop4412/board/samsung/itop4412/itop4412.c
--- u-boot-2017.11/board/samsung/itop4412/itop4412.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-2017.11-itop4412/board/samsung/itop4412/itop4412.c	2019-02-16 09:21:42.000000000 +0800
@@ -0,0 +1,53 @@
+/*
+ * Copyright (C) 2011 Samsung Electronics
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/gpio.h>
+#include <asm/arch/cpu.h>
+#include <asm/arch/mmc.h>
+#include <asm/arch/periph.h>
+#include <asm/arch/pinmux.h>
+#include <usb.h>
+#include <usb/dwc2_udc.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+u32 get_board_rev(void)
+{
+	return 0;
+}
+
+int exynos_init(void)
+{
+	return 0;
+}
+
+static int s5pc210_phy_control(int on)
+{
+	return 0;
+}
+
+struct dwc2_plat_otg_data s5pc210_otg_data = {
+	.phy_control	= s5pc210_phy_control,
+	.regs_phy	= EXYNOS4X12_USBPHY_BASE,
+	.regs_otg	= EXYNOS4X12_USBOTG_BASE,
+	.usb_phy_ctrl	= EXYNOS4X12_USBPHY_CONTROL,
+	.usb_flags	= PHY0_SLEEP,
+};
+
+int board_usb_init(int index, enum usb_init_type init)
+{
+	debug("USB_udc_probe\n");
+	return dwc2_udc_probe(&s5pc210_otg_data);
+}
+
+#ifdef CONFIG_BOARD_EARLY_INIT_F
+int exynos_early_init_f(void)
+{
+	return 0;
+}
+#endif
diff -urN u-boot-2017.11/board/samsung/itop4412/Kconfig u-boot-2017.11-itop4412/board/samsung/itop4412/Kconfig
--- u-boot-2017.11/board/samsung/itop4412/Kconfig	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-2017.11-itop4412/board/samsung/itop4412/Kconfig	2019-02-16 09:21:42.000000000 +0800
@@ -0,0 +1,12 @@
+if TARGET_ITOP4412
+
+config SYS_BOARD
+	default "itop4412"
+
+config SYS_VENDOR
+	default "samsung"
+
+config SYS_CONFIG_NAME
+	default "itop4412"
+
+endif
diff -urN u-boot-2017.11/board/samsung/itop4412/MAINTAINERS u-boot-2017.11-itop4412/board/samsung/itop4412/MAINTAINERS
--- u-boot-2017.11/board/samsung/itop4412/MAINTAINERS	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-2017.11-itop4412/board/samsung/itop4412/MAINTAINERS	2019-02-16 09:21:42.000000000 +0800
@@ -0,0 +1,6 @@
+ITOP4412 BOARD
+M:	Chander Kashyap <k.chander@samsung.com>
+S:	Maintained
+F:	board/samsung/itop4412/
+F:	include/configs/itop4412.h
+F:	configs/itop4412_defconfig
diff -urN u-boot-2017.11/board/samsung/itop4412/Makefile u-boot-2017.11-itop4412/board/samsung/itop4412/Makefile
--- u-boot-2017.11/board/samsung/itop4412/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-2017.11-itop4412/board/samsung/itop4412/Makefile	2019-02-16 09:21:42.000000000 +0800
@@ -0,0 +1,22 @@
+#
+# Copyright (C) 2011 Samsung Electronics
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+ifdef CONFIG_SPL_BUILD
+# necessary to create built-in.o
+obj- := __dummy__.o
+
+hostprogs-y := tools/mkitop4412spl
+always := $(hostprogs-y)
+
+# omit -O2 option to suppress
+#   warning: dereferencing type-punned pointer will break strict-aliasing rules
+#
+# TODO:
+# Fix the root cause in tools/mkitop4412spl.c and delete the following work-around
+$(obj)/tools/mkitop4412spl: HOSTCFLAGS:=$(filter-out -O2,$(HOSTCFLAGS))
+else
+obj-y	+= itop4412.o
+endif
diff -urN u-boot-2017.11/board/samsung/itop4412/tools/mkitop4412spl.c u-boot-2017.11-itop4412/board/samsung/itop4412/tools/mkitop4412spl.c
--- u-boot-2017.11/board/samsung/itop4412/tools/mkitop4412spl.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-2017.11-itop4412/board/samsung/itop4412/tools/mkitop4412spl.c	2019-02-16 09:21:42.000000000 +0800
@@ -0,0 +1,117 @@
+/*
+ * Copyright (C) 2011 Samsung Electronics
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <string.h>
+#include <sys/stat.h>
+
+#define BUFSIZE			(16*1024)
+#define IMG_SIZE		(14*1024) //16*1024
+#define SPL_HEADER_SIZE		0 //16
+#define FILE_PERM		(S_IRUSR | S_IWUSR | S_IRGRP \
+				| S_IWGRP | S_IROTH | S_IWOTH)
+#define SPL_HEADER		"S5PC210 HEADER  "
+/*
+* Requirement:
+* IROM code reads first 14K bytes from boot device.
+* It then calculates the checksum of 14K-4 bytes and compare with data at
+* 14K-4 offset.
+*
+* This function takes two filenames:
+* IN  "u-boot-spl.bin" and
+* OUT "$(BOARD)-spl.bin as filenames.
+* It reads the "u-boot-spl.bin" in 16K buffer.
+* It calculates checksum of 14K-4 Bytes and stores at 14K-4 offset in buffer.
+* It writes the buffer to "$(BOARD)-spl.bin" file.
+*/
+
+int main(int argc, char **argv)
+{
+	int i, len;
+	unsigned char buffer[BUFSIZE] = {0};
+	int ifd, ofd;
+	unsigned int checksum = 0, count;
+
+	if (argc != 3) {
+		printf(" %d Wrong number of arguments\n", argc);
+		exit(EXIT_FAILURE);
+	}
+
+	ifd = open(argv[1], O_RDONLY);
+	if (ifd < 0) {
+		fprintf(stderr, "%s: Can't open %s: %s\n",
+			argv[0], argv[1], strerror(errno));
+		exit(EXIT_FAILURE);
+	}
+
+	ofd = open(argv[2], O_WRONLY | O_CREAT | O_TRUNC, FILE_PERM);
+	if (ofd < 0) {
+		fprintf(stderr, "%s: Can't open %s: %s\n",
+			argv[0], argv[2], strerror(errno));
+		if (ifd)
+			close(ifd);
+		exit(EXIT_FAILURE);
+	}
+
+	len = lseek(ifd, 0, SEEK_END);
+	lseek(ifd, 0, SEEK_SET);
+
+	memcpy(&buffer[0], SPL_HEADER, SPL_HEADER_SIZE);
+
+	count = (len < (IMG_SIZE - SPL_HEADER_SIZE))
+		? len : (IMG_SIZE - SPL_HEADER_SIZE);
+
+	if (read(ifd, buffer + SPL_HEADER_SIZE, count) != count) {
+		fprintf(stderr, "%s: Can't read %s: %s\n",
+			argv[0], argv[1], strerror(errno));
+
+		if (ifd)
+			close(ifd);
+		if (ofd)
+			close(ofd);
+
+		exit(EXIT_FAILURE);
+	}
+	
+#if 0
+	for (i = 0; i < IMG_SIZE - SPL_HEADER_SIZE; i++)
+		checksum += buffer[i+16];
+
+	*(unsigned long *)buffer ^= 0x1f;
+	*(unsigned long *)(buffer+4) ^= checksum;
+
+	for (i = 1; i < SPL_HEADER_SIZE; i++)
+		buffer[i] ^= buffer[i-1];
+#endif
+
+	for (i = 0; i < IMG_SIZE - 4; i++)
+		checksum += (unsigned char)buffer[i];
+
+	*(unsigned int *)&buffer[i] = checksum;
+
+	if (write(ofd, buffer, BUFSIZE) != BUFSIZE) {
+		fprintf(stderr, "%s: Can't write %s: %s\n",
+			argv[0], argv[2], strerror(errno));
+
+		if (ifd)
+			close(ifd);
+		if (ofd)
+			close(ofd);
+
+		exit(EXIT_FAILURE);
+	}
+
+	if (ifd)
+		close(ifd);
+	if (ofd)
+		close(ofd);
+
+	return EXIT_SUCCESS;
+}
diff -urN u-boot-2017.11/cmd/mmc.c u-boot-2017.11-itop4412/cmd/mmc.c
--- u-boot-2017.11/cmd/mmc.c	2017-11-14 09:08:06.000000000 +0800
+++ u-boot-2017.11-itop4412/cmd/mmc.c	2019-02-25 12:14:46.000000000 +0800
@@ -9,6 +9,7 @@
 #include <command.h>
 #include <console.h>
 #include <mmc.h>
+#include <asm/arch/power.h>
 
 static int curr_device = -1;
 
@@ -97,6 +98,28 @@
 		return NULL;
 	return mmc;
 }
+
+u64 get_mmcinfo_capacity()
+{
+        struct mmc *mmc;
+
+        if (curr_device < 0) {
+                if (get_mmc_num() > 0)
+                        curr_device = 0;
+                else {
+                        puts("No MMC device available\n");
+                        return 1;
+                }
+        }
+
+        mmc = init_mmc_device(curr_device, false);
+        if (!mmc)
+                return CMD_RET_FAILURE;
+
+        return mmc->capacity >> 30;
+}
+
+
 static int do_mmcinfo(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 {
 	struct mmc *mmc;
@@ -297,7 +320,7 @@
 
 	return (n == cnt) ? CMD_RET_SUCCESS : CMD_RET_FAILURE;
 }
-static int do_mmc_write(cmd_tbl_t *cmdtp, int flag,
+int do_mmc_write(cmd_tbl_t *cmdtp, int flag,
 			int argc, char * const argv[])
 {
 	struct mmc *mmc;
@@ -385,11 +408,12 @@
 	puts("get mmc type error!\n");
 	return CMD_RET_FAILURE;
 }
-static int do_mmc_dev(cmd_tbl_t *cmdtp, int flag,
+int do_mmc_dev(cmd_tbl_t *cmdtp, int flag,
 		      int argc, char * const argv[])
 {
 	int dev, part = 0, ret;
 	struct mmc *mmc;
+	struct mmc_cmd cmd;
 
 	if (argc == 1) {
 		dev = curr_device;
@@ -411,11 +435,34 @@
 	if (!mmc)
 		return CMD_RET_FAILURE;
 
-	ret = blk_select_hwpart_devnum(IF_TYPE_MMC, dev, part);
-	printf("switch to partitions #%d, %s\n",
-	       part, (!ret) ? "OK" : "ERROR");
-	if (ret)
-		return 1;
+	 if(strcmp(argv[0],"open") == 0){
+                cmd.cmdidx = MMC_CMD_SWITCH;
+                cmd.resp_type = MMC_RSP_R1b;
+                cmd.cmdarg = ((3<<24)|(179<<16)|(((1<<6)|(1<<3)|(1<<0))<<8));
+
+                ret = mmc_send_cmd(mmc, &cmd, NULL);
+                printf("switch to partitions #%d, %s\n",
+                                part, (!ret) ? "OK" : "ERROR");
+                if (ret)
+                        return 1;
+        }else if(strcmp(argv[0],"close") == 0)
+        {
+                cmd.cmdidx = MMC_CMD_SWITCH;
+                cmd.resp_type = MMC_RSP_R1b;
+                cmd.cmdarg = ((3<<24)|(179<<16)|(((1<<6)|(1<<3)|(0<<0))<<8));
+                ret = mmc_send_cmd(mmc, &cmd, NULL);
+                printf("eMMC CLOSE Success.!!");
+                if (ret)
+                        return 1;
+
+        }
+
+
+	//ret = blk_select_hwpart_devnum(IF_TYPE_MMC, dev, part);
+	//printf("switch to partitions #%d, %s\n",
+	 //      part, (!ret) ? "OK" : "ERROR");
+	//if (ret)
+	//	return 1;
 
 	curr_device = dev;
 	if (mmc->part_config == MMCPART_NOAVAILABLE)
@@ -807,10 +854,11 @@
 #endif
 };
 
-static int do_mmcops(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+int do_mmcops(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 {
 	cmd_tbl_t *cp;
-
+	unsigned int boot_mode  = get_boot_mode();
+	
 	cp = find_cmd_tbl(argv[1], cmd_mmc, ARRAY_SIZE(cmd_mmc));
 
 	/* Drop the mmc command */
@@ -824,7 +872,10 @@
 
 	if (curr_device < 0) {
 		if (get_mmc_num() > 0) {
-			curr_device = 0;
+			if (boot_mode == BOOT_MODE_EMMC_SD)
+				curr_device = 0;
+			else if (boot_mode == BOOT_MODE_SD)
+				curr_device = 1;
 		} else {
 			puts("No MMC device available\n");
 			return CMD_RET_FAILURE;
diff -urN u-boot-2017.11/common/autoboot.c u-boot-2017.11-itop4412/common/autoboot.c
--- u-boot-2017.11/common/autoboot.c	2017-11-14 09:08:06.000000000 +0800
+++ u-boot-2017.11-itop4412/common/autoboot.c	2019-02-16 09:21:32.000000000 +0800
@@ -347,7 +347,6 @@
 #if defined(CONFIG_AUTOBOOT_KEYED) && !defined(CONFIG_AUTOBOOT_KEYED_CTRLC)
 		int prev = disable_ctrlc(1);	/* disable Control C checking */
 #endif
-
 		run_command_list(s, -1, 0);
 
 #if defined(CONFIG_AUTOBOOT_KEYED) && !defined(CONFIG_AUTOBOOT_KEYED_CTRLC)
diff -urN u-boot-2017.11/common/board_r.c u-boot-2017.11-itop4412/common/board_r.c
--- u-boot-2017.11/common/board_r.c	2017-11-14 09:08:06.000000000 +0800
+++ u-boot-2017.11-itop4412/common/board_r.c	2019-02-16 09:21:32.000000000 +0800
@@ -252,7 +252,6 @@
 static int initr_malloc(void)
 {
 	ulong malloc_start;
-
 #if CONFIG_VAL(SYS_MALLOC_F_LEN)
 	debug("Pre-reloc malloc() used %#lx bytes (%ld KB)\n", gd->malloc_ptr,
 	      gd->malloc_ptr / 1024);
diff -urN u-boot-2017.11/common/cli.c u-boot-2017.11-itop4412/common/cli.c
--- u-boot-2017.11/common/cli.c	2017-11-14 09:08:06.000000000 +0800
+++ u-boot-2017.11-itop4412/common/cli.c	2019-02-16 09:21:32.000000000 +0800
@@ -76,7 +76,6 @@
 	int need_buff = 1;
 	char *buff = (char *)cmd;	/* cast away const */
 	int rcode = 0;
-
 	if (len == -1) {
 		len = strlen(cmd);
 #ifdef CONFIG_HUSH_PARSER
diff -urN u-boot-2017.11/common/cli_hush.c u-boot-2017.11-itop4412/common/cli_hush.c
--- u-boot-2017.11/common/cli_hush.c	2017-11-14 09:08:06.000000000 +0800
+++ u-boot-2017.11-itop4412/common/cli_hush.c	2019-02-16 09:21:32.000000000 +0800
@@ -1028,7 +1028,6 @@
 	bootretry_reset_cmd_timeout();
 	i->__promptme = 1;
 	n = uboot_cli_readline(i);
-
 #ifdef CONFIG_BOOT_RETRY_TIME
 	if (n == -2) {
 	  puts("\nTimeout waiting for command\n");
diff -urN u-boot-2017.11/.config u-boot-2017.11-itop4412/.config
--- u-boot-2017.11/.config	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-2017.11-itop4412/.config	2019-02-16 11:31:55.000000000 +0800
@@ -0,0 +1,1058 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# U-Boot 2017.11 Configuration
+#
+CONFIG_CREATE_ARCH_SYMLINK=y
+# CONFIG_ARC is not set
+CONFIG_ARM=y
+# CONFIG_M68K is not set
+# CONFIG_MICROBLAZE is not set
+# CONFIG_MIPS is not set
+# CONFIG_NDS32 is not set
+# CONFIG_NIOS2 is not set
+# CONFIG_PPC is not set
+# CONFIG_SANDBOX is not set
+# CONFIG_SH is not set
+# CONFIG_X86 is not set
+# CONFIG_XTENSA is not set
+CONFIG_SYS_ARCH="arm"
+CONFIG_SYS_CPU="armv7"
+CONFIG_SYS_SOC="exynos"
+CONFIG_SYS_VENDOR="samsung"
+CONFIG_SYS_BOARD="itop4412"
+CONFIG_SYS_CONFIG_NAME="itop4412"
+
+#
+# ARM architecture
+#
+CONFIG_HAS_VBAR=y
+CONFIG_HAS_THUMB2=y
+CONFIG_ARM_ASM_UNIFIED=y
+CONFIG_CPU_V7=y
+CONFIG_SYS_ARM_ARCH=7
+CONFIG_SYS_CACHE_SHIFT_6=y
+CONFIG_SYS_CACHELINE_SIZE=64
+# CONFIG_ARM_SMCCC is not set
+# CONFIG_SEMIHOSTING is not set
+# CONFIG_SYS_THUMB_BUILD is not set
+# CONFIG_SPL_SYS_THUMB_BUILD is not set
+# CONFIG_SYS_L2CACHE_OFF is not set
+# CONFIG_ENABLE_ARM_SOC_BOOT0_HOOK is not set
+# CONFIG_ARM_CORTEX_CPU_IS_UP is not set
+CONFIG_USE_ARCH_MEMCPY=y
+CONFIG_SPL_USE_ARCH_MEMCPY=y
+CONFIG_USE_ARCH_MEMSET=y
+CONFIG_SPL_USE_ARCH_MEMSET=y
+# CONFIG_ARM64_SUPPORT_AARCH32 is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_TARGET_EDB93XX is not set
+# CONFIG_TARGET_ASPENITE is not set
+# CONFIG_TARGET_GPLUGD is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_KIRKWOOD is not set
+# CONFIG_ARCH_MVEBU is not set
+# CONFIG_TARGET_DEVKIT3250 is not set
+# CONFIG_TARGET_WORK_92105 is not set
+# CONFIG_TARGET_APF27 is not set
+# CONFIG_TARGET_APX4DEVKIT is not set
+# CONFIG_TARGET_XFI3 is not set
+# CONFIG_TARGET_M28EVK is not set
+# CONFIG_TARGET_MX23EVK is not set
+# CONFIG_TARGET_MX28EVK is not set
+# CONFIG_TARGET_MX23_OLINUXINO is not set
+# CONFIG_TARGET_BG0900 is not set
+# CONFIG_TARGET_SANSA_FUZE_PLUS is not set
+# CONFIG_TARGET_SC_SPS_1 is not set
+# CONFIG_ORION5X is not set
+# CONFIG_TARGET_SPEAR300 is not set
+# CONFIG_TARGET_SPEAR310 is not set
+# CONFIG_TARGET_SPEAR320 is not set
+# CONFIG_TARGET_SPEAR600 is not set
+# CONFIG_TARGET_STV0991 is not set
+# CONFIG_TARGET_X600 is not set
+# CONFIG_TARGET_IMX31_PHYCORE is not set
+# CONFIG_TARGET_IMX31_PHYCORE_EET is not set
+# CONFIG_TARGET_MX31ADS is not set
+# CONFIG_TARGET_MX31PDK is not set
+# CONFIG_TARGET_WOODBURN is not set
+# CONFIG_TARGET_WOODBURN_SD is not set
+# CONFIG_TARGET_FLEA3 is not set
+# CONFIG_TARGET_MX35PDK is not set
+# CONFIG_ARCH_BCM283X is not set
+# CONFIG_TARGET_VEXPRESS_CA15_TC2 is not set
+# CONFIG_TARGET_VEXPRESS_CA5X2 is not set
+# CONFIG_TARGET_VEXPRESS_CA9X4 is not set
+# CONFIG_TARGET_BCM23550_W1D is not set
+# CONFIG_TARGET_BCM28155_AP is not set
+# CONFIG_TARGET_BCMCYGNUS is not set
+# CONFIG_TARGET_BCMNSP is not set
+# CONFIG_TARGET_BCMNS2 is not set
+CONFIG_ARCH_EXYNOS=y
+# CONFIG_ARCH_S5PC1XX is not set
+# CONFIG_ARCH_HIGHBANK is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_KEYSTONE is not set
+# CONFIG_ARCH_OMAP2PLUS is not set
+# CONFIG_ARCH_MESON is not set
+# CONFIG_ARCH_MX25 is not set
+# CONFIG_ARCH_MX7ULP is not set
+# CONFIG_ARCH_MX7 is not set
+# CONFIG_ARCH_MX6 is not set
+CONFIG_SPL_LDSCRIPT="board/samsung/common/exynos-uboot-spl.lds"
+# CONFIG_ARCH_MX5 is not set
+# CONFIG_ARCH_QEMU is not set
+# CONFIG_ARCH_RMOBILE is not set
+# CONFIG_TARGET_S32V234EVB is not set
+# CONFIG_ARCH_SNAPDRAGON is not set
+# CONFIG_ARCH_SOCFPGA is not set
+# CONFIG_ARCH_SUNXI is not set
+# CONFIG_TARGET_TS4600 is not set
+# CONFIG_ARCH_VF610 is not set
+# CONFIG_ARCH_ZYNQ is not set
+# CONFIG_ARCH_ZYNQMP is not set
+# CONFIG_TEGRA is not set
+# CONFIG_TARGET_VEXPRESS64_AEMV8A is not set
+# CONFIG_TARGET_VEXPRESS64_BASE_FVP is not set
+# CONFIG_TARGET_VEXPRESS64_BASE_FVP_DRAM is not set
+# CONFIG_TARGET_VEXPRESS64_JUNO is not set
+# CONFIG_TARGET_LS2080A_EMU is not set
+# CONFIG_TARGET_LS2080A_SIMU is not set
+# CONFIG_TARGET_LS1088AQDS is not set
+# CONFIG_TARGET_LS2080AQDS is not set
+# CONFIG_TARGET_LS2080ARDB is not set
+# CONFIG_TARGET_LS2081ARDB is not set
+# CONFIG_TARGET_HIKEY is not set
+# CONFIG_TARGET_POPLAR is not set
+# CONFIG_TARGET_LS1012AQDS is not set
+# CONFIG_TARGET_LS1012ARDB is not set
+# CONFIG_TARGET_LS1012AFRDM is not set
+# CONFIG_TARGET_LS1088ARDB is not set
+# CONFIG_TARGET_LS1021AQDS is not set
+# CONFIG_TARGET_LS1021ATWR is not set
+# CONFIG_TARGET_LS1021AIOT is not set
+# CONFIG_TARGET_LS1043AQDS is not set
+# CONFIG_TARGET_LS1043ARDB is not set
+# CONFIG_TARGET_LS1046AQDS is not set
+# CONFIG_TARGET_LS1046ARDB is not set
+# CONFIG_TARGET_H2200 is not set
+# CONFIG_TARGET_ZIPITZ2 is not set
+# CONFIG_TARGET_COLIBRI_PXA270 is not set
+# CONFIG_ARCH_UNIPHIER is not set
+# CONFIG_STM32 is not set
+# CONFIG_ARCH_STI is not set
+# CONFIG_ARCH_ROCKCHIP is not set
+# CONFIG_TARGET_THUNDERX_88XX is not set
+# CONFIG_ARCH_ASPEED is not set
+CONFIG_ARCH_EXYNOS4=y
+# CONFIG_ARCH_EXYNOS5 is not set
+# CONFIG_ARCH_EXYNOS7 is not set
+# CONFIG_TARGET_SMDKV310 is not set
+# CONFIG_TARGET_TRATS is not set
+# CONFIG_TARGET_S5PC210_UNIVERSAL is not set
+# CONFIG_TARGET_ORIGEN is not set
+CONFIG_TARGET_ITOP4412=y
+# CONFIG_TARGET_TRATS2 is not set
+# CONFIG_TARGET_ODROID is not set
+CONFIG_SPL_GPIO_SUPPORT=y
+# CONFIG_SPL_LIBCOMMON_SUPPORT is not set
+# CONFIG_SPL_LIBGENERIC_SUPPORT is not set
+CONFIG_SYS_MALLOC_F_LEN=0x400
+# CONFIG_SPL_MMC_SUPPORT is not set
+CONFIG_SPL_SERIAL_SUPPORT=y
+# CONFIG_SPL_DRIVERS_MISC_SUPPORT is not set
+# CONFIG_SPL_LIBDISK_SUPPORT is not set
+# CONFIG_SPL_NAND_SUPPORT is not set
+# CONFIG_SPL_SPI_FLASH_SUPPORT is not set
+# CONFIG_SPL_SPI_SUPPORT is not set
+# CONFIG_SPL_WATCHDOG_SUPPORT is not set
+CONFIG_IDENT_STRING=" for itop-4412"
+# CONFIG_SPL_FAT_SUPPORT is not set
+# CONFIG_ARMV7_LPAE is not set
+# CONFIG_CMD_DEKBLOB is not set
+# CONFIG_CMD_HDMIDETECT is not set
+
+#
+# ARM debug
+#
+# CONFIG_DEBUG_LL is not set
+CONFIG_DEFAULT_DEVICE_TREE="exynos4412-itop4412"
+CONFIG_SMBIOS_PRODUCT_NAME="itop4412"
+CONFIG_DEBUG_UART=y
+# CONFIG_AHCI is not set
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+# CONFIG_DISTRO_DEFAULTS is not set
+CONFIG_SYS_MALLOC_F=y
+CONFIG_SPL_SYS_MALLOC_F_LEN=0x400
+CONFIG_TPL_SYS_MALLOC_F_LEN=0x400
+CONFIG_EXPERT=y
+CONFIG_SYS_MALLOC_CLEAR_ON_INIT=y
+# CONFIG_TOOLS_DEBUG is not set
+# CONFIG_PHYS_64BIT is not set
+
+#
+# Boot images
+#
+# CONFIG_ANDROID_BOOT_IMAGE is not set
+# CONFIG_FIT is not set
+# CONFIG_OF_BOARD_SETUP is not set
+# CONFIG_OF_SYSTEM_SETUP is not set
+# CONFIG_OF_STDOUT_VIA_ALIAS is not set
+CONFIG_SYS_EXTRA_OPTIONS=""
+CONFIG_ARCH_FIXUP_FDT_MEMORY=y
+
+#
+# API
+#
+# CONFIG_API is not set
+
+#
+# Boot timing
+#
+# CONFIG_BOOTSTAGE is not set
+CONFIG_BOOTSTAGE_RECORD_COUNT=30
+CONFIG_SPL_BOOTSTAGE_RECORD_COUNT=5
+CONFIG_BOOTSTAGE_STASH_ADDR=0
+CONFIG_BOOTSTAGE_STASH_SIZE=0x1000
+
+#
+# Boot media
+#
+# CONFIG_NAND_BOOT is not set
+# CONFIG_ONENAND_BOOT is not set
+# CONFIG_QSPI_BOOT is not set
+# CONFIG_SATA_BOOT is not set
+CONFIG_SD_BOOT=y
+# CONFIG_SPI_BOOT is not set
+CONFIG_BOOTDELAY=5
+# CONFIG_USE_BOOTARGS is not set
+
+#
+# Console
+#
+# CONFIG_CONSOLE_RECORD is not set
+CONFIG_LOGLEVEL=4
+CONFIG_SPL_LOGLEVEL=4
+# CONFIG_SILENT_CONSOLE is not set
+# CONFIG_PRE_CONSOLE_BUFFER is not set
+# CONFIG_CONSOLE_MUX is not set
+CONFIG_SYS_CONSOLE_IS_IN_ENV=y
+# CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE is not set
+# CONFIG_SYS_CONSOLE_ENV_OVERWRITE is not set
+CONFIG_SYS_CONSOLE_INFO_QUIET=y
+CONFIG_SYS_STDIO_DEREGISTER=y
+CONFIG_DEFAULT_FDT_FILE=""
+# CONFIG_VERSION_VARIABLE is not set
+CONFIG_DISPLAY_CPUINFO=y
+CONFIG_DISPLAY_BOARDINFO=y
+
+#
+# Start-up hooks
+#
+# CONFIG_ARCH_EARLY_INIT_R is not set
+# CONFIG_ARCH_MISC_INIT is not set
+CONFIG_BOARD_EARLY_INIT_F=y
+
+#
+# Security support
+#
+CONFIG_HASH=y
+
+#
+# SPL / TPL
+#
+CONFIG_SUPPORT_SPL=y
+CONFIG_SPL=y
+# CONFIG_SPL_BOARD_INIT is not set
+# CONFIG_SPL_BOOTROM_SUPPORT is not set
+CONFIG_SPL_RAW_IMAGE_SUPPORT=y
+CONFIG_SPL_LEGACY_IMAGE_SUPPORT=y
+# CONFIG_SPL_SYS_MALLOC_SIMPLE is not set
+# CONFIG_TPL_SYS_MALLOC_SIMPLE is not set
+# CONFIG_SPL_STACK_R is not set
+# CONFIG_SPL_SEPARATE_BSS is not set
+# CONFIG_SPL_DISPLAY_PRINT is not set
+# CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_USE_SECTOR is not set
+# CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_USE_PARTITION is not set
+# CONFIG_SPL_CPU_SUPPORT is not set
+# CONFIG_SPL_CRYPTO_SUPPORT is not set
+# CONFIG_SPL_HASH_SUPPORT is not set
+# CONFIG_SPL_DMA_SUPPORT is not set
+# CONFIG_SPL_ENV_SUPPORT is not set
+# CONFIG_SPL_EXT_SUPPORT is not set
+# CONFIG_SPL_FPGA_SUPPORT is not set
+# CONFIG_SPL_I2C_SUPPORT is not set
+# CONFIG_SPL_MPC8XXX_INIT_DDR_SUPPORT is not set
+# CONFIG_SPL_MTD_SUPPORT is not set
+# CONFIG_SPL_MUSB_NEW_SUPPORT is not set
+# CONFIG_SPL_NET_SUPPORT is not set
+# CONFIG_SPL_NO_CPU_SUPPORT is not set
+# CONFIG_SPL_NOR_SUPPORT is not set
+# CONFIG_SPL_XIP_SUPPORT is not set
+# CONFIG_SPL_ONENAND_SUPPORT is not set
+# CONFIG_SPL_OS_BOOT is not set
+# CONFIG_SPL_PCI_SUPPORT is not set
+# CONFIG_SPL_PCH_SUPPORT is not set
+# CONFIG_SPL_POST_MEM_SUPPORT is not set
+# CONFIG_SPL_POWER_SUPPORT is not set
+# CONFIG_SPL_RAM_SUPPORT is not set
+# CONFIG_SPL_RTC_SUPPORT is not set
+# CONFIG_SPL_SATA_SUPPORT is not set
+# CONFIG_SPL_USB_HOST_SUPPORT is not set
+# CONFIG_SPL_USB_GADGET_SUPPORT is not set
+# CONFIG_SPL_YMODEM_SUPPORT is not set
+
+#
+# Command line interface
+#
+CONFIG_CMDLINE=y
+CONFIG_HUSH_PARSER=y
+CONFIG_SYS_PROMPT="u-boot # "
+
+#
+# Autoboot options
+#
+CONFIG_AUTOBOOT=y
+# CONFIG_AUTOBOOT_KEYED is not set
+
+#
+# FASTBOOT
+#
+CONFIG_FASTBOOT=y
+CONFIG_USB_FUNCTION_FASTBOOT=y
+CONFIG_CMD_FASTBOOT=y
+CONFIG_FASTBOOT_BUF_ADDR=0x40000000
+CONFIG_FASTBOOT_BUF_SIZE=0x10000000
+CONFIG_FASTBOOT_USB_DEV=0
+CONFIG_FASTBOOT_FLASH=y
+CONFIG_FASTBOOT_FLASH_MMC_DEV=0
+CONFIG_FASTBOOT_GPT_NAME="gpt"
+CONFIG_FASTBOOT_MBR_NAME="mbr"
+
+#
+# Commands
+#
+
+#
+# Info commands
+#
+CONFIG_CMD_BDI=y
+# CONFIG_CMD_CONFIG is not set
+CONFIG_CMD_CONSOLE=y
+# CONFIG_CMD_CPU is not set
+# CONFIG_CMD_LICENSE is not set
+
+#
+# Boot commands
+#
+CONFIG_CMD_BOOTD=y
+CONFIG_CMD_BOOTM=y
+CONFIG_CMD_BOOTZ=y
+CONFIG_CMD_BOOTEFI=y
+CONFIG_CMD_BOOTEFI_HELLO_COMPILE=y
+# CONFIG_CMD_BOOTEFI_HELLO is not set
+# CONFIG_CMD_BOOTEFI_SELFTEST is not set
+# CONFIG_CMD_BOOTMENU is not set
+CONFIG_CMD_ELF=y
+CONFIG_CMD_FDT=y
+CONFIG_CMD_GO=y
+CONFIG_CMD_RUN=y
+CONFIG_CMD_IMI=y
+# CONFIG_CMD_IMLS is not set
+# CONFIG_CMD_XIMG is not set
+# CONFIG_CMD_POWEROFF is not set
+# CONFIG_CMD_SPL is not set
+CONFIG_CMD_THOR_DOWNLOAD=y
+# CONFIG_CMD_ZBOOT is not set
+
+#
+# Environment commands
+#
+# CONFIG_CMD_ASKENV is not set
+CONFIG_CMD_EXPORTENV=y
+CONFIG_CMD_IMPORTENV=y
+CONFIG_CMD_EDITENV=y
+# CONFIG_CMD_GREPENV is not set
+CONFIG_CMD_SAVEENV=y
+CONFIG_CMD_ENV_EXISTS=y
+# CONFIG_CMD_ENV_CALLBACK is not set
+# CONFIG_CMD_ENV_FLAGS is not set
+
+#
+# Memory commands
+#
+CONFIG_CMD_CRC32=y
+# CONFIG_CRC32_VERIFY is not set
+# CONFIG_CMD_EEPROM is not set
+# CONFIG_LOOPW is not set
+# CONFIG_CMD_MD5SUM is not set
+# CONFIG_CMD_MEMINFO is not set
+CONFIG_CMD_MEMORY=y
+# CONFIG_CMD_MEMTEST is not set
+# CONFIG_CMD_MX_CYCLIC is not set
+# CONFIG_CMD_SHA1SUM is not set
+# CONFIG_CMD_STRINGS is not set
+
+#
+# Compression commands
+#
+# CONFIG_CMD_LZMADEC is not set
+# CONFIG_CMD_UNZIP is not set
+# CONFIG_CMD_ZIP is not set
+
+#
+# Device access commands
+#
+# CONFIG_CMD_ARMFLASH is not set
+# CONFIG_CMD_CLK is not set
+# CONFIG_CMD_DEMO is not set
+CONFIG_CMD_DFU=y
+CONFIG_CMD_DM=y
+# CONFIG_CMD_FDC is not set
+CONFIG_CMD_FLASH=y
+# CONFIG_CMD_FPGA is not set
+# CONFIG_CMD_FPGAD is not set
+# CONFIG_CMD_FUSE is not set
+# CONFIG_CMD_GPIO is not set
+CONFIG_CMD_GPT=y
+CONFIG_RANDOM_UUID=y
+# CONFIG_CMD_GPT_RENAME is not set
+# CONFIG_CMD_IDE is not set
+# CONFIG_CMD_IO is not set
+# CONFIG_CMD_IOTRACE is not set
+# CONFIG_CMD_I2C is not set
+CONFIG_CMD_LOADB=y
+CONFIG_CMD_LOADS=y
+CONFIG_CMD_MMC=y
+# CONFIG_CMD_NAND is not set
+# CONFIG_CMD_MMC_SPI is not set
+# CONFIG_CMD_ONENAND is not set
+CONFIG_CMD_PART=y
+# CONFIG_CMD_PCI is not set
+# CONFIG_CMD_PCMCIA is not set
+# CONFIG_CMD_READ is not set
+# CONFIG_CMD_SATA is not set
+# CONFIG_CMD_SAVES is not set
+# CONFIG_CMD_SDRAM is not set
+# CONFIG_CMD_SF is not set
+# CONFIG_CMD_SF_TEST is not set
+# CONFIG_CMD_SPI is not set
+# CONFIG_CMD_TSI148 is not set
+# CONFIG_CMD_UNIVERSE is not set
+CONFIG_CMD_USB=y
+# CONFIG_CMD_USB_SDP is not set
+CONFIG_CMD_USB_MASS_STORAGE=y
+
+#
+# Shell scripting commands
+#
+CONFIG_CMD_ECHO=y
+CONFIG_CMD_ITEST=y
+CONFIG_CMD_SOURCE=y
+CONFIG_CMD_SETEXPR=y
+
+#
+# Network commands
+#
+# CONFIG_CMD_NET is not set
+# CONFIG_CMD_TFTPPUT is not set
+# CONFIG_CMD_TFTPSRV is not set
+# CONFIG_CMD_RARP is not set
+CONFIG_CMD_DHCP=y
+# CONFIG_CMD_PXE is not set
+# CONFIG_CMD_NFS is not set
+CONFIG_CMD_MII=y
+# CONFIG_CMD_PING is not set
+# CONFIG_CMD_CDP is not set
+# CONFIG_CMD_SNTP is not set
+# CONFIG_CMD_DNS is not set
+# CONFIG_CMD_LINK_LOCAL is not set
+# CONFIG_CMD_ETHSW is not set
+
+#
+# Misc commands
+#
+# CONFIG_CMD_BSP is not set
+# CONFIG_CMD_BKOPS_ENABLE is not set
+CONFIG_CMD_CACHE=y
+# CONFIG_CMD_DISPLAY is not set
+# CONFIG_CMD_LED is not set
+# CONFIG_CMD_DATE is not set
+# CONFIG_CMD_TIME is not set
+# CONFIG_CMD_GETTIME is not set
+# CONFIG_CMD_MISC is not set
+# CONFIG_CMD_TIMER is not set
+# CONFIG_CMD_QFW is not set
+# CONFIG_CMD_TERMINAL is not set
+# CONFIG_CMD_UUID is not set
+
+#
+# Power commands
+#
+
+#
+# Security commands
+#
+# CONFIG_CMD_AES is not set
+# CONFIG_CMD_BLOB is not set
+# CONFIG_CMD_HASH is not set
+
+#
+# Firmware commands
+#
+
+#
+# Filesystem commands
+#
+# CONFIG_CMD_BTRFS is not set
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+# CONFIG_CMD_FS_UUID is not set
+# CONFIG_CMD_JFFS2 is not set
+# CONFIG_CMD_MTDPARTS is not set
+CONFIG_MTDIDS_DEFAULT=""
+CONFIG_MTDPARTS_DEFAULT=""
+# CONFIG_CMD_REISER is not set
+# CONFIG_CMD_SCSI is not set
+# CONFIG_CMD_ZFS is not set
+
+#
+# Debug commands
+#
+# CONFIG_CMD_BEDBUG is not set
+# CONFIG_CMD_DIAG is not set
+# CONFIG_CMD_KGDB is not set
+# CONFIG_CMD_TRACE is not set
+# CONFIG_CMD_UBI is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITIONS=y
+# CONFIG_MAC_PARTITION is not set
+# CONFIG_SPL_MAC_PARTITION is not set
+CONFIG_DOS_PARTITION=y
+CONFIG_SPL_DOS_PARTITION=y
+CONFIG_ISO_PARTITION=y
+CONFIG_SPL_ISO_PARTITION=y
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_SPL_AMIGA_PARTITION is not set
+CONFIG_EFI_PARTITION=y
+CONFIG_EFI_PARTITION_ENTRIES_OFF=0
+CONFIG_SPL_EFI_PARTITION=y
+CONFIG_PARTITION_UUIDS=y
+CONFIG_SPL_PARTITION_UUIDS=y
+# CONFIG_PARTITION_TYPE_GUID is not set
+CONFIG_SUPPORT_OF_CONTROL=y
+CONFIG_DTC=y
+
+#
+# Device Tree Control
+#
+CONFIG_OF_CONTROL=y
+# CONFIG_OF_BOARD_FIXUP is not set
+# CONFIG_SPL_OF_CONTROL is not set
+# CONFIG_OF_LIVE is not set
+CONFIG_OF_SEPARATE=y
+# CONFIG_OF_EMBED is not set
+# CONFIG_OF_BOARD is not set
+# CONFIG_MULTI_DTB_FIT is not set
+CONFIG_MKIMAGE_DTC_PATH="dtc"
+
+#
+# Environment
+#
+# CONFIG_ENV_IS_NOWHERE is not set
+# CONFIG_ENV_IS_IN_EEPROM is not set
+# CONFIG_ENV_IS_IN_FAT is not set
+# CONFIG_ENV_IS_IN_FLASH is not set
+CONFIG_ENV_IS_IN_MMC=y
+# CONFIG_ENV_IS_IN_NAND is not set
+# CONFIG_ENV_IS_IN_NVRAM is not set
+# CONFIG_ENV_IS_IN_ONENAND is not set
+# CONFIG_ENV_IS_IN_REMOTE is not set
+# CONFIG_ENV_IS_IN_SPI_FLASH is not set
+# CONFIG_ENV_IS_IN_UBI is not set
+# CONFIG_ENV_AES is not set
+# CONFIG_NET is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_DM=y
+# CONFIG_SPL_DM is not set
+CONFIG_DM_WARN=y
+# CONFIG_DM_DEBUG is not set
+CONFIG_DM_DEVICE_REMOVE=y
+CONFIG_DM_STDIO=y
+CONFIG_DM_SEQ_ALIAS=y
+# CONFIG_SPL_DM_SEQ_ALIAS is not set
+# CONFIG_REGMAP is not set
+# CONFIG_DEVRES is not set
+CONFIG_SIMPLE_BUS=y
+CONFIG_OF_TRANSLATE=y
+CONFIG_DM_DEV_READ_INLINE=y
+# CONFIG_ADC is not set
+# CONFIG_ADC_EXYNOS is not set
+# CONFIG_ADC_SANDBOX is not set
+# CONFIG_SARADC_ROCKCHIP is not set
+# CONFIG_SATA is not set
+
+#
+# SATA/SCSI device support
+#
+CONFIG_BLK=y
+# CONFIG_BLOCK_CACHE is not set
+# CONFIG_IDE is not set
+
+#
+# Clock
+#
+# CONFIG_CLK is not set
+# CONFIG_CPU is not set
+
+#
+# Hardware crypto devices
+#
+# CONFIG_FSL_CAAM is not set
+# CONFIG_SYS_FSL_SEC_BE is not set
+# CONFIG_SYS_FSL_SEC_LE is not set
+
+#
+# Demo for driver model
+#
+# CONFIG_DM_DEMO is not set
+
+#
+# DFU support
+#
+CONFIG_USB_FUNCTION_DFU=y
+# CONFIG_DFU_TFTP is not set
+CONFIG_DFU_MMC=y
+# CONFIG_DFU_NAND is not set
+# CONFIG_DFU_RAM is not set
+# CONFIG_DFU_SF is not set
+
+#
+# DMA Support
+#
+# CONFIG_DMA is not set
+# CONFIG_TI_EDMA3 is not set
+
+#
+# FPGA support
+#
+# CONFIG_FPGA_ALTERA is not set
+# CONFIG_FPGA_SOCFPGA is not set
+# CONFIG_FPGA_XILINX is not set
+
+#
+# GPIO Support
+#
+CONFIG_DM_GPIO=y
+# CONFIG_ALTERA_PIO is not set
+# CONFIG_DWAPB_GPIO is not set
+# CONFIG_AT91_GPIO is not set
+# CONFIG_ATMEL_PIO4 is not set
+# CONFIG_INTEL_BROADWELL_GPIO is not set
+# CONFIG_INTEL_ICH6_GPIO is not set
+# CONFIG_IMX_RGPIO2P is not set
+# CONFIG_LPC32XX_GPIO is not set
+# CONFIG_MSM_GPIO is not set
+# CONFIG_CMD_PCA953X is not set
+# CONFIG_PCF8575_GPIO is not set
+# CONFIG_ROCKCHIP_GPIO is not set
+# CONFIG_CMD_TCA642X is not set
+# CONFIG_TEGRA_GPIO is not set
+# CONFIG_TEGRA186_GPIO is not set
+# CONFIG_VYBRID_GPIO is not set
+# CONFIG_DM_74X164 is not set
+# CONFIG_DM_PCA953X is not set
+# CONFIG_MPC85XX_GPIO is not set
+
+#
+# I2C support
+#
+CONFIG_DM_I2C=y
+# CONFIG_DM_I2C_COMPAT is not set
+# CONFIG_I2C_SET_DEFAULT_BUS_NUM is not set
+# CONFIG_DM_I2C_GPIO is not set
+# CONFIG_SYS_I2C_FSL is not set
+# CONFIG_SYS_I2C_DW is not set
+# CONFIG_SYS_I2C_INTEL is not set
+# CONFIG_SYS_I2C_IMX_LPI2C is not set
+# CONFIG_SYS_I2C_ROCKCHIP is not set
+# CONFIG_SYS_I2C_S3C24X0 is not set
+# CONFIG_SYS_I2C_MVTWSI is not set
+# CONFIG_I2C_MUX is not set
+CONFIG_DM_KEYBOARD=y
+# CONFIG_CROS_EC_KEYB is not set
+# CONFIG_I8042_KEYB is not set
+
+#
+# LED Support
+#
+# CONFIG_LED is not set
+# CONFIG_LED_STATUS is not set
+
+#
+# Mailbox Controller Support
+#
+# CONFIG_DM_MAILBOX is not set
+
+#
+# Memory Controller drivers
+#
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MISC is not set
+# CONFIG_CROS_EC is not set
+# CONFIG_DS4510 is not set
+# CONFIG_FSL_SEC_MON is not set
+# CONFIG_MXC_OCOTP is not set
+# CONFIG_NUVOTON_NCT6102D is not set
+# CONFIG_PWRSEQ is not set
+# CONFIG_PCA9551_LED is not set
+# CONFIG_WINBOND_W83627 is not set
+
+#
+# MMC Host controller Support
+#
+CONFIG_MMC=y
+CONFIG_DM_MMC=y
+# CONFIG_SPL_MMC_TINY is not set
+CONFIG_MMC_DW=y
+CONFIG_MMC_DW_EXYNOS=y
+# CONFIG_MMC_DW_K3 is not set
+# CONFIG_MMC_DW_ROCKCHIP is not set
+# CONFIG_MMC_MXC is not set
+# CONFIG_MMC_MXS is not set
+# CONFIG_MMC_PCI is not set
+# CONFIG_MMC_OMAP_HS is not set
+CONFIG_MMC_SDHCI=y
+CONFIG_MMC_SDHCI_SDMA=y
+# CONFIG_MMC_SDHCI_CADENCE is not set
+# CONFIG_MMC_SDHCI_KONA is not set
+# CONFIG_MMC_SDHCI_MSM is not set
+CONFIG_MMC_SDHCI_S5P=y
+# CONFIG_MMC_SDHCI_SPEAR is not set
+# CONFIG_MMC_SDHCI_STI is not set
+# CONFIG_MMC_SDHCI_XENON is not set
+# CONFIG_MMC_SDHCI_TANGIER is not set
+# CONFIG_STM32_SDMMC2 is not set
+
+#
+# MTD Support
+#
+# CONFIG_MTD is not set
+# CONFIG_MTD_NOR_FLASH is not set
+# CONFIG_NAND is not set
+
+#
+# SPI Flash Support
+#
+CONFIG_DM_SPI_FLASH=y
+# CONFIG_SPI_FLASH is not set
+
+#
+# UBI support
+#
+# CONFIG_MTD_UBI is not set
+# CONFIG_BITBANGMII is not set
+# CONFIG_MV88E6352_SWITCH is not set
+# CONFIG_PHYLIB is not set
+# CONFIG_DM_ETH is not set
+# CONFIG_PCI is not set
+
+#
+# PHY Subsystem
+#
+# CONFIG_PHY is not set
+# CONFIG_SPL_PHY is not set
+# CONFIG_MVEBU_COMPHY_SUPPORT is not set
+
+#
+# Pin controllers
+#
+# CONFIG_PINCTRL is not set
+
+#
+# Power
+#
+
+#
+# Power Domain Support
+#
+# CONFIG_POWER_DOMAIN is not set
+# CONFIG_DM_PMIC is not set
+# CONFIG_PMIC_AS3722 is not set
+# CONFIG_POWER_MC34VR500 is not set
+# CONFIG_DM_REGULATOR is not set
+# CONFIG_DM_PWM is not set
+# CONFIG_PWM_SANDBOX is not set
+# CONFIG_RAM is not set
+
+#
+# Remote Processor drivers
+#
+
+#
+# Reset Controller Support
+#
+# CONFIG_DM_RESET is not set
+
+#
+# Real Time Clock
+#
+# CONFIG_DM_RTC is not set
+# CONFIG_SCSI is not set
+# CONFIG_DM_SCSI is not set
+
+#
+# Serial drivers
+#
+CONFIG_BAUDRATE=115200
+CONFIG_REQUIRE_SERIAL_CONSOLE=y
+CONFIG_SERIAL_PRESENT=y
+CONFIG_SPL_SERIAL_PRESENT=y
+CONFIG_DM_SERIAL=y
+# CONFIG_SERIAL_RX_BUFFER is not set
+CONFIG_SPL_DM_SERIAL=y
+# CONFIG_TPL_DM_SERIAL is not set
+# CONFIG_DEBUG_UART_ALTERA_JTAGUART is not set
+# CONFIG_DEBUG_UART_ALTERA_UART is not set
+# CONFIG_DEBUG_UART_ATMEL is not set
+# CONFIG_DEBUG_UART_NS16550 is not set
+CONFIG_DEBUG_UART_S5P=y
+# CONFIG_DEBUG_UART_UARTLITE is not set
+# CONFIG_DEBUG_UART_ARM_DCC is not set
+# CONFIG_DEBUG_MVEBU_A3700_UART is not set
+# CONFIG_DEBUG_UART_ZYNQ is not set
+# CONFIG_DEBUG_UART_PL010 is not set
+# CONFIG_DEBUG_UART_PL011 is not set
+# CONFIG_DEBUG_UART_OMAP is not set
+CONFIG_DEBUG_UART_BASE=0x13820000
+CONFIG_DEBUG_UART_CLOCK=100000000
+CONFIG_DEBUG_UART_SHIFT=0
+# CONFIG_DEBUG_UART_BOARD_INIT is not set
+# CONFIG_DEBUG_UART_ANNOUNCE is not set
+# CONFIG_DEBUG_UART_SKIP_INIT is not set
+# CONFIG_ALTERA_JTAG_UART is not set
+# CONFIG_ALTERA_UART is not set
+# CONFIG_ATMEL_USART is not set
+# CONFIG_FSL_LPUART is not set
+# CONFIG_MVEBU_A3700_UART is not set
+# CONFIG_NULLDEV_SERIAL is not set
+# CONFIG_SYS_NS16550 is not set
+# CONFIG_MSM_SERIAL is not set
+# CONFIG_PXA_SERIAL is not set
+
+#
+# Sound support
+#
+# CONFIG_SOUND is not set
+
+#
+# SPI Support
+#
+CONFIG_DM_SPI=y
+# CONFIG_ALTERA_SPI is not set
+# CONFIG_CADENCE_QSPI is not set
+# CONFIG_DESIGNWARE_SPI is not set
+# CONFIG_EXYNOS_SPI is not set
+# CONFIG_FSL_DSPI is not set
+# CONFIG_ICH_SPI is not set
+# CONFIG_MVEBU_A3700_SPI is not set
+# CONFIG_ROCKCHIP_SPI is not set
+# CONFIG_TEGRA114_SPI is not set
+# CONFIG_TEGRA20_SFLASH is not set
+# CONFIG_TEGRA20_SLINK is not set
+# CONFIG_TEGRA210_QSPI is not set
+# CONFIG_XILINX_SPI is not set
+# CONFIG_SOFT_SPI is not set
+# CONFIG_FSL_ESPI is not set
+# CONFIG_FSL_QSPI is not set
+# CONFIG_NDS_AE3XX_SPI is not set
+# CONFIG_TI_QSPI is not set
+# CONFIG_OMAP3_SPI is not set
+
+#
+# SPMI support
+#
+# CONFIG_SPMI is not set
+
+#
+# System reset device drivers
+#
+# CONFIG_SYSRESET is not set
+# CONFIG_SYSRESET_SYSCON is not set
+# CONFIG_SYSRESET_WATCHDOG is not set
+# CONFIG_DM_THERMAL is not set
+
+#
+# Timer Support
+#
+# CONFIG_TIMER is not set
+
+#
+# TPM support
+#
+CONFIG_USB=y
+CONFIG_DM_USB=y
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_XHCI_HCD is not set
+# CONFIG_USB_EHCI_HCD is not set
+# CONFIG_USB_OHCI_HCD is not set
+# CONFIG_USB_UHCI_HCD is not set
+# CONFIG_USB_DWC2 is not set
+# CONFIG_USB_DWC3 is not set
+
+#
+# MUSB Controller Driver
+#
+# CONFIG_USB_MUSB_HOST is not set
+# CONFIG_USB_MUSB_GADGET is not set
+# CONFIG_USB_MUSB_TI is not set
+
+#
+# ULPI drivers
+#
+
+#
+# USB peripherals
+#
+CONFIG_USB_STORAGE=y
+CONFIG_USB_KEYBOARD=y
+# CONFIG_SYS_USB_EVENT_POLL is not set
+# CONFIG_SYS_USB_EVENT_POLL_VIA_INT_QUEUE is not set
+CONFIG_SYS_USB_EVENT_POLL_VIA_CONTROL_EP=y
+CONFIG_USB_GADGET=y
+CONFIG_USB_GADGET_MANUFACTURER="Freescale"
+CONFIG_USB_GADGET_VENDOR_NUM=0x18d1
+CONFIG_USB_GADGET_PRODUCT_NUM=0x4e30
+# CONFIG_USB_GADGET_ATMEL_USBA is not set
+# CONFIG_USB_GADGET_BCM_UDC_OTG_PHY is not set
+CONFIG_USB_GADGET_DWC2_OTG=y
+# CONFIG_USB_GADGET_DWC2_OTG_PHY_BUS_WIDTH_8 is not set
+# CONFIG_CI_UDC is not set
+CONFIG_USB_GADGET_VBUS_DRAW=2
+CONFIG_USB_GADGET_DUALSPEED=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_USB_FUNCTION_SDP=y
+CONFIG_USB_ETHER=y
+# CONFIG_USB_ETH_CDC is not set
+CONFIG_USB_ETH_RNDIS=y
+CONFIG_USBNET_DEVADDR="de:ad:be:ef:00:01"
+CONFIG_USBNET_HOST_ADDR="de:ad:be:ef:00:00"
+# CONFIG_USB_HOST_ETHER is not set
+
+#
+# Graphics support
+#
+# CONFIG_DM_VIDEO is not set
+CONFIG_SYS_WHITE_ON_BLACK=y
+# CONFIG_NO_FB_CLEAR is not set
+
+#
+# TrueType Fonts
+#
+# CONFIG_VIDEO_VESA is not set
+# CONFIG_VIDEO_LCD_ANX9804 is not set
+# CONFIG_VIDEO_LCD_SSD2828 is not set
+# CONFIG_VIDEO_MVEBU is not set
+# CONFIG_I2C_EDID is not set
+# CONFIG_DISPLAY is not set
+# CONFIG_VIDEO_TEGRA20 is not set
+# CONFIG_VIDEO_BRIDGE is not set
+# CONFIG_VIDEO is not set
+# CONFIG_LCD is not set
+# CONFIG_VIDEO_SIMPLE is not set
+# CONFIG_VIDEO_DT_SIMPLEFB is not set
+
+#
+# Watchdog Timer Support
+#
+# CONFIG_BCM2835_WDT is not set
+# CONFIG_ULP_WATCHDOG is not set
+# CONFIG_WDT is not set
+# CONFIG_PHYS_TO_BUS is not set
+
+#
+# File systems
+#
+# CONFIG_FS_BTRFS is not set
+# CONFIG_FS_CBFS is not set
+CONFIG_FS_FAT=y
+CONFIG_FAT_WRITE=y
+CONFIG_FS_FAT_MAX_CLUSTSIZE=65536
+# CONFIG_FS_JFFS2 is not set
+# CONFIG_FS_CRAMFS is not set
+# CONFIG_YAFFS2 is not set
+
+#
+# Library routines
+#
+# CONFIG_BCH is not set
+# CONFIG_CC_OPTIMIZE_LIBS_FOR_SPEED is not set
+CONFIG_HAVE_PRIVATE_LIBGCC=y
+CONFIG_USE_PRIVATE_LIBGCC=y
+CONFIG_SYS_HZ=1000
+# CONFIG_USE_TINY_PRINTF is not set
+# CONFIG_REGEX is not set
+# CONFIG_LIB_RAND is not set
+# CONFIG_SPL_TINY_MEMSET is not set
+# CONFIG_TPL_TINY_MEMSET is not set
+# CONFIG_CMD_DHRYSTONE is not set
+
+#
+# Security support
+#
+# CONFIG_AES is not set
+# CONFIG_RSA is not set
+# CONFIG_TPM is not set
+
+#
+# Hashing Support
+#
+# CONFIG_SHA1 is not set
+# CONFIG_SHA256 is not set
+# CONFIG_SHA_HW_ACCEL is not set
+
+#
+# Compression Support
+#
+# CONFIG_LZ4 is not set
+# CONFIG_LZMA is not set
+# CONFIG_LZO is not set
+# CONFIG_SPL_LZO is not set
+# CONFIG_SPL_GZIP is not set
+# CONFIG_ERRNO_STR is not set
+CONFIG_OF_LIBFDT=y
+# CONFIG_OF_LIBFDT_OVERLAY is not set
+# CONFIG_SPL_OF_LIBFDT is not set
+# CONFIG_FDT_FIXUP_PARTITIONS is not set
+
+#
+# System tables
+#
+CONFIG_GENERATE_SMBIOS_TABLE=y
+CONFIG_SMBIOS_MANUFACTURER="samsung"
+CONFIG_EFI_LOADER=y
+# CONFIG_UNIT_TEST is not set
diff -urN u-boot-2017.11/config_new u-boot-2017.11-itop4412/config_new
--- u-boot-2017.11/config_new	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-2017.11-itop4412/config_new	2019-02-16 09:21:13.000000000 +0800
@@ -0,0 +1,1073 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# U-Boot 2017.11 Configuration
+#
+CONFIG_CREATE_ARCH_SYMLINK=y
+# CONFIG_ARC is not set
+CONFIG_ARM=y
+# CONFIG_M68K is not set
+# CONFIG_MICROBLAZE is not set
+# CONFIG_MIPS is not set
+# CONFIG_NDS32 is not set
+# CONFIG_NIOS2 is not set
+# CONFIG_PPC is not set
+# CONFIG_SANDBOX is not set
+# CONFIG_SH is not set
+# CONFIG_X86 is not set
+# CONFIG_XTENSA is not set
+CONFIG_SYS_ARCH="arm"
+CONFIG_SYS_CPU="armv7"
+CONFIG_SYS_SOC="exynos"
+CONFIG_SYS_VENDOR="samsung"
+CONFIG_SYS_BOARD="itop4412"
+CONFIG_SYS_CONFIG_NAME="itop4412"
+
+#
+# ARM architecture
+#
+CONFIG_HAS_VBAR=y
+CONFIG_HAS_THUMB2=y
+CONFIG_ARM_ASM_UNIFIED=y
+CONFIG_CPU_V7=y
+CONFIG_SYS_ARM_ARCH=7
+CONFIG_SYS_CACHE_SHIFT_6=y
+CONFIG_SYS_CACHELINE_SIZE=64
+# CONFIG_ARM_SMCCC is not set
+# CONFIG_SEMIHOSTING is not set
+# CONFIG_SYS_THUMB_BUILD is not set
+# CONFIG_SPL_SYS_THUMB_BUILD is not set
+# CONFIG_SYS_L2CACHE_OFF is not set
+# CONFIG_ENABLE_ARM_SOC_BOOT0_HOOK is not set
+# CONFIG_ARM_CORTEX_CPU_IS_UP is not set
+CONFIG_USE_ARCH_MEMCPY=y
+CONFIG_SPL_USE_ARCH_MEMCPY=y
+CONFIG_USE_ARCH_MEMSET=y
+CONFIG_SPL_USE_ARCH_MEMSET=y
+# CONFIG_ARM64_SUPPORT_AARCH32 is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_TARGET_EDB93XX is not set
+# CONFIG_TARGET_ASPENITE is not set
+# CONFIG_TARGET_GPLUGD is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_KIRKWOOD is not set
+# CONFIG_ARCH_MVEBU is not set
+# CONFIG_TARGET_DEVKIT3250 is not set
+# CONFIG_TARGET_WORK_92105 is not set
+# CONFIG_TARGET_APF27 is not set
+# CONFIG_TARGET_APX4DEVKIT is not set
+# CONFIG_TARGET_XFI3 is not set
+# CONFIG_TARGET_M28EVK is not set
+# CONFIG_TARGET_MX23EVK is not set
+# CONFIG_TARGET_MX28EVK is not set
+# CONFIG_TARGET_MX23_OLINUXINO is not set
+# CONFIG_TARGET_BG0900 is not set
+# CONFIG_TARGET_SANSA_FUZE_PLUS is not set
+# CONFIG_TARGET_SC_SPS_1 is not set
+# CONFIG_ORION5X is not set
+# CONFIG_TARGET_SPEAR300 is not set
+# CONFIG_TARGET_SPEAR310 is not set
+# CONFIG_TARGET_SPEAR320 is not set
+# CONFIG_TARGET_SPEAR600 is not set
+# CONFIG_TARGET_STV0991 is not set
+# CONFIG_TARGET_X600 is not set
+# CONFIG_TARGET_IMX31_PHYCORE is not set
+# CONFIG_TARGET_IMX31_PHYCORE_EET is not set
+# CONFIG_TARGET_MX31ADS is not set
+# CONFIG_TARGET_MX31PDK is not set
+# CONFIG_TARGET_WOODBURN is not set
+# CONFIG_TARGET_WOODBURN_SD is not set
+# CONFIG_TARGET_FLEA3 is not set
+# CONFIG_TARGET_MX35PDK is not set
+# CONFIG_ARCH_BCM283X is not set
+# CONFIG_TARGET_VEXPRESS_CA15_TC2 is not set
+# CONFIG_TARGET_VEXPRESS_CA5X2 is not set
+# CONFIG_TARGET_VEXPRESS_CA9X4 is not set
+# CONFIG_TARGET_BCM23550_W1D is not set
+# CONFIG_TARGET_BCM28155_AP is not set
+# CONFIG_TARGET_BCMCYGNUS is not set
+# CONFIG_TARGET_BCMNSP is not set
+# CONFIG_TARGET_BCMNS2 is not set
+CONFIG_ARCH_EXYNOS=y
+# CONFIG_ARCH_S5PC1XX is not set
+# CONFIG_ARCH_HIGHBANK is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_KEYSTONE is not set
+# CONFIG_ARCH_OMAP2PLUS is not set
+# CONFIG_ARCH_MESON is not set
+# CONFIG_ARCH_MX25 is not set
+# CONFIG_ARCH_MX7ULP is not set
+# CONFIG_ARCH_MX7 is not set
+# CONFIG_ARCH_MX6 is not set
+CONFIG_SPL_LDSCRIPT="board/samsung/common/exynos-uboot-spl.lds"
+# CONFIG_ARCH_MX5 is not set
+# CONFIG_ARCH_QEMU is not set
+# CONFIG_ARCH_RMOBILE is not set
+# CONFIG_TARGET_S32V234EVB is not set
+# CONFIG_ARCH_SNAPDRAGON is not set
+# CONFIG_ARCH_SOCFPGA is not set
+# CONFIG_ARCH_SUNXI is not set
+# CONFIG_TARGET_TS4600 is not set
+# CONFIG_ARCH_VF610 is not set
+# CONFIG_ARCH_ZYNQ is not set
+# CONFIG_ARCH_ZYNQMP is not set
+# CONFIG_TEGRA is not set
+# CONFIG_TARGET_VEXPRESS64_AEMV8A is not set
+# CONFIG_TARGET_VEXPRESS64_BASE_FVP is not set
+# CONFIG_TARGET_VEXPRESS64_BASE_FVP_DRAM is not set
+# CONFIG_TARGET_VEXPRESS64_JUNO is not set
+# CONFIG_TARGET_LS2080A_EMU is not set
+# CONFIG_TARGET_LS2080A_SIMU is not set
+# CONFIG_TARGET_LS1088AQDS is not set
+# CONFIG_TARGET_LS2080AQDS is not set
+# CONFIG_TARGET_LS2080ARDB is not set
+# CONFIG_TARGET_LS2081ARDB is not set
+# CONFIG_TARGET_HIKEY is not set
+# CONFIG_TARGET_POPLAR is not set
+# CONFIG_TARGET_LS1012AQDS is not set
+# CONFIG_TARGET_LS1012ARDB is not set
+# CONFIG_TARGET_LS1012AFRDM is not set
+# CONFIG_TARGET_LS1088ARDB is not set
+# CONFIG_TARGET_LS1021AQDS is not set
+# CONFIG_TARGET_LS1021ATWR is not set
+# CONFIG_TARGET_LS1021AIOT is not set
+# CONFIG_TARGET_LS1043AQDS is not set
+# CONFIG_TARGET_LS1043ARDB is not set
+# CONFIG_TARGET_LS1046AQDS is not set
+# CONFIG_TARGET_LS1046ARDB is not set
+# CONFIG_TARGET_H2200 is not set
+# CONFIG_TARGET_ZIPITZ2 is not set
+# CONFIG_TARGET_COLIBRI_PXA270 is not set
+# CONFIG_ARCH_UNIPHIER is not set
+# CONFIG_STM32 is not set
+# CONFIG_ARCH_STI is not set
+# CONFIG_ARCH_ROCKCHIP is not set
+# CONFIG_TARGET_THUNDERX_88XX is not set
+# CONFIG_ARCH_ASPEED is not set
+CONFIG_ARCH_EXYNOS4=y
+# CONFIG_ARCH_EXYNOS5 is not set
+# CONFIG_ARCH_EXYNOS7 is not set
+# CONFIG_TARGET_SMDKV310 is not set
+# CONFIG_TARGET_TRATS is not set
+# CONFIG_TARGET_S5PC210_UNIVERSAL is not set
+# CONFIG_TARGET_ORIGEN is not set
+CONFIG_TARGET_ITOP4412=y
+# CONFIG_TARGET_TRATS2 is not set
+# CONFIG_TARGET_ODROID is not set
+CONFIG_SPL_GPIO_SUPPORT=y
+# CONFIG_SPL_LIBCOMMON_SUPPORT is not set
+# CONFIG_SPL_LIBGENERIC_SUPPORT is not set
+CONFIG_SYS_MALLOC_F_LEN=0x400
+# CONFIG_SPL_MMC_SUPPORT is not set
+CONFIG_SPL_SERIAL_SUPPORT=y
+# CONFIG_SPL_DRIVERS_MISC_SUPPORT is not set
+# CONFIG_SPL_LIBDISK_SUPPORT is not set
+# CONFIG_SPL_NAND_SUPPORT is not set
+# CONFIG_SPL_SPI_FLASH_SUPPORT is not set
+# CONFIG_SPL_SPI_SUPPORT is not set
+# CONFIG_SPL_WATCHDOG_SUPPORT is not set
+CONFIG_IDENT_STRING=" for itop-4412"
+# CONFIG_SPL_FAT_SUPPORT is not set
+# CONFIG_ARMV7_LPAE is not set
+# CONFIG_CMD_DEKBLOB is not set
+# CONFIG_CMD_HDMIDETECT is not set
+
+#
+# ARM debug
+#
+# CONFIG_DEBUG_LL is not set
+CONFIG_DEFAULT_DEVICE_TREE="exynos4412-itop4412"
+CONFIG_SMBIOS_PRODUCT_NAME="itop4412"
+CONFIG_DEBUG_UART=y
+# CONFIG_AHCI is not set
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+# CONFIG_DISTRO_DEFAULTS is not set
+CONFIG_SYS_MALLOC_F=y
+CONFIG_SPL_SYS_MALLOC_F_LEN=0x400
+CONFIG_TPL_SYS_MALLOC_F_LEN=0x400
+CONFIG_EXPERT=y
+CONFIG_SYS_MALLOC_CLEAR_ON_INIT=y
+# CONFIG_TOOLS_DEBUG is not set
+# CONFIG_PHYS_64BIT is not set
+
+#
+# Boot images
+#
+CONFIG_ANDROID_BOOT_IMAGE=y
+# CONFIG_FIT is not set
+# CONFIG_OF_BOARD_SETUP is not set
+# CONFIG_OF_SYSTEM_SETUP is not set
+# CONFIG_OF_STDOUT_VIA_ALIAS is not set
+CONFIG_SYS_EXTRA_OPTIONS=""
+CONFIG_ARCH_FIXUP_FDT_MEMORY=y
+
+#
+# API
+#
+# CONFIG_API is not set
+
+#
+# Boot timing
+#
+# CONFIG_BOOTSTAGE is not set
+CONFIG_BOOTSTAGE_RECORD_COUNT=30
+CONFIG_SPL_BOOTSTAGE_RECORD_COUNT=5
+CONFIG_BOOTSTAGE_STASH_ADDR=0
+CONFIG_BOOTSTAGE_STASH_SIZE=0x1000
+
+#
+# Boot media
+#
+# CONFIG_NAND_BOOT is not set
+# CONFIG_ONENAND_BOOT is not set
+# CONFIG_QSPI_BOOT is not set
+# CONFIG_SATA_BOOT is not set
+CONFIG_SD_BOOT=y
+# CONFIG_SPI_BOOT is not set
+CONFIG_BOOTDELAY=5
+# CONFIG_USE_BOOTARGS is not set
+
+#
+# Console
+#
+# CONFIG_CONSOLE_RECORD is not set
+CONFIG_LOGLEVEL=4
+CONFIG_SPL_LOGLEVEL=4
+# CONFIG_SILENT_CONSOLE is not set
+# CONFIG_PRE_CONSOLE_BUFFER is not set
+# CONFIG_CONSOLE_MUX is not set
+CONFIG_SYS_CONSOLE_IS_IN_ENV=y
+# CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE is not set
+# CONFIG_SYS_CONSOLE_ENV_OVERWRITE is not set
+CONFIG_SYS_CONSOLE_INFO_QUIET=y
+# CONFIG_SYS_STDIO_DEREGISTER is not set
+CONFIG_DEFAULT_FDT_FILE=""
+# CONFIG_VERSION_VARIABLE is not set
+CONFIG_DISPLAY_CPUINFO=y
+CONFIG_DISPLAY_BOARDINFO=y
+
+#
+# Start-up hooks
+#
+# CONFIG_ARCH_EARLY_INIT_R is not set
+# CONFIG_ARCH_MISC_INIT is not set
+CONFIG_BOARD_EARLY_INIT_F=y
+
+#
+# Security support
+#
+
+#
+# SPL / TPL
+#
+CONFIG_SUPPORT_SPL=y
+CONFIG_SPL=y
+# CONFIG_SPL_BOARD_INIT is not set
+# CONFIG_SPL_BOOTROM_SUPPORT is not set
+CONFIG_SPL_RAW_IMAGE_SUPPORT=y
+CONFIG_SPL_LEGACY_IMAGE_SUPPORT=y
+# CONFIG_SPL_SYS_MALLOC_SIMPLE is not set
+# CONFIG_TPL_SYS_MALLOC_SIMPLE is not set
+# CONFIG_SPL_STACK_R is not set
+# CONFIG_SPL_SEPARATE_BSS is not set
+# CONFIG_SPL_DISPLAY_PRINT is not set
+# CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_USE_SECTOR is not set
+# CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_USE_PARTITION is not set
+# CONFIG_SPL_CPU_SUPPORT is not set
+# CONFIG_SPL_CRYPTO_SUPPORT is not set
+# CONFIG_SPL_HASH_SUPPORT is not set
+# CONFIG_SPL_DMA_SUPPORT is not set
+# CONFIG_SPL_ENV_SUPPORT is not set
+# CONFIG_SPL_EXT_SUPPORT is not set
+# CONFIG_SPL_FPGA_SUPPORT is not set
+# CONFIG_SPL_I2C_SUPPORT is not set
+# CONFIG_SPL_MPC8XXX_INIT_DDR_SUPPORT is not set
+# CONFIG_SPL_MTD_SUPPORT is not set
+# CONFIG_SPL_MUSB_NEW_SUPPORT is not set
+# CONFIG_SPL_NET_SUPPORT is not set
+# CONFIG_SPL_NO_CPU_SUPPORT is not set
+# CONFIG_SPL_NOR_SUPPORT is not set
+# CONFIG_SPL_XIP_SUPPORT is not set
+# CONFIG_SPL_ONENAND_SUPPORT is not set
+# CONFIG_SPL_OS_BOOT is not set
+# CONFIG_SPL_PCI_SUPPORT is not set
+# CONFIG_SPL_PCH_SUPPORT is not set
+# CONFIG_SPL_POST_MEM_SUPPORT is not set
+# CONFIG_SPL_POWER_SUPPORT is not set
+# CONFIG_SPL_RAM_SUPPORT is not set
+# CONFIG_SPL_RTC_SUPPORT is not set
+# CONFIG_SPL_SATA_SUPPORT is not set
+# CONFIG_SPL_USB_HOST_SUPPORT is not set
+# CONFIG_SPL_USB_GADGET_SUPPORT is not set
+# CONFIG_SPL_YMODEM_SUPPORT is not set
+
+#
+# Command line interface
+#
+CONFIG_CMDLINE=y
+CONFIG_HUSH_PARSER=y
+CONFIG_SYS_PROMPT="u-boot # "
+
+#
+# Autoboot options
+#
+CONFIG_AUTOBOOT=y
+# CONFIG_AUTOBOOT_KEYED is not set
+
+#
+# FASTBOOT
+#
+CONFIG_FASTBOOT=y
+CONFIG_USB_FUNCTION_FASTBOOT=y
+CONFIG_CMD_FASTBOOT=y
+CONFIG_FASTBOOT_BUF_ADDR=0x70000000
+CONFIG_FASTBOOT_BUF_SIZE=0x100000
+CONFIG_FASTBOOT_USB_DEV=0
+CONFIG_FASTBOOT_FLASH=y
+CONFIG_FASTBOOT_FLASH_MMC_DEV=0
+CONFIG_FASTBOOT_GPT_NAME="gpt"
+CONFIG_FASTBOOT_MBR_NAME="mbr"
+
+#
+# Commands
+#
+
+#
+# Info commands
+#
+CONFIG_CMD_BDI=y
+# CONFIG_CMD_CONFIG is not set
+CONFIG_CMD_CONSOLE=y
+# CONFIG_CMD_CPU is not set
+# CONFIG_CMD_LICENSE is not set
+
+#
+# Boot commands
+#
+CONFIG_CMD_BOOTD=y
+CONFIG_CMD_BOOTM=y
+# CONFIG_CMD_BOOTZ is not set
+CONFIG_CMD_BOOTEFI=y
+CONFIG_CMD_BOOTEFI_HELLO_COMPILE=y
+# CONFIG_CMD_BOOTEFI_HELLO is not set
+# CONFIG_CMD_BOOTEFI_SELFTEST is not set
+# CONFIG_CMD_BOOTMENU is not set
+CONFIG_CMD_ELF=y
+CONFIG_CMD_FDT=y
+# CONFIG_CMD_GO is not set
+CONFIG_CMD_RUN=y
+CONFIG_CMD_IMI=y
+# CONFIG_CMD_IMLS is not set
+# CONFIG_CMD_XIMG is not set
+# CONFIG_CMD_POWEROFF is not set
+# CONFIG_CMD_SPL is not set
+# CONFIG_CMD_THOR_DOWNLOAD is not set
+# CONFIG_CMD_ZBOOT is not set
+
+#
+# Environment commands
+#
+# CONFIG_CMD_ASKENV is not set
+CONFIG_CMD_EXPORTENV=y
+CONFIG_CMD_IMPORTENV=y
+CONFIG_CMD_EDITENV=y
+# CONFIG_CMD_GREPENV is not set
+CONFIG_CMD_SAVEENV=y
+CONFIG_CMD_ENV_EXISTS=y
+# CONFIG_CMD_ENV_CALLBACK is not set
+# CONFIG_CMD_ENV_FLAGS is not set
+
+#
+# Memory commands
+#
+# CONFIG_CMD_CRC32 is not set
+# CONFIG_CMD_EEPROM is not set
+# CONFIG_LOOPW is not set
+# CONFIG_CMD_MD5SUM is not set
+# CONFIG_CMD_MEMINFO is not set
+# CONFIG_CMD_MEMORY is not set
+# CONFIG_CMD_MEMTEST is not set
+# CONFIG_CMD_MX_CYCLIC is not set
+# CONFIG_CMD_SHA1SUM is not set
+# CONFIG_CMD_STRINGS is not set
+
+#
+# Compression commands
+#
+# CONFIG_CMD_LZMADEC is not set
+# CONFIG_CMD_UNZIP is not set
+# CONFIG_CMD_ZIP is not set
+
+#
+# Device access commands
+#
+# CONFIG_CMD_ARMFLASH is not set
+# CONFIG_CMD_CLK is not set
+# CONFIG_CMD_DEMO is not set
+# CONFIG_CMD_DFU is not set
+# CONFIG_CMD_DM is not set
+# CONFIG_CMD_FDC is not set
+# CONFIG_CMD_FLASH is not set
+# CONFIG_CMD_FPGA is not set
+# CONFIG_CMD_FPGAD is not set
+# CONFIG_CMD_FUSE is not set
+# CONFIG_CMD_GPIO is not set
+# CONFIG_CMD_GPT is not set
+# CONFIG_RANDOM_UUID is not set
+# CONFIG_CMD_IDE is not set
+# CONFIG_CMD_IO is not set
+# CONFIG_CMD_IOTRACE is not set
+# CONFIG_CMD_I2C is not set
+# CONFIG_CMD_LOADB is not set
+# CONFIG_CMD_LOADS is not set
+CONFIG_CMD_MMC=y
+# CONFIG_CMD_NAND is not set
+# CONFIG_CMD_MMC_SPI is not set
+# CONFIG_CMD_ONENAND is not set
+# CONFIG_CMD_PART is not set
+# CONFIG_CMD_PCI is not set
+# CONFIG_CMD_PCMCIA is not set
+# CONFIG_CMD_READ is not set
+# CONFIG_CMD_SATA is not set
+# CONFIG_CMD_SAVES is not set
+# CONFIG_CMD_SDRAM is not set
+# CONFIG_CMD_SF is not set
+# CONFIG_CMD_SF_TEST is not set
+# CONFIG_CMD_SPI is not set
+# CONFIG_CMD_TSI148 is not set
+# CONFIG_CMD_UNIVERSE is not set
+CONFIG_CMD_USB=y
+# CONFIG_CMD_USB_SDP is not set
+# CONFIG_CMD_USB_MASS_STORAGE is not set
+
+#
+# Shell scripting commands
+#
+CONFIG_CMD_ECHO=y
+CONFIG_CMD_ITEST=y
+CONFIG_CMD_SOURCE=y
+CONFIG_CMD_SETEXPR=y
+
+#
+# Network commands
+#
+# CONFIG_CMD_NET is not set
+# CONFIG_CMD_TFTPPUT is not set
+# CONFIG_CMD_TFTPSRV is not set
+# CONFIG_CMD_RARP is not set
+# CONFIG_CMD_DHCP is not set
+# CONFIG_CMD_PXE is not set
+# CONFIG_CMD_NFS is not set
+# CONFIG_CMD_MII is not set
+CONFIG_CMD_PING=y
+# CONFIG_CMD_CDP is not set
+# CONFIG_CMD_SNTP is not set
+# CONFIG_CMD_DNS is not set
+# CONFIG_CMD_LINK_LOCAL is not set
+# CONFIG_CMD_ETHSW is not set
+
+#
+# Misc commands
+#
+# CONFIG_CMD_BSP is not set
+# CONFIG_CMD_BKOPS_ENABLE is not set
+CONFIG_CMD_CACHE=y
+# CONFIG_CMD_DISPLAY is not set
+# CONFIG_CMD_LED is not set
+# CONFIG_CMD_DATE is not set
+# CONFIG_CMD_TIME is not set
+# CONFIG_CMD_GETTIME is not set
+# CONFIG_CMD_MISC is not set
+# CONFIG_CMD_TIMER is not set
+# CONFIG_CMD_QFW is not set
+# CONFIG_CMD_TERMINAL is not set
+# CONFIG_CMD_UUID is not set
+
+#
+# Power commands
+#
+# CONFIG_CMD_PMIC is not set
+# CONFIG_CMD_REGULATOR is not set
+
+#
+# Security commands
+#
+# CONFIG_CMD_AES is not set
+# CONFIG_CMD_BLOB is not set
+# CONFIG_CMD_HASH is not set
+
+#
+# Firmware commands
+#
+
+#
+# Filesystem commands
+#
+# CONFIG_CMD_BTRFS is not set
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+# CONFIG_CMD_FS_UUID is not set
+# CONFIG_CMD_JFFS2 is not set
+# CONFIG_CMD_MTDPARTS is not set
+# CONFIG_CMD_REISER is not set
+# CONFIG_CMD_SCSI is not set
+# CONFIG_CMD_ZFS is not set
+
+#
+# Debug commands
+#
+# CONFIG_CMD_BEDBUG is not set
+# CONFIG_CMD_DIAG is not set
+# CONFIG_CMD_KGDB is not set
+# CONFIG_CMD_TRACE is not set
+# CONFIG_CMD_UBI is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITIONS=y
+# CONFIG_MAC_PARTITION is not set
+# CONFIG_SPL_MAC_PARTITION is not set
+CONFIG_DOS_PARTITION=y
+CONFIG_SPL_DOS_PARTITION=y
+CONFIG_ISO_PARTITION=y
+CONFIG_SPL_ISO_PARTITION=y
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_SPL_AMIGA_PARTITION is not set
+CONFIG_EFI_PARTITION=y
+CONFIG_EFI_PARTITION_ENTRIES_OFF=0
+CONFIG_SPL_EFI_PARTITION=y
+CONFIG_PARTITION_UUIDS=y
+CONFIG_SPL_PARTITION_UUIDS=y
+# CONFIG_PARTITION_TYPE_GUID is not set
+CONFIG_SUPPORT_OF_CONTROL=y
+CONFIG_DTC=y
+
+#
+# Device Tree Control
+#
+CONFIG_OF_CONTROL=y
+# CONFIG_OF_BOARD_FIXUP is not set
+# CONFIG_SPL_OF_CONTROL is not set
+# CONFIG_OF_LIVE is not set
+CONFIG_OF_SEPARATE=y
+# CONFIG_OF_EMBED is not set
+# CONFIG_OF_BOARD is not set
+# CONFIG_MULTI_DTB_FIT is not set
+CONFIG_MKIMAGE_DTC_PATH="dtc"
+
+#
+# Environment
+#
+# CONFIG_ENV_IS_NOWHERE is not set
+# CONFIG_ENV_IS_IN_EEPROM is not set
+# CONFIG_ENV_IS_IN_FAT is not set
+# CONFIG_ENV_IS_IN_FLASH is not set
+CONFIG_ENV_IS_IN_MMC=y
+# CONFIG_ENV_IS_IN_NAND is not set
+# CONFIG_ENV_IS_IN_NVRAM is not set
+# CONFIG_ENV_IS_IN_ONENAND is not set
+# CONFIG_ENV_IS_IN_REMOTE is not set
+# CONFIG_ENV_IS_IN_SPI_FLASH is not set
+# CONFIG_ENV_IS_IN_UBI is not set
+# CONFIG_ENV_AES is not set
+# CONFIG_NET is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_DM=y
+# CONFIG_SPL_DM is not set
+CONFIG_DM_WARN=y
+# CONFIG_DM_DEBUG is not set
+CONFIG_DM_DEVICE_REMOVE=y
+CONFIG_DM_STDIO=y
+CONFIG_DM_SEQ_ALIAS=y
+# CONFIG_SPL_DM_SEQ_ALIAS is not set
+# CONFIG_REGMAP is not set
+# CONFIG_DEVRES is not set
+CONFIG_SIMPLE_BUS=y
+CONFIG_OF_TRANSLATE=y
+CONFIG_DM_DEV_READ_INLINE=y
+# CONFIG_ADC is not set
+# CONFIG_ADC_EXYNOS is not set
+# CONFIG_ADC_SANDBOX is not set
+# CONFIG_SARADC_ROCKCHIP is not set
+# CONFIG_SATA is not set
+
+#
+# SATA/SCSI device support
+#
+CONFIG_BLK=y
+# CONFIG_BLOCK_CACHE is not set
+# CONFIG_IDE is not set
+
+#
+# Clock
+#
+# CONFIG_CLK is not set
+# CONFIG_CPU is not set
+
+#
+# Hardware crypto devices
+#
+# CONFIG_FSL_CAAM is not set
+# CONFIG_SYS_FSL_SEC_BE is not set
+# CONFIG_SYS_FSL_SEC_LE is not set
+
+#
+# Demo for driver model
+#
+# CONFIG_DM_DEMO is not set
+
+#
+# DFU support
+#
+
+#
+# DMA Support
+#
+# CONFIG_DMA is not set
+# CONFIG_TI_EDMA3 is not set
+
+#
+# FPGA support
+#
+# CONFIG_FPGA_ALTERA is not set
+# CONFIG_FPGA_SOCFPGA is not set
+# CONFIG_FPGA_XILINX is not set
+
+#
+# GPIO Support
+#
+CONFIG_DM_GPIO=y
+# CONFIG_ALTERA_PIO is not set
+# CONFIG_DWAPB_GPIO is not set
+# CONFIG_AT91_GPIO is not set
+# CONFIG_ATMEL_PIO4 is not set
+# CONFIG_INTEL_BROADWELL_GPIO is not set
+# CONFIG_INTEL_ICH6_GPIO is not set
+# CONFIG_IMX_RGPIO2P is not set
+# CONFIG_LPC32XX_GPIO is not set
+# CONFIG_MSM_GPIO is not set
+# CONFIG_CMD_PCA953X is not set
+# CONFIG_PCF8575_GPIO is not set
+# CONFIG_ROCKCHIP_GPIO is not set
+# CONFIG_CMD_TCA642X is not set
+# CONFIG_TEGRA_GPIO is not set
+# CONFIG_TEGRA186_GPIO is not set
+# CONFIG_VYBRID_GPIO is not set
+# CONFIG_DM_74X164 is not set
+# CONFIG_DM_PCA953X is not set
+# CONFIG_MPC85XX_GPIO is not set
+
+#
+# I2C support
+#
+CONFIG_DM_I2C=y
+# CONFIG_DM_I2C_COMPAT is not set
+# CONFIG_I2C_SET_DEFAULT_BUS_NUM is not set
+# CONFIG_DM_I2C_GPIO is not set
+# CONFIG_SYS_I2C_FSL is not set
+# CONFIG_SYS_I2C_DW is not set
+# CONFIG_SYS_I2C_INTEL is not set
+# CONFIG_SYS_I2C_IMX_LPI2C is not set
+# CONFIG_SYS_I2C_ROCKCHIP is not set
+# CONFIG_SYS_I2C_S3C24X0 is not set
+# CONFIG_SYS_I2C_MVTWSI is not set
+# CONFIG_I2C_MUX is not set
+CONFIG_DM_KEYBOARD=y
+# CONFIG_CROS_EC_KEYB is not set
+# CONFIG_I8042_KEYB is not set
+
+#
+# LED Support
+#
+# CONFIG_LED is not set
+# CONFIG_LED_STATUS is not set
+
+#
+# Mailbox Controller Support
+#
+# CONFIG_DM_MAILBOX is not set
+
+#
+# Memory Controller drivers
+#
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MISC is not set
+# CONFIG_CROS_EC is not set
+# CONFIG_DS4510 is not set
+# CONFIG_FSL_SEC_MON is not set
+# CONFIG_MXC_OCOTP is not set
+# CONFIG_NUVOTON_NCT6102D is not set
+# CONFIG_PWRSEQ is not set
+# CONFIG_PCA9551_LED is not set
+# CONFIG_WINBOND_W83627 is not set
+
+#
+# MMC Host controller Support
+#
+CONFIG_MMC=y
+CONFIG_DM_MMC=y
+# CONFIG_SPL_MMC_TINY is not set
+CONFIG_MMC_DW=y
+CONFIG_MMC_DW_EXYNOS=y
+# CONFIG_MMC_DW_K3 is not set
+# CONFIG_MMC_DW_ROCKCHIP is not set
+# CONFIG_MMC_MXC is not set
+# CONFIG_MMC_MXS is not set
+# CONFIG_MMC_PCI is not set
+# CONFIG_MMC_OMAP_HS is not set
+CONFIG_MMC_SDHCI=y
+CONFIG_MMC_SDHCI_SDMA=y
+# CONFIG_MMC_SDHCI_CADENCE is not set
+# CONFIG_MMC_SDHCI_KONA is not set
+# CONFIG_MMC_SDHCI_MSM is not set
+CONFIG_MMC_SDHCI_S5P=y
+# CONFIG_MMC_SDHCI_SPEAR is not set
+# CONFIG_MMC_SDHCI_STI is not set
+# CONFIG_MMC_SDHCI_XENON is not set
+# CONFIG_MMC_SDHCI_TANGIER is not set
+# CONFIG_STM32_SDMMC2 is not set
+
+#
+# MTD Support
+#
+# CONFIG_MTD is not set
+# CONFIG_MTD_NOR_FLASH is not set
+# CONFIG_NAND is not set
+
+#
+# SPI Flash Support
+#
+CONFIG_DM_SPI_FLASH=y
+# CONFIG_SPI_FLASH is not set
+
+#
+# UBI support
+#
+# CONFIG_MTD_UBI is not set
+# CONFIG_BITBANGMII is not set
+# CONFIG_MV88E6352_SWITCH is not set
+# CONFIG_PHYLIB is not set
+# CONFIG_DM_ETH is not set
+# CONFIG_PCI is not set
+
+#
+# PHY Subsystem
+#
+# CONFIG_PHY is not set
+# CONFIG_SPL_PHY is not set
+# CONFIG_MVEBU_COMPHY_SUPPORT is not set
+
+#
+# Pin controllers
+#
+# CONFIG_PINCTRL is not set
+
+#
+# Power
+#
+
+#
+# Power Domain Support
+#
+# CONFIG_POWER_DOMAIN is not set
+CONFIG_DM_PMIC=y
+CONFIG_PMIC_CHILDREN=y
+CONFIG_SPL_PMIC_CHILDREN=y
+# CONFIG_PMIC_ACT8846 is not set
+# CONFIG_PMIC_AS3722 is not set
+# CONFIG_DM_PMIC_PFUZE100 is not set
+# CONFIG_DM_PMIC_MAX77686 is not set
+# CONFIG_DM_PMIC_MAX8998 is not set
+# CONFIG_PMIC_MAX8997 is not set
+# CONFIG_PMIC_PM8916 is not set
+# CONFIG_PMIC_RK8XX is not set
+# CONFIG_PMIC_S2MPS11 is not set
+# CONFIG_DM_PMIC_SANDBOX is not set
+CONFIG_PMIC_S5M8767=y
+# CONFIG_PMIC_RN5T567 is not set
+# CONFIG_PMIC_TPS65090 is not set
+# CONFIG_PMIC_PALMAS is not set
+# CONFIG_PMIC_LP873X is not set
+# CONFIG_PMIC_LP87565 is not set
+# CONFIG_POWER_MC34VR500 is not set
+CONFIG_DM_REGULATOR=y
+# CONFIG_SPL_DM_REGULATOR is not set
+# CONFIG_REGULATOR_PWM is not set
+# CONFIG_DM_REGULATOR_FIXED is not set
+# CONFIG_DM_REGULATOR_GPIO is not set
+CONFIG_REGULATOR_S5M8767=y
+# CONFIG_DM_REGULATOR_PBIAS is not set
+# CONFIG_DM_PWM is not set
+# CONFIG_PWM_SANDBOX is not set
+# CONFIG_RAM is not set
+
+#
+# Remote Processor drivers
+#
+
+#
+# Reset Controller Support
+#
+# CONFIG_DM_RESET is not set
+
+#
+# Real Time Clock
+#
+# CONFIG_DM_RTC is not set
+# CONFIG_SCSI is not set
+# CONFIG_DM_SCSI is not set
+
+#
+# Serial drivers
+#
+CONFIG_BAUDRATE=115200
+CONFIG_REQUIRE_SERIAL_CONSOLE=y
+CONFIG_SERIAL_PRESENT=y
+CONFIG_SPL_SERIAL_PRESENT=y
+CONFIG_DM_SERIAL=y
+# CONFIG_SERIAL_RX_BUFFER is not set
+CONFIG_SPL_DM_SERIAL=y
+# CONFIG_TPL_DM_SERIAL is not set
+# CONFIG_DEBUG_UART_ALTERA_JTAGUART is not set
+# CONFIG_DEBUG_UART_ALTERA_UART is not set
+# CONFIG_DEBUG_UART_ATMEL is not set
+# CONFIG_DEBUG_UART_NS16550 is not set
+CONFIG_DEBUG_UART_S5P=y
+# CONFIG_DEBUG_UART_UARTLITE is not set
+# CONFIG_DEBUG_UART_ARM_DCC is not set
+# CONFIG_DEBUG_MVEBU_A3700_UART is not set
+# CONFIG_DEBUG_UART_ZYNQ is not set
+# CONFIG_DEBUG_UART_PL010 is not set
+# CONFIG_DEBUG_UART_PL011 is not set
+# CONFIG_DEBUG_UART_OMAP is not set
+CONFIG_DEBUG_UART_BASE=0x13820000
+CONFIG_DEBUG_UART_CLOCK=100000000
+CONFIG_DEBUG_UART_SHIFT=0
+# CONFIG_DEBUG_UART_BOARD_INIT is not set
+# CONFIG_DEBUG_UART_ANNOUNCE is not set
+# CONFIG_DEBUG_UART_SKIP_INIT is not set
+# CONFIG_ALTERA_JTAG_UART is not set
+# CONFIG_ALTERA_UART is not set
+# CONFIG_ATMEL_USART is not set
+# CONFIG_FSL_LPUART is not set
+# CONFIG_MVEBU_A3700_UART is not set
+# CONFIG_NULLDEV_SERIAL is not set
+# CONFIG_SYS_NS16550 is not set
+# CONFIG_MSM_SERIAL is not set
+# CONFIG_PXA_SERIAL is not set
+
+#
+# Sound support
+#
+# CONFIG_SOUND is not set
+
+#
+# SPI Support
+#
+CONFIG_DM_SPI=y
+# CONFIG_ALTERA_SPI is not set
+# CONFIG_CADENCE_QSPI is not set
+# CONFIG_DESIGNWARE_SPI is not set
+# CONFIG_EXYNOS_SPI is not set
+# CONFIG_FSL_DSPI is not set
+# CONFIG_ICH_SPI is not set
+# CONFIG_MVEBU_A3700_SPI is not set
+# CONFIG_ROCKCHIP_SPI is not set
+# CONFIG_TEGRA114_SPI is not set
+# CONFIG_TEGRA20_SFLASH is not set
+# CONFIG_TEGRA20_SLINK is not set
+# CONFIG_TEGRA210_QSPI is not set
+# CONFIG_XILINX_SPI is not set
+# CONFIG_SOFT_SPI is not set
+# CONFIG_FSL_ESPI is not set
+# CONFIG_FSL_QSPI is not set
+# CONFIG_NDS_AE3XX_SPI is not set
+# CONFIG_TI_QSPI is not set
+# CONFIG_OMAP3_SPI is not set
+
+#
+# SPMI support
+#
+# CONFIG_SPMI is not set
+
+#
+# System reset device drivers
+#
+# CONFIG_SYSRESET is not set
+# CONFIG_SYSRESET_SYSCON is not set
+# CONFIG_SYSRESET_WATCHDOG is not set
+# CONFIG_DM_THERMAL is not set
+
+#
+# Timer Support
+#
+# CONFIG_TIMER is not set
+
+#
+# TPM support
+#
+CONFIG_USB=y
+CONFIG_DM_USB=y
+
+#
+# USB Host Controller Drivers
+#
+CONFIG_USB_HOST=y
+# CONFIG_USB_XHCI_HCD is not set
+CONFIG_USB_EHCI_HCD=y
+# CONFIG_USB_EHCI_MSM is not set
+# CONFIG_USB_EHCI_PCI is not set
+# CONFIG_USB_EHCI_GENERIC is not set
+# CONFIG_USB_OHCI_HCD is not set
+# CONFIG_USB_UHCI_HCD is not set
+# CONFIG_USB_DWC2 is not set
+# CONFIG_USB_DWC3 is not set
+
+#
+# MUSB Controller Driver
+#
+# CONFIG_USB_MUSB_HOST is not set
+# CONFIG_USB_MUSB_GADGET is not set
+# CONFIG_USB_MUSB_TI is not set
+
+#
+# ULPI drivers
+#
+
+#
+# USB peripherals
+#
+# CONFIG_USB_STORAGE is not set
+# CONFIG_USB_KEYBOARD is not set
+CONFIG_USB_GADGET=y
+CONFIG_USB_GADGET_MANUFACTURER="Samsung"
+CONFIG_USB_GADGET_VENDOR_NUM=0x18d1
+CONFIG_USB_GADGET_PRODUCT_NUM=0x4e30
+# CONFIG_USB_GADGET_ATMEL_USBA is not set
+# CONFIG_USB_GADGET_BCM_UDC_OTG_PHY is not set
+CONFIG_USB_GADGET_DWC2_OTG=y
+# CONFIG_USB_GADGET_DWC2_OTG_PHY_BUS_WIDTH_8 is not set
+# CONFIG_CI_UDC is not set
+CONFIG_USB_GADGET_VBUS_DRAW=2
+CONFIG_USB_GADGET_DUALSPEED=y
+CONFIG_USB_GADGET_DOWNLOAD=y
+# CONFIG_USB_FUNCTION_SDP is not set
+CONFIG_USB_ETHER=y
+# CONFIG_USB_ETH_CDC is not set
+CONFIG_USB_ETH_RNDIS=y
+CONFIG_USBNET_DEVADDR="de:ad:be:ef:00:01"
+CONFIG_USBNET_HOST_ADDR="de:ad:be:ef:00:00"
+# CONFIG_USB_HOST_ETHER is not set
+
+#
+# Graphics support
+#
+# CONFIG_DM_VIDEO is not set
+CONFIG_SYS_WHITE_ON_BLACK=y
+# CONFIG_NO_FB_CLEAR is not set
+
+#
+# TrueType Fonts
+#
+# CONFIG_VIDEO_VESA is not set
+# CONFIG_VIDEO_LCD_ANX9804 is not set
+# CONFIG_VIDEO_LCD_SSD2828 is not set
+# CONFIG_VIDEO_MVEBU is not set
+# CONFIG_I2C_EDID is not set
+# CONFIG_DISPLAY is not set
+# CONFIG_VIDEO_TEGRA20 is not set
+# CONFIG_VIDEO_BRIDGE is not set
+# CONFIG_VIDEO is not set
+# CONFIG_LCD is not set
+# CONFIG_VIDEO_SIMPLE is not set
+# CONFIG_VIDEO_DT_SIMPLEFB is not set
+
+#
+# Watchdog Timer Support
+#
+# CONFIG_BCM2835_WDT is not set
+# CONFIG_ULP_WATCHDOG is not set
+# CONFIG_WDT is not set
+# CONFIG_PHYS_TO_BUS is not set
+
+#
+# File systems
+#
+# CONFIG_FS_BTRFS is not set
+# CONFIG_FS_CBFS is not set
+CONFIG_FS_FAT=y
+CONFIG_FAT_WRITE=y
+CONFIG_FS_FAT_MAX_CLUSTSIZE=65536
+# CONFIG_FS_JFFS2 is not set
+# CONFIG_FS_CRAMFS is not set
+# CONFIG_YAFFS2 is not set
+
+#
+# Library routines
+#
+# CONFIG_BCH is not set
+# CONFIG_CC_OPTIMIZE_LIBS_FOR_SPEED is not set
+CONFIG_HAVE_PRIVATE_LIBGCC=y
+CONFIG_USE_PRIVATE_LIBGCC=y
+CONFIG_SYS_HZ=1000
+# CONFIG_USE_TINY_PRINTF is not set
+# CONFIG_REGEX is not set
+# CONFIG_LIB_RAND is not set
+# CONFIG_SPL_TINY_MEMSET is not set
+# CONFIG_TPL_TINY_MEMSET is not set
+# CONFIG_CMD_DHRYSTONE is not set
+
+#
+# Security support
+#
+# CONFIG_AES is not set
+# CONFIG_RSA is not set
+# CONFIG_TPM is not set
+
+#
+# Hashing Support
+#
+# CONFIG_SHA1 is not set
+# CONFIG_SHA256 is not set
+# CONFIG_SHA_HW_ACCEL is not set
+
+#
+# Compression Support
+#
+# CONFIG_LZ4 is not set
+# CONFIG_LZMA is not set
+# CONFIG_LZO is not set
+# CONFIG_SPL_LZO is not set
+# CONFIG_SPL_GZIP is not set
+# CONFIG_ERRNO_STR is not set
+CONFIG_OF_LIBFDT=y
+# CONFIG_OF_LIBFDT_OVERLAY is not set
+# CONFIG_SPL_OF_LIBFDT is not set
+# CONFIG_FDT_FIXUP_PARTITIONS is not set
+
+#
+# System tables
+#
+CONFIG_GENERATE_SMBIOS_TABLE=y
+CONFIG_SMBIOS_MANUFACTURER="samsung"
+CONFIG_EFI_LOADER=y
+# CONFIG_UNIT_TEST is not set
diff -urN u-boot-2017.11/configs/itop4412_defconfig u-boot-2017.11-itop4412/configs/itop4412_defconfig
--- u-boot-2017.11/configs/itop4412_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-2017.11-itop4412/configs/itop4412_defconfig	2019-02-16 09:21:58.000000000 +0800
@@ -0,0 +1,66 @@
+CONFIG_ARM=y
+CONFIG_ARCH_EXYNOS=y
+CONFIG_ARCH_EXYNOS4=y
+CONFIG_TARGET_ITOP4412=y
+CONFIG_SPL_GPIO_SUPPORT=y
+CONFIG_SPL_SERIAL_SUPPORT=y
+CONFIG_IDENT_STRING=" for itop-4412"
+CONFIG_DEFAULT_DEVICE_TREE="exynos4412-itop4412"
+CONFIG_DEBUG_UART=y
+CONFIG_SD_BOOT=y
+CONFIG_BOOTDELAY=5
+CONFIG_SYS_CONSOLE_IS_IN_ENV=y
+CONFIG_SYS_CONSOLE_INFO_QUIET=y
+CONFIG_SPL=y
+CONFIG_HUSH_PARSER=y
+CONFIG_SYS_PROMPT="u-boot # "
+CONFIG_FASTBOOT=y
+CONFIG_FASTBOOT_BUF_ADDR=0x70000000
+CONFIG_FASTBOOT_BUF_SIZE=0x100000
+CONFIG_FASTBOOT_FLASH=y
+CONFIG_FASTBOOT_FLASH_MMC_DEV=0
+# CONFIG_CMD_GO is not set
+# CONFIG_CMD_XIMG is not set
+# CONFIG_CMD_CRC32 is not set
+# CONFIG_CMD_MEMORY is not set
+# CONFIG_CMD_DM is not set
+# CONFIG_CMD_FLASH is not set
+# CONFIG_CMD_FPGA is not set
+# CONFIG_CMD_LOADB is not set
+# CONFIG_CMD_LOADS is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_USB=y
+# CONFIG_CMD_NET is not set
+# CONFIG_CMD_NFS is not set
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+# CONFIG_CMD_MISC is not set
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_ISO_PARTITION=y
+CONFIG_EFI_PARTITION=y
+CONFIG_OF_CONTROL=y
+CONFIG_DM_MMC=y
+CONFIG_MMC_DW=y
+CONFIG_MMC_SDHCI=y
+CONFIG_MMC_SDHCI_SDMA=y
+CONFIG_MMC_SDHCI_S5P=y
+CONFIG_DM_PMIC=y
+CONFIG_PMIC_S5M8767=y
+CONFIG_DM_REGULATOR=y
+CONFIG_REGULATOR_S5M8767=y
+CONFIG_DEBUG_UART_S5P=y
+CONFIG_DEBUG_UART_BASE=0x13820000
+CONFIG_DEBUG_UART_CLOCK=100000000
+CONFIG_USB=y
+CONFIG_DM_USB=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_GADGET=y
+CONFIG_USB_GADGET_MANUFACTURER="Samsung"
+CONFIG_USB_GADGET_VENDOR_NUM=0x18d1
+CONFIG_USB_GADGET_PRODUCT_NUM=0x4e30
+CONFIG_USB_GADGET_DWC2_OTG=y
+CONFIG_USB_ETHER=y
diff -urN u-boot-2017.11/drivers/usb/gadget/f_fastboot.c u-boot-2017.11-itop4412/drivers/usb/gadget/f_fastboot.c
--- u-boot-2017.11/drivers/usb/gadget/f_fastboot.c	2017-11-14 09:08:06.000000000 +0800
+++ u-boot-2017.11-itop4412/drivers/usb/gadget/f_fastboot.c	2019-02-25 12:22:00.000000000 +0800
@@ -21,6 +21,7 @@
 #include <linux/compiler.h>
 #include <version.h>
 #include <g_dnl.h>
+#include <decompress_ext4.h>
 #ifdef CONFIG_FASTBOOT_FLASH_MMC_DEV
 #include <fb_mmc.h>
 #endif
@@ -45,6 +46,13 @@
  * that expect bulk OUT requests to be divisible by maxpacket size.
  */
 
+int do_mmcops(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[]);
+int do_mmc_write(cmd_tbl_t *cmdtp, int flag,int argc, char * const argv[]);
+int do_mem_md(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[]);
+int do_mmc_dev(cmd_tbl_t *cmdtp, int flag,int argc, char * const argv[]);
+int get_mmcinfo_capacity();
+//int get_mmcinfo_capacity(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[]);
+
 struct f_fastboot {
 	struct usb_function usb_function;
 
@@ -586,11 +594,106 @@
 }
 
 #ifdef CONFIG_FASTBOOT_FLASH
+#define SECTOR_BITS             9       /* 512B */
+#define ext4_printf(args, ...)
+
+int write_raw_chunk(char* data, unsigned int sector, unsigned int sector_size) {
+        char run_cmd[64];
+        int err ;
+        ext4_printf("write raw data in %d size %d \n", sector, sector_size);
+        sprintf(run_cmd,"mmc write  0x%x 0x%x 0x%x",(int)data, sector, sector_size);
+        err = run_command(run_cmd, 0);
+
+
+        return (1-err); //mj
+}
+int write_compressed_ext4(char* img_base, unsigned int sector_base) {
+        unsigned int sector_size;
+        int total_chunks;
+        ext4_chunk_header *chunk_header;
+        ext4_file_header *file_header;
+        int err;
+
+        file_header = (ext4_file_header*)img_base;
+        total_chunks = file_header->total_chunks;
+
+        ext4_printf("total chunk = %d \n", total_chunks);
+
+        img_base += EXT4_FILE_HEADER_SIZE;
+
+        while(total_chunks) {
+                chunk_header = (ext4_chunk_header*)img_base;
+                sector_size = (chunk_header->chunk_size * file_header->block_size) >> SECTOR_BITS;
+
+                switch(chunk_header->type)
+                {
+                case EXT4_CHUNK_TYPE_RAW:
+                        ext4_printf("raw_chunk \n");
+                        err = write_raw_chunk(img_base + EXT4_CHUNK_HEADER_SIZE,
+                                                        sector_base, sector_size);
+                        //if(err)//mj for emergency
+                        //{
+                          //      printf("[ERROR] System image write fail.please try again..\n");
+                            //    return err;
+                        //}
+                        //else
+                        //{
+                                sector_base += sector_size;
+                                break;
+                        //}
+                case EXT4_CHUNK_TYPE_FILL:
+                        ext4_printf("fill_chunk \n");
+                        sector_base += sector_size;
+                        break;
+
+                case EXT4_CHUNK_TYPE_NONE:
+                        ext4_printf("none chunk \n");
+                        sector_base += sector_size;
+                        break;
+
+                default:
+                        ext4_printf("unknown chunk type \n");
+                        sector_base += sector_size;
+                        break;
+                }
+                total_chunks--;
+                ext4_printf("remain chunks = %d \n", total_chunks);
+
+                img_base += chunk_header->total_size;
+        };
+
+        ext4_printf("write done \n");
+        return 0;
+}
+
 static void cb_flash(struct usb_ep *ep, struct usb_request *req)
 {
 	char *cmd = req->buf;
 	char response[FASTBOOT_RESPONSE_LEN];
 
+	char *argv[2]  = { "md","40000000"};
+        char *open_emmc[2]  = { "open","   "};
+        char *close_emmc[2]  = { "close","   "};
+        char *argv_uboot[5]  = { "mmc","write", "40000000","0","40e"};
+        char *argv_kernel[5]  = { "mmc","write", "40000000","460","3000"};
+        char *argv_dtb[5]  = { "mmc","write", "40000000","3460","a0"};
+        char *argv_system[5]  = { "mmc","write", "40000000","aeed","a000"};
+
+        static cmd_tbl_t cmdtp;
+        char value[] = {"mmc"};
+        //char run_cmd[64];
+
+        unsigned int addr = 0x40000000;
+        unsigned int start_8G = 0xaeed;
+        unsigned int start_16G = 0x8000;
+
+        cmdtp.name = &value;
+        cmdtp.maxargs = 29;
+        cmdtp.repeatable = 1;
+        cmdtp.cmd = do_mmc_write;
+        cmdtp.usage = NULL;
+
+
 	strsep(&cmd, ":");
 	if (!cmd) {
 		pr_err("missing partition name");
@@ -601,10 +704,37 @@
 	/* initialize the response buffer */
 	fb_response_str = response;
 
-	fastboot_fail("no flash device defined");
+//	fastboot_fail("no flash device defined");
 #ifdef CONFIG_FASTBOOT_FLASH_MMC_DEV
-	fb_mmc_flash_write(cmd, (void *)CONFIG_FASTBOOT_BUF_ADDR,
-			   download_bytes);
+//	fb_mmc_flash_write(cmd, (void *)CONFIG_FASTBOOT_BUF_ADDR,
+//			   download_bytes);
+	if(strstr(cmd,"bootloader") != NULL)
+        {
+                printf("---%s---\n",cmd);
+                do_mmc_dev(NULL,0,2,open_emmc);//open emmc
+                do_mmcops(&cmdtp,0,5,argv_uboot);
+                do_mmc_dev(NULL,0,2,close_emmc);//close emmc
+        }else if(strstr(cmd, "kernel") != NULL)
+        {
+                printf("---%s---\n",cmd);
+                do_mmcops(&cmdtp,0,5,argv_kernel);
+        }else if(strstr(cmd,"dtb") != NULL)
+        {
+                printf("---%s---\n",cmd);
+                do_mmcops(&cmdtp,0,5,argv_dtb);
+        }else if(strstr(cmd,"system") != NULL)
+        {
+                printf("---%s---\n",cmd);
+
+        //      do_mmcops(&cmdtp,0,5,argv_system);
+		if(get_mmcinfo_capacity() > 8){
+			write_compressed_ext4((char *)addr,start_16G);
+		}
+		else{
+			write_compressed_ext4((char *)addr,start_8G);
+		}
+        }
+
 #endif
 #ifdef CONFIG_FASTBOOT_FLASH_NAND_DEV
 	fb_nand_flash_write(cmd,
diff -urN u-boot-2017.11/env/common.c u-boot-2017.11-itop4412/env/common.c
--- u-boot-2017.11/env/common.c	2017-11-14 09:08:06.000000000 +0800
+++ u-boot-2017.11-itop4412/env/common.c	2019-02-16 09:21:30.000000000 +0800
@@ -162,7 +162,6 @@
 		uint32_t crc;
 
 		memcpy(&crc, &ep->crc, sizeof(crc));
-
 		if (crc32(0, ep->data, ENV_SIZE) != crc) {
 			set_default_env("!bad CRC");
 			return 0;
diff -urN u-boot-2017.11/env/mmc.c u-boot-2017.11-itop4412/env/mmc.c
--- u-boot-2017.11/env/mmc.c	2017-11-14 09:08:06.000000000 +0800
+++ u-boot-2017.11-itop4412/env/mmc.c	2019-02-16 09:21:30.000000000 +0800
@@ -17,6 +17,7 @@
 #include <mmc.h>
 #include <search.h>
 #include <errno.h>
+#include <asm/arch/power.h>
 
 #if defined(CONFIG_ENV_SIZE_REDUND) &&  \
 	(CONFIG_ENV_SIZE_REDUND != CONFIG_ENV_SIZE)
@@ -71,6 +72,13 @@
 
 __weak int mmc_get_env_dev(void)
 {
+	unsigned int boot_mode;
+
+	boot_mode = get_boot_mode();
+	if (boot_mode == BOOT_MODE_SD)
+		return 1;
+	else if (boot_mode == BOOT_MODE_EMMC_SD)
+		return 0;
 	return CONFIG_SYS_MMC_ENV_DEV;
 }
 
diff -urN u-boot-2017.11/include/autoconf.mk u-boot-2017.11-itop4412/include/autoconf.mk
--- u-boot-2017.11/include/autoconf.mk	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-2017.11-itop4412/include/autoconf.mk	2019-02-16 11:32:11.000000000 +0800
@@ -0,0 +1,92 @@
+CONFIG_BOOTM_NETBSD=y
+CONFIG_BOOTCOMMAND="if mmc rescan; then echo SD/MMC found on device ${mmcdev};if run loadbootenv; then echo Loaded environment from ${bootenv};run importbootenv;fi;if test -n $uenvcmd; then echo Running uenvcmd ...;run uenvcmd;fi;if run loadbootscript; then run bootscript; fi; fi;mmc read ${loadaddr} 0x460 0x3000; mmc read ${dtb_addr} 0x3460 0xa0; bootm ${loadaddr} - ${dtb_addr}load mmc ${mmcdev} ${loadaddr} uImage; load mmc ${mmcdev} ${dtb_addr} ${dtb_name}; bootm ${loadaddr} - ${dtb_addr}"
+CONFIG_SYS_CLK_FREQ=24000000
+CONFIG_BOOTM_VXWORKS=y
+CONFIG_SYS_MEM_TOP_HIDE="(1 << 20)"
+CONFIG_EXTRA_ENV_ITB="loadkernel=load mmc ${mmcbootdev}:${mmcbootpart} ${kerneladdr} ${kernelname}0loadinitrd=load mmc ${mmcbootdev}:${mmcbootpart} ${initrdaddr} ${initrdname}0loaddtb=load mmc ${mmcbootdev}:${mmcbootpart} ${fdtaddr} ${fdtfile}0check_ramdisk=if run loadinitrd; then setenv initrd_addr ${initrdaddr};else setenv initrd_addr -;fi;0check_dtb=if run loaddtb; then setenv fdt_addr ${fdtaddr};else setenv fdt_addr;fi;0kernel_args=setenv bootargs root=/dev/mmcblk${mmcdev}p${mmcrootpart} ${lpj} rootwait ${console} ${meminfo} ${opts} ${lcdinfo};0boot_fit=setenv kerneladdr 0x42000000;setenv kernelname Image.itb;run loadkernel;run kernel_args;bootm ${kerneladdr}#${board_name}0boot_uimg=setenv kerneladdr 0x40007FC0;setenv kernelname uImage;run check_dtb;run check_ramdisk;run loadkernel;run kernel_args;bootm ${kerneladdr} ${initrd_addr} ${fdt_addr};0boot_zimg=setenv kerneladdr 0x40007FC0;setenv kernelname zImage;run check_dtb;run check_ramdisk;run loadkernel;run kernel_args;bootz ${kerneladdr} ${initrd_addr} ${fdt_addr};0autoboot=if test -e mmc ${mmcdev}:${mmcbootpart} Image.itb; then; run boot_fit;elif test -e mmc ${mmcdev}:${mmcbootpart} zImage; then; run boot_zimg;elif test -e mmc ${mmcdev}:${mmcbootpart} uImage; then; run boot_uimg;fi;0"
+CONFIG_SYS_LONGHELP=y
+CONFIG_IS_MODULE(option)="config_enabled(CONFIG_VAL(option ##_MODULE))"
+CONFIG_SYS_LOAD_ADDR="(CONFIG_SYS_SDRAM_BASE + 0x00100000)"
+CONFIG_BOOTP_BOOTPATH=y
+CONFIG_SYS_HELP_CMD_WIDTH=8
+CONFIG_NR_DRAM_BANKS=4
+CONFIG_BOOTM_RTEMS=y
+CONFIG_SYS_CBSIZE=1024
+CONFIG_SKIP_LOWLEVEL_INIT=y
+CONFIG_SYS_MONITOR_LEN="(256 << 10)"
+CONFIG_BOOTM_LINUX=y
+CONFIG_G_DNL_THOR_VENDOR_NUM=0x04E8
+CONFIG_REVISION_TAG=y
+CONFIG_DEFAULT_CONSOLE="console=ttySAC1,115200n80"
+CONFIG_ENV_OFFSET="(RESERVE_BLOCK_SIZE + BL1_SIZE + BL2_SIZE + COPY_BL2_SIZE)"
+CONFIG_ENV_OVERWRITE=y
+CONFIG_ENV_SIZE="(8 << 10)"
+CONFIG_SUPPORT_RAW_INITRD=y
+CONFIG_SYS_MALLOC_LEN="(CONFIG_ENV_SIZE + (80 << 20))"
+CONFIG_INITRD_TAG=y
+CONFIG_SYS_MMC_ENV_DEV=0
+CONFIG_EXYNOS4210=y
+CONFIG_MMC_DEFAULT_DEV=0
+CONFIG_SYS_TEXT_BASE=0x43E00000
+CONFIG_USB_FUNCTION_MASS_STORAGE=y
+CONFIG_USB_GADGET_DWC2_OTG_PHY=y
+CONFIG_BOOTM_PLAN9=y
+CONFIG_IS_BUILTIN(option)="config_enabled(CONFIG_VAL(option))"
+CONFIG_SPL_TEXT_BASE=0x02023400
+CONFIG_BOOTP_DNS=y
+CONFIG_SYS_MAXARGS=16
+CONFIG_SYS_PBSIZE=1024
+CONFIG_ENV_VARS_UBOOT_CONFIG=y
+CONFIG_BOOTP_HOSTNAME=y
+CONFIG_BOARDDIR="board/samsung/itop4412"
+CONFIG_BOUNCE_BUFFER=y
+CONFIG_SPL_STACK=0x02040000
+CONFIG_SYS_MAX_FLASH_SECT=512
+CONFIG_CMDLINE_EDITING=y
+CONFIG_SPL_MAX_FOOTPRINT="(14 * 1024)"
+CONFIG_SYS_BOOT_RAMDISK_HIGH=y
+CONFIG_ZLIB=y
+CONFIG_LIB_UUID=y
+CONFIG_SYS_BARGSIZE=$(CONFIG_SYS_CBSIZE)
+CONFIG_AUTO_COMPLETE=y
+CONFIG_PWM=y
+CONFIG_GZIP=y
+CONFIG_SYS_DFU_DATA_BUF_SIZE="SZ_32M"
+CONFIG_CLK_1000_400_200=y
+CONFIG_SYS_BAUDRATE_TABLE="{ 9600, 19200, 38400, 57600, 115200 }"
+CONFIG_VAL(option)="config_val(option)"
+CONFIG_SYS_DCACHE_OFF=y
+CONFIG_SYS_SDRAM_BASE=0x40000000
+CONFIG_IMAGE_FORMAT_LEGACY=y
+CONFIG_BOOTP_GATEWAY=y
+CONFIG_G_DNL_UMS_PRODUCT_NUM=0xA4A5
+CONFIG_SYS_MONITOR_BASE=0x00000000
+CONFIG_SPL_PAD_TO=0
+CONFIG_EXTRA_ENV_SETTINGS="loadaddr=0x400070000rdaddr=0x480000000kerneladdr=0x400070000ramdiskaddr=0x480000000console=ttySAC2,115200n80mmcdev=00bootenv=uEnv.txt0dtb_addr=0x410000000dtb_name=exynos4412-itop-elite.dtb0loadbootenv=load mmc ${mmcdev} ${loadaddr} ${bootenv}0bootargs=root=/dev/mmcblk1p2 rw console=ttySAC2,115200 init=/linuxrc earlyprintk0importbootenv=echo Importing environment from mmc ...; env import -t $loadaddr $filesize0loadbootscript=load mmc ${mmcdev} ${loadaddr} boot.scr0bootscript=echo Running bootscript from mmc${mmcdev} ...; source ${loadaddr}0"
+CONFIG_BOOTP_PXE=y
+CONFIG_G_DNL_UMS_VENDOR_NUM=0x0525
+CONFIG_LIB_RAND=y
+CONFIG_SYS_INIT_SP_ADDR="(CONFIG_SYS_TEXT_BASE + UBOOT_SIZE - 0x1000)"
+CONFIG_S5P=y
+CONFIG_CMDLINE_TAG=y
+CONFIG_SUPPORT_EMMC_BOOT=y
+CONFIG_USB_FUNCTION_THOR=y
+CONFIG_G_DNL_THOR_PRODUCT_NUM=0x685D
+CONFIG_ARCH_CPU_INIT=y
+CONFIG_SYS_MMC_MAX_BLK_COUNT=65535
+CONFIG_SYS_DEF_EEPROM_ADDR=0
+CONFIG_FS_EXT4=y
+CONFIG_MACH_TYPE="MACH_TYPE_ITOP4412"
+CONFIG_BOARD_COMMON=y
+CONFIG_SYS_MEMTEST_END="(CONFIG_SYS_SDRAM_BASE + 0x6000000)"
+CONFIG_SETUP_MEMORY_TAGS=y
+CONFIG_ITOP4412=y
+CONFIG_SERIAL2=y
+CONFIG_EXT4_WRITE=y
+CONFIG_SYS_MEMTEST_START=$(CONFIG_SYS_SDRAM_BASE)
+CONFIG_LMB=y
+CONFIG_SAMSUNG=y
+CONFIG_IS_ENABLED(option)="(config_enabled(CONFIG_VAL(option)) || config_enabled(CONFIG_VAL(option ##_MODULE)))"
+CONFIG_BOOTP_SUBNETMASK=y
+CONFIG_MIU_2BIT_21_7_INTERLEAVED=y
+CONFIG_EXYNOS4=y
diff -urN u-boot-2017.11/include/autoconf.mk.dep u-boot-2017.11-itop4412/include/autoconf.mk.dep
--- u-boot-2017.11/include/autoconf.mk.dep	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-2017.11-itop4412/include/autoconf.mk.dep	2019-02-16 11:32:10.000000000 +0800
@@ -0,0 +1,219 @@
+include/config/auto.conf: include/common.h include/linux/kconfig.h \
+ include/generated/autoconf.h include/config.h include/config_defaults.h \
+ include/config_uncmd_spl.h include/configs/itop4412.h \
+ include/configs/exynos4-common.h include/configs/exynos-common.h \
+ arch/arm/include/asm/arch/cpu.h arch/arm/include/asm/io.h \
+ include/linux/types.h include/linux/posix_types.h include/linux/stddef.h \
+ arch/arm/include/asm/posix_types.h arch/arm/include/asm/types.h \
+ /usr/local/arm/gcc-4.6.2-glibc-2.13-linaro-multilib-2011.12/fsl-linaro-toolchain/bin/../lib/gcc/arm-fsl-linux-gnueabi/4.6.2/include/stdbool.h \
+ arch/arm/include/asm/byteorder.h include/linux/byteorder/little_endian.h \
+ include/linux/compiler.h include/linux/compiler-gcc.h \
+ include/linux/byteorder/swab.h include/linux/byteorder/generic.h \
+ arch/arm/include/asm/memory.h arch/arm/include/asm/barriers.h \
+ include/asm-generic/io.h include/iotrace.h include/linux/sizes.h \
+ include/config_distro_defaults.h arch/arm/include/asm/config.h \
+ include/linux/kconfig.h include/config_fallbacks.h include/errno.h \
+ include/linux/errno.h include/time.h include/linux/typecheck.h \
+ include/asm-offsets.h include/linux/bitops.h \
+ include/asm-generic/bitsperlong.h arch/arm/include/asm/bitops.h \
+ arch/arm/include/asm/proc-armv/system.h \
+ include/asm-generic/bitops/__fls.h include/asm-generic/bitops/__ffs.h \
+ include/asm-generic/bitops/fls.h include/asm-generic/bitops/fls64.h \
+ include/linux/bug.h include/vsprintf.h \
+ /usr/local/arm/gcc-4.6.2-glibc-2.13-linaro-multilib-2011.12/fsl-linaro-toolchain/bin/../lib/gcc/arm-fsl-linux-gnueabi/4.6.2/include/stdarg.h \
+ include/linux/build_bug.h include/linux/printk.h include/stdio.h \
+ include/linux/delay.h include/linux/kernel.h include/linux/string.h \
+ arch/arm/include/asm/string.h include/linux/linux_string.h \
+ include/linux/stringify.h arch/arm/include/asm/ptrace.h \
+ arch/arm/include/asm/proc-armv/ptrace.h include/part.h include/blk.h \
+ include/efi.h include/linux/linkage.h arch/arm/include/asm/linkage.h \
+ include/ide.h include/uuid.h include/linux/list.h include/linux/poison.h \
+ include/part_efi.h include/flash.h include/image.h include/compiler.h \
+ /usr/local/arm/gcc-4.6.2-glibc-2.13-linaro-multilib-2011.12/fsl-linaro-toolchain/bin/../lib/gcc/arm-fsl-linux-gnueabi/4.6.2/include/stddef.h \
+ include/lmb.h arch/arm/include/asm/u-boot.h include/asm-generic/u-boot.h \
+ arch/arm/include/asm/u-boot-arm.h include/command.h \
+ include/linker_lists.h arch/arm/include/asm/global_data.h \
+ include/asm-generic/global_data.h include/membuff.h \
+ include/display_options.h include/u-boot/crc.h include/net.h \
+ arch/arm/include/asm/cache.h arch/arm/include/asm/system.h \
+ include/common.h include/bootstage.h include/environment.h include/mmc.h
+
+include/linux/kconfig.h:
+
+include/generated/autoconf.h:
+
+include/config.h:
+
+include/config_defaults.h:
+
+include/config_uncmd_spl.h:
+
+include/configs/itop4412.h:
+
+include/configs/exynos4-common.h:
+
+include/configs/exynos-common.h:
+
+arch/arm/include/asm/arch/cpu.h:
+
+arch/arm/include/asm/io.h:
+
+include/linux/types.h:
+
+include/linux/posix_types.h:
+
+include/linux/stddef.h:
+
+arch/arm/include/asm/posix_types.h:
+
+arch/arm/include/asm/types.h:
+
+/usr/local/arm/gcc-4.6.2-glibc-2.13-linaro-multilib-2011.12/fsl-linaro-toolchain/bin/../lib/gcc/arm-fsl-linux-gnueabi/4.6.2/include/stdbool.h:
+
+arch/arm/include/asm/byteorder.h:
+
+include/linux/byteorder/little_endian.h:
+
+include/linux/compiler.h:
+
+include/linux/compiler-gcc.h:
+
+include/linux/byteorder/swab.h:
+
+include/linux/byteorder/generic.h:
+
+arch/arm/include/asm/memory.h:
+
+arch/arm/include/asm/barriers.h:
+
+include/asm-generic/io.h:
+
+include/iotrace.h:
+
+include/linux/sizes.h:
+
+include/config_distro_defaults.h:
+
+arch/arm/include/asm/config.h:
+
+include/linux/kconfig.h:
+
+include/config_fallbacks.h:
+
+include/errno.h:
+
+include/linux/errno.h:
+
+include/time.h:
+
+include/linux/typecheck.h:
+
+include/asm-offsets.h:
+
+include/linux/bitops.h:
+
+include/asm-generic/bitsperlong.h:
+
+arch/arm/include/asm/bitops.h:
+
+arch/arm/include/asm/proc-armv/system.h:
+
+include/asm-generic/bitops/__fls.h:
+
+include/asm-generic/bitops/__ffs.h:
+
+include/asm-generic/bitops/fls.h:
+
+include/asm-generic/bitops/fls64.h:
+
+include/linux/bug.h:
+
+include/vsprintf.h:
+
+/usr/local/arm/gcc-4.6.2-glibc-2.13-linaro-multilib-2011.12/fsl-linaro-toolchain/bin/../lib/gcc/arm-fsl-linux-gnueabi/4.6.2/include/stdarg.h:
+
+include/linux/build_bug.h:
+
+include/linux/printk.h:
+
+include/stdio.h:
+
+include/linux/delay.h:
+
+include/linux/kernel.h:
+
+include/linux/string.h:
+
+arch/arm/include/asm/string.h:
+
+include/linux/linux_string.h:
+
+include/linux/stringify.h:
+
+arch/arm/include/asm/ptrace.h:
+
+arch/arm/include/asm/proc-armv/ptrace.h:
+
+include/part.h:
+
+include/blk.h:
+
+include/efi.h:
+
+include/linux/linkage.h:
+
+arch/arm/include/asm/linkage.h:
+
+include/ide.h:
+
+include/uuid.h:
+
+include/linux/list.h:
+
+include/linux/poison.h:
+
+include/part_efi.h:
+
+include/flash.h:
+
+include/image.h:
+
+include/compiler.h:
+
+/usr/local/arm/gcc-4.6.2-glibc-2.13-linaro-multilib-2011.12/fsl-linaro-toolchain/bin/../lib/gcc/arm-fsl-linux-gnueabi/4.6.2/include/stddef.h:
+
+include/lmb.h:
+
+arch/arm/include/asm/u-boot.h:
+
+include/asm-generic/u-boot.h:
+
+arch/arm/include/asm/u-boot-arm.h:
+
+include/command.h:
+
+include/linker_lists.h:
+
+arch/arm/include/asm/global_data.h:
+
+include/asm-generic/global_data.h:
+
+include/membuff.h:
+
+include/display_options.h:
+
+include/u-boot/crc.h:
+
+include/net.h:
+
+arch/arm/include/asm/cache.h:
+
+arch/arm/include/asm/system.h:
+
+include/common.h:
+
+include/bootstage.h:
+
+include/environment.h:
+
+include/mmc.h:
diff -urN u-boot-2017.11/include/config/auto.conf u-boot-2017.11-itop4412/include/config/auto.conf
--- u-boot-2017.11/include/config/auto.conf	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-2017.11-itop4412/include/config/auto.conf	2019-02-16 11:32:11.000000000 +0800
@@ -0,0 +1,201 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# U-Boot 2017.11 Configuration
+#
+CONFIG_DISPLAY_BOARDINFO=y
+CONFIG_CMD_BOOTM=y
+CONFIG_CMD_EXT4=y
+CONFIG_BOOTSTAGE_RECORD_COUNT=30
+CONFIG_CMD_FASTBOOT=y
+CONFIG_LOGLEVEL=4
+CONFIG_CMD_USB=y
+CONFIG_SPL_DOS_PARTITION=y
+CONFIG_MTDIDS_DEFAULT=""
+CONFIG_OF_LIBFDT=y
+CONFIG_CMD_EDITENV=y
+CONFIG_SPL_USE_ARCH_MEMSET=y
+CONFIG_FASTBOOT_FLASH=y
+CONFIG_USE_ARCH_MEMCPY=y
+CONFIG_BLK=y
+CONFIG_USB=y
+CONFIG_ARM_ASM_UNIFIED=y
+CONFIG_OF_SEPARATE=y
+CONFIG_GENERATE_SMBIOS_TABLE=y
+CONFIG_SPL_LEGACY_IMAGE_SUPPORT=y
+CONFIG_MMC_SDHCI_SDMA=y
+CONFIG_FASTBOOT_GPT_NAME="gpt"
+CONFIG_HASH=y
+CONFIG_CMD_CONSOLE=y
+CONFIG_CMD_BOOTD=y
+CONFIG_DEFAULT_FDT_FILE=""
+CONFIG_OF_TRANSLATE=y
+CONFIG_SPL_ISO_PARTITION=y
+CONFIG_BOOTSTAGE_STASH_ADDR=0
+CONFIG_SMBIOS_MANUFACTURER="samsung"
+CONFIG_HAVE_PRIVATE_LIBGCC=y
+CONFIG_CMD_BDI=y
+CONFIG_ARM=y
+CONFIG_CREATE_ARCH_SYMLINK=y
+CONFIG_DM_SEQ_ALIAS=y
+CONFIG_SYS_VENDOR="samsung"
+CONFIG_USB_STORAGE=y
+CONFIG_SYS_USB_EVENT_POLL_VIA_CONTROL_EP=y
+CONFIG_CMD_BOOTEFI_HELLO_COMPILE=y
+CONFIG_EFI_LOADER=y
+CONFIG_USB_GADGET_VENDOR_NUM=0x18d1
+CONFIG_DTC=y
+CONFIG_CMD_SAVEENV=y
+CONFIG_DEBUG_UART_SHIFT=0
+CONFIG_SYS_STDIO_DEREGISTER=y
+CONFIG_FASTBOOT_USB_DEV=0
+CONFIG_SYS_CPU="armv7"
+CONFIG_SYS_CONSOLE_IS_IN_ENV=y
+CONFIG_CMD_THOR_DOWNLOAD=y
+CONFIG_FASTBOOT_FLASH_MMC_DEV=0
+CONFIG_USB_GADGET_PRODUCT_NUM=0x4e30
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_DEBUG_UART_BASE=0x13820000
+CONFIG_DM_MMC=y
+CONFIG_SPL_SERIAL_SUPPORT=y
+CONFIG_USE_PRIVATE_LIBGCC=y
+CONFIG_ARCH_FIXUP_FDT_MEMORY=y
+CONFIG_DM_SERIAL=y
+CONFIG_DM_I2C=y
+CONFIG_CMD_FLASH=y
+CONFIG_USB_GADGET_MANUFACTURER="Freescale"
+CONFIG_DEBUG_UART_S5P=y
+CONFIG_DOS_PARTITION=y
+CONFIG_CMD_ENV_EXISTS=y
+CONFIG_SMBIOS_PRODUCT_NAME="itop4412"
+CONFIG_IDENT_STRING=" for itop-4412"
+CONFIG_TPL_SYS_MALLOC_F_LEN=0x400
+CONFIG_CMD_SETEXPR=y
+CONFIG_SYS_CONSOLE_INFO_QUIET=y
+CONFIG_DM_DEVICE_REMOVE=y
+CONFIG_DFU_MMC=y
+CONFIG_SYS_CACHELINE_SIZE=64
+CONFIG_CMD_EXPORTENV=y
+CONFIG_CMD_MMC=y
+CONFIG_DM_DEV_READ_INLINE=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_REQUIRE_SERIAL_CONSOLE=y
+CONFIG_ENV_IS_IN_MMC=y
+CONFIG_USB_GADGET=y
+CONFIG_USB_ETH_RNDIS=y
+CONFIG_SPL_EFI_PARTITION=y
+CONFIG_ARCH_EXYNOS4=y
+CONFIG_CMD_DHCP=y
+CONFIG_FS_FAT=y
+CONFIG_SD_BOOT=y
+CONFIG_DM_SPI=y
+CONFIG_DEBUG_UART=y
+CONFIG_SYS_EXTRA_OPTIONS=""
+CONFIG_EFI_PARTITION=y
+CONFIG_CMD_PART=y
+CONFIG_SPL_SERIAL_PRESENT=y
+CONFIG_SIMPLE_BUS=y
+CONFIG_CMD_CRC32=y
+CONFIG_USB_GADGET_VBUS_DRAW=2
+CONFIG_USB_FUNCTION_DFU=y
+CONFIG_SYS_BOARD="itop4412"
+CONFIG_MMC_SDHCI_S5P=y
+CONFIG_FASTBOOT=y
+CONFIG_SYS_CONFIG_NAME="itop4412"
+CONFIG_DM_GPIO=y
+CONFIG_USB_GADGET_DUALSPEED=y
+CONFIG_USE_ARCH_MEMSET=y
+CONFIG_DM_WARN=y
+CONFIG_MMC_DW=y
+CONFIG_PARTITION_UUIDS=y
+CONFIG_CMD_GO=y
+CONFIG_CMD_DFU=y
+CONFIG_TARGET_ITOP4412=y
+CONFIG_USBNET_HOST_ADDR="de:ad:be:ef:00:00"
+CONFIG_ISO_PARTITION=y
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_USB_FUNCTION_SDP=y
+CONFIG_SYS_MALLOC_CLEAR_ON_INIT=y
+CONFIG_BOOTDELAY=5
+CONFIG_CMD_IMI=y
+CONFIG_SYS_HZ=1000
+CONFIG_CPU_V7=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_SUPPORT_OF_CONTROL=y
+CONFIG_SPL_BOOTSTAGE_RECORD_COUNT=5
+CONFIG_DEBUG_UART_CLOCK=100000000
+CONFIG_CMD_EXT2=y
+CONFIG_DM_STDIO=y
+CONFIG_LOCALVERSION=""
+CONFIG_USB_GADGET_DOWNLOAD=y
+CONFIG_SUPPORT_SPL=y
+CONFIG_CMDLINE=y
+CONFIG_USB_ETHER=y
+CONFIG_CMD_LOADB=y
+CONFIG_CMD_RUN=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_FASTBOOT_BUF_ADDR=0x40000000
+CONFIG_FS_FAT_MAX_CLUSTSIZE=65536
+CONFIG_SYS_PROMPT="u-boot # "
+CONFIG_CMD_MEMORY=y
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_BOOTZ=y
+CONFIG_FASTBOOT_MBR_NAME="mbr"
+CONFIG_CMD_ECHO=y
+CONFIG_FASTBOOT_BUF_SIZE=0x10000000
+CONFIG_SPL=y
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_SPL_SYS_MALLOC_F_LEN=0x400
+CONFIG_SYS_ARCH="arm"
+CONFIG_CMD_DM=y
+CONFIG_SYS_CACHE_SHIFT_6=y
+CONFIG_USBNET_DEVADDR="de:ad:be:ef:00:01"
+CONFIG_HAS_VBAR=y
+CONFIG_EXPERT=y
+CONFIG_MMC_DW_EXYNOS=y
+CONFIG_SYS_SOC="exynos"
+CONFIG_MMC=y
+CONFIG_BAUDRATE=115200
+CONFIG_USB_GADGET_DWC2_OTG=y
+CONFIG_FAT_WRITE=y
+CONFIG_MMC_SDHCI=y
+CONFIG_PARTITIONS=y
+CONFIG_CMD_ITEST=y
+CONFIG_DISPLAY_CPUINFO=y
+CONFIG_DM_SPI_FLASH=y
+CONFIG_DM_USB=y
+CONFIG_CMD_CACHE=y
+CONFIG_BOOTSTAGE_STASH_SIZE=0x1000
+CONFIG_SERIAL_PRESENT=y
+CONFIG_OF_CONTROL=y
+CONFIG_SYS_WHITE_ON_BLACK=y
+CONFIG_SPL_LDSCRIPT="board/samsung/common/exynos-uboot-spl.lds"
+CONFIG_CMD_FDT=y
+CONFIG_CMD_LOADS=y
+CONFIG_CMD_FAT=y
+CONFIG_USB_FUNCTION_FASTBOOT=y
+CONFIG_ARCH_EXYNOS=y
+CONFIG_MKIMAGE_DTC_PATH="dtc"
+CONFIG_EFI_PARTITION_ENTRIES_OFF=0
+CONFIG_SPL_RAW_IMAGE_SUPPORT=y
+CONFIG_DEFAULT_DEVICE_TREE="exynos4412-itop4412"
+CONFIG_SPL_LOGLEVEL=4
+CONFIG_CMD_BOOTEFI=y
+CONFIG_SPL_GPIO_SUPPORT=y
+CONFIG_AUTOBOOT=y
+CONFIG_DM=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_GPT=y
+CONFIG_DM_KEYBOARD=y
+CONFIG_HAS_THUMB2=y
+CONFIG_SPL_DM_SERIAL=y
+CONFIG_SYS_MALLOC_F=y
+CONFIG_SPL_USE_ARCH_MEMCPY=y
+CONFIG_CMD_IMPORTENV=y
+CONFIG_SYS_MALLOC_F_LEN=0x400
+CONFIG_MTDPARTS_DEFAULT=""
+CONFIG_SPL_PARTITION_UUIDS=y
+CONFIG_CMD_ELF=y
+CONFIG_RANDOM_UUID=y
+CONFIG_SYS_ARM_ARCH=7
+CONFIG_CMD_SOURCE=y

diff -urN u-boot-2017.11/include/config/uboot.release u-boot-2017.11-itop4412/include/config/uboot.release
--- u-boot-2017.11/include/config/uboot.release	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-2017.11-itop4412/include/config/uboot.release	2019-02-16 09:37:36.000000000 +0800
@@ -0,0 +1 @@
+2017.11""
diff -urN u-boot-2017.11/include/config.h u-boot-2017.11-itop4412/include/config.h
--- u-boot-2017.11/include/config.h	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-2017.11-itop4412/include/config.h	2019-02-16 09:37:36.000000000 +0800
@@ -0,0 +1,8 @@
+/* Automatically generated - do not edit */
+#define CONFIG_BOARDDIR board/samsung/itop4412
+#include <config_defaults.h>
+#include <config_uncmd_spl.h>
+#include <configs/itop4412.h>
+#include <asm/config.h>
+#include <linux/kconfig.h>
+#include <config_fallbacks.h>
diff -urN u-boot-2017.11/include/configs/itop4412.h u-boot-2017.11-itop4412/include/configs/itop4412.h
--- u-boot-2017.11/include/configs/itop4412.h	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-2017.11-itop4412/include/configs/itop4412.h	2019-02-16 09:21:13.000000000 +0800
@@ -0,0 +1,118 @@
+/*
+ * Copyright (C) 2011 Samsung Electronics
+ *
+ * Configuration settings for the SAMSUNG ITOP4412 (EXYNOS4412) board.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __CONFIG_ITOP4412_H
+#define __CONFIG_ITOP4412_H
+
+#include <configs/exynos4-common.h>
+
+#define CONFIG_SUPPORT_EMMC_BOOT 1
+
+/* High Level Configuration Options */
+#define CONFIG_EXYNOS4210		1	/* which is a EXYNOS4210 SoC */
+#define CONFIG_ITOP4412			1	/* working with ITOP4412*/
+
+
+#define CONFIG_SYS_DCACHE_OFF		1
+
+/* itop-4412 has 4 bank of DRAM */
+#define CONFIG_NR_DRAM_BANKS		4
+#define CONFIG_SYS_SDRAM_BASE		0x40000000
+#define PHYS_SDRAM_1			CONFIG_SYS_SDRAM_BASE
+#define SDRAM_BANK_SIZE			(256 << 20)	/* 256 MB */
+
+/* memtest works on */
+#define CONFIG_SYS_MEMTEST_START	CONFIG_SYS_SDRAM_BASE
+#define CONFIG_SYS_MEMTEST_END		(CONFIG_SYS_SDRAM_BASE + 0x6000000)
+#define CONFIG_SYS_LOAD_ADDR		(CONFIG_SYS_SDRAM_BASE + 0x00100000)
+
+#define CONFIG_SYS_TEXT_BASE		0x43E00000
+
+/* #define MACH_TYPE_ITOP4412		0xffffffff */
+#define CONFIG_MACH_TYPE		MACH_TYPE_ITOP4412
+
+/* select serial console configuration */
+#define CONFIG_SERIAL2
+
+/* Console configuration */
+#define CONFIG_DEFAULT_CONSOLE		"console=ttySAC1,115200n8\0"
+
+#define CONFIG_SYS_MEM_TOP_HIDE	(1 << 20)	/* ram console */
+
+#define CONFIG_SYS_MONITOR_BASE	0x00000000
+
+/* Power Down Modes */
+#define S5P_CHECK_SLEEP			0x00000BAD
+#define S5P_CHECK_DIDLE			0xBAD00000
+#define S5P_CHECK_LPA			0xABAD0000
+
+#define CONFIG_SUPPORT_RAW_INITRD
+
+/* MMC SPL */
+#define COPY_BL2_FNPTR_ADDR		0x02020030
+#define CONFIG_SPL_TEXT_BASE	0x02023400 /* 0x02021410 */
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	"loadaddr=0x40007000\0" \
+	"rdaddr=0x48000000\0" \
+	"kerneladdr=0x40007000\0" \
+	"ramdiskaddr=0x48000000\0" \
+	"console=ttySAC2,115200n8\0" \
+	"mmcdev=0\0" \
+	"bootenv=uEnv.txt\0" \
+	"dtb_addr=0x41000000\0" \
+	"dtb_name=exynos4412-itop-elite.dtb\0" \
+	"loadbootenv=load mmc ${mmcdev} ${loadaddr} ${bootenv}\0" \
+	"bootargs=root=/dev/mmcblk1p2 rw console=ttySAC2,115200 init=/linuxrc earlyprintk\0" \
+	"importbootenv=echo Importing environment from mmc ...; " \
+	"env import -t $loadaddr $filesize\0" \
+    "loadbootscript=load mmc ${mmcdev} ${loadaddr} boot.scr\0" \
+    "bootscript=echo Running bootscript from mmc${mmcdev} ...; " \
+    "source ${loadaddr}\0"
+#define CONFIG_BOOTCOMMAND \
+	"if mmc rescan; then " \
+		"echo SD/MMC found on device ${mmcdev};" \
+		"if run loadbootenv; then " \
+			"echo Loaded environment from ${bootenv};" \
+			"run importbootenv;" \
+		"fi;" \
+		"if test -n $uenvcmd; then " \
+			"echo Running uenvcmd ...;" \
+			"run uenvcmd;" \
+		"fi;" \
+		"if run loadbootscript; then " \
+			"run bootscript; " \
+		"fi; " \
+	"fi;" \
+	"mmc read ${loadaddr} 0x460 0x3000; mmc read ${dtb_addr} 0x3460 0xa0; bootm ${loadaddr} - ${dtb_addr}" \
+	"load mmc ${mmcdev} ${loadaddr} uImage; load mmc ${mmcdev} ${dtb_addr} ${dtb_name}; bootm ${loadaddr} - ${dtb_addr}"
+
+#define CONFIG_CLK_1000_400_200
+
+/* MIU (Memory Interleaving Unit) */
+#define CONFIG_MIU_2BIT_21_7_INTERLEAVED
+
+#define CONFIG_SYS_MMC_ENV_DEV		0
+#define CONFIG_ENV_SIZE				(8 << 10) /* 8 KB */
+#define RESERVE_BLOCK_SIZE			(512)
+#define BL1_SIZE					(8 << 10) /* 8 K reserved for BL1 */
+#define BL2_SIZE					(16 << 10) /* 16 K reserved for BL2 */
+#define CONFIG_ENV_OFFSET			(RESERVE_BLOCK_SIZE + BL1_SIZE + BL2_SIZE + COPY_BL2_SIZE)
+
+#define CONFIG_SPL_MAX_FOOTPRINT	(14 * 1024)
+
+#define CONFIG_SPL_STACK			0x02040000
+#define UBOOT_SIZE					(2 << 20)
+#define CONFIG_SYS_INIT_SP_ADDR		(CONFIG_SYS_TEXT_BASE + UBOOT_SIZE - 0x1000)
+
+/* U-Boot copy size from boot Media to DRAM. */
+#define COPY_BL2_SIZE		0x80000
+#define BL2_START_OFFSET	((RESERVE_BLOCK_SIZE + BL1_SIZE + BL2_SIZE)/512)
+#define BL2_SIZE_BLOC_COUNT	(COPY_BL2_SIZE / 512)
+
+#endif	/* __CONFIG_H */
Binary files u-boot-2017.11/include/configs/.itop4412.h.swp and u-boot-2017.11-itop4412/include/configs/.itop4412.h.swp differ
diff -urN u-boot-2017.11/include/decompress_ext4.h u-boot-2017.11-itop4412/include/decompress_ext4.h
--- u-boot-2017.11/include/decompress_ext4.h	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-2017.11-itop4412/include/decompress_ext4.h	2019-02-16 09:21:11.000000000 +0800
@@ -0,0 +1,44 @@
+/* copyright (c) 2010 Samsung Electronics Co., Ltd.
+ *              http://www.samsung.com/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+typedef struct _ext4_file_header {
+	unsigned int magic;
+	unsigned short major;
+	unsigned short minor;
+	unsigned short file_header_size;
+	unsigned short chunk_header_size;
+	unsigned int block_size;
+	unsigned int total_blocks;
+	unsigned int total_chunks;
+	unsigned int crc32;
+}ext4_file_header;
+
+
+typedef struct _ext4_chunk_header {
+	unsigned short type;
+	unsigned short reserved;
+	unsigned int chunk_size;
+	unsigned int total_size;
+}ext4_chunk_header;
+
+#define EXT4_FILE_HEADER_MAGIC	0xED26FF3A
+#define EXT4_FILE_HEADER_MAJOR	0x0001
+#define EXT4_FILE_HEADER_MINOR	0x0000
+#define EXT4_FILE_BLOCK_SIZE	0x1000
+
+#define EXT4_FILE_HEADER_SIZE	(sizeof(struct _ext4_file_header))
+#define EXT4_CHUNK_HEADER_SIZE	(sizeof(struct _ext4_chunk_header))
+
+
+#define EXT4_CHUNK_TYPE_RAW			0xCAC1
+#define EXT4_CHUNK_TYPE_FILL		0xCAC2
+#define EXT4_CHUNK_TYPE_NONE		0xCAC3
+
+int write_compressed_ext4(char* img_base, unsigned int sector_base);
+int check_compress_ext4(char *img_base, unsigned int parti_size);
+

diff -urN u-boot-2017.11/itop4412-5.6.3_defconfig u-boot-2017.11-itop4412/itop4412-5.6.3_defconfig
--- u-boot-2017.11/itop4412-5.6.3_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-2017.11-itop4412/itop4412-5.6.3_defconfig	2019-02-16 09:21:59.000000000 +0800
@@ -0,0 +1,66 @@
+CONFIG_ARM=y
+CONFIG_ARCH_EXYNOS=y
+CONFIG_ARCH_EXYNOS4=y
+CONFIG_TARGET_ITOP4412=y
+CONFIG_SPL_GPIO_SUPPORT=y
+CONFIG_SPL_SERIAL_SUPPORT=y
+CONFIG_IDENT_STRING=" for itop-4412"
+CONFIG_DEFAULT_DEVICE_TREE="exynos4412-itop4412"
+CONFIG_DEBUG_UART=y
+CONFIG_SD_BOOT=y
+CONFIG_BOOTDELAY=5
+CONFIG_SYS_CONSOLE_IS_IN_ENV=y
+CONFIG_SYS_CONSOLE_INFO_QUIET=y
+CONFIG_SPL=y
+CONFIG_HUSH_PARSER=y
+CONFIG_SYS_PROMPT="u-boot # "
+CONFIG_FASTBOOT=y
+CONFIG_FASTBOOT_BUF_ADDR=0x70000000
+CONFIG_FASTBOOT_BUF_SIZE=0x100000
+CONFIG_FASTBOOT_FLASH=y
+CONFIG_FASTBOOT_FLASH_MMC_DEV=0
+# CONFIG_CMD_GO is not set
+# CONFIG_CMD_XIMG is not set
+# CONFIG_CMD_CRC32 is not set
+# CONFIG_CMD_MEMORY is not set
+# CONFIG_CMD_DM is not set
+# CONFIG_CMD_FLASH is not set
+# CONFIG_CMD_FPGA is not set
+# CONFIG_CMD_LOADB is not set
+# CONFIG_CMD_LOADS is not set
+CONFIG_CMD_MMC=y
+CONFIG_CMD_USB=y
+# CONFIG_CMD_NET is not set
+# CONFIG_CMD_NFS is not set
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+# CONFIG_CMD_MISC is not set
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_ISO_PARTITION=y
+CONFIG_EFI_PARTITION=y
+CONFIG_OF_CONTROL=y
+CONFIG_DM_MMC=y
+CONFIG_MMC_DW=y
+CONFIG_MMC_SDHCI=y
+CONFIG_MMC_SDHCI_SDMA=y
+CONFIG_MMC_SDHCI_S5P=y
+CONFIG_DM_PMIC=y
+CONFIG_PMIC_S5M8767=y
+CONFIG_DM_REGULATOR=y
+CONFIG_REGULATOR_S5M8767=y
+CONFIG_DEBUG_UART_S5P=y
+CONFIG_DEBUG_UART_BASE=0x13820000
+CONFIG_DEBUG_UART_CLOCK=100000000
+CONFIG_USB=y
+CONFIG_DM_USB=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_GADGET=y
+CONFIG_USB_GADGET_MANUFACTURER="Samsung"
+CONFIG_USB_GADGET_VENDOR_NUM=0x18d1
+CONFIG_USB_GADGET_PRODUCT_NUM=0x4e30
+CONFIG_USB_GADGET_DWC2_OTG=y
+CONFIG_USB_ETHER=y
Binary files u-boot-2017.11/lib/efi_loader/helloworld.efi and u-boot-2017.11-itop4412/lib/efi_loader/helloworld.efi differ
diff -urN u-boot-2017.11/Makefile u-boot-2017.11-itop4412/Makefile
--- u-boot-2017.11/Makefile	2017-11-14 09:08:06.000000000 +0800
+++ u-boot-2017.11-itop4412/Makefile	2019-02-16 09:21:59.000000000 +0800
@@ -246,6 +246,9 @@
 CROSS_COMPILE ?=
 endif
 
+#CROSS_COMPILE := arm-linux-gnueabi-
+CROSS_COMPILE := arm-none-linux-gnueabi-
+
 KCONFIG_CONFIG	?= .config
 export KCONFIG_CONFIG
 
@@ -852,9 +855,9 @@
 
 cfg: u-boot.cfg
 
-quiet_cmd_cfgcheck = CFGCHK  $2
-cmd_cfgcheck = $(srctree)/scripts/check-config.sh $2 \
-		$(srctree)/scripts/config_whitelist.txt $(srctree)
+#quiet_cmd_cfgcheck = CFGCHK  $2
+#cmd_cfgcheck = $(srctree)/scripts/check-config.sh $2 \
+#		$(srctree)/scripts/config_whitelist.txt $(srctree)
 
 all:		$(ALL-y) cfg
 ifeq ($(CONFIG_DM_I2C_COMPAT)$(CONFIG_SANDBOX),y)
Binary files u-boot-2017.11/MyUnderstandProject.udb and u-boot-2017.11-itop4412/MyUnderstandProject.udb differ
Binary files u-boot-2017.11/scripts/basic/fixdep and u-boot-2017.11-itop4412/scripts/basic/fixdep differ
Binary files u-boot-2017.11/scripts/dtc/dtc and u-boot-2017.11-itop4412/scripts/dtc/dtc differ
diff -urN u-boot-2017.11/scripts/dtc/dtc-lexer.lex.c u-boot-2017.11-itop4412/scripts/dtc/dtc-lexer.lex.c
--- u-boot-2017.11/scripts/dtc/dtc-lexer.lex.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-2017.11-itop4412/scripts/dtc/dtc-lexer.lex.c	2019-02-16 09:37:36.000000000 +0800
@@ -0,0 +1,2255 @@
+#line 2 "dtc-lexer.lex.c"
+
+#line 4 "dtc-lexer.lex.c"
+
+#define  YY_INT_ALIGNED short int
+
+/* A lexical scanner generated by flex */
+
+#define FLEX_SCANNER
+#define YY_FLEX_MAJOR_VERSION 2
+#define YY_FLEX_MINOR_VERSION 5
+#define YY_FLEX_SUBMINOR_VERSION 35
+#if YY_FLEX_SUBMINOR_VERSION > 0
+#define FLEX_BETA
+#endif
+
+/* First, we deal with  platform-specific or compiler-specific issues. */
+
+/* begin standard C headers. */
+#include <stdio.h>
+#include <string.h>
+#include <errno.h>
+#include <stdlib.h>
+
+/* end standard C headers. */
+
+/* flex integer type definitions */
+
+#ifndef FLEXINT_H
+#define FLEXINT_H
+
+/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
+
+#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
+
+/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
+ * if you want the limit (max/min) macros for int types. 
+ */
+#ifndef __STDC_LIMIT_MACROS
+#define __STDC_LIMIT_MACROS 1
+#endif
+
+#include <inttypes.h>
+typedef int8_t flex_int8_t;
+typedef uint8_t flex_uint8_t;
+typedef int16_t flex_int16_t;
+typedef uint16_t flex_uint16_t;
+typedef int32_t flex_int32_t;
+typedef uint32_t flex_uint32_t;
+#else
+typedef signed char flex_int8_t;
+typedef short int flex_int16_t;
+typedef int flex_int32_t;
+typedef unsigned char flex_uint8_t; 
+typedef unsigned short int flex_uint16_t;
+typedef unsigned int flex_uint32_t;
+
+/* Limits of integral types. */
+#ifndef INT8_MIN
+#define INT8_MIN               (-128)
+#endif
+#ifndef INT16_MIN
+#define INT16_MIN              (-32767-1)
+#endif
+#ifndef INT32_MIN
+#define INT32_MIN              (-2147483647-1)
+#endif
+#ifndef INT8_MAX
+#define INT8_MAX               (127)
+#endif
+#ifndef INT16_MAX
+#define INT16_MAX              (32767)
+#endif
+#ifndef INT32_MAX
+#define INT32_MAX              (2147483647)
+#endif
+#ifndef UINT8_MAX
+#define UINT8_MAX              (255U)
+#endif
+#ifndef UINT16_MAX
+#define UINT16_MAX             (65535U)
+#endif
+#ifndef UINT32_MAX
+#define UINT32_MAX             (4294967295U)
+#endif
+
+#endif /* ! C99 */
+
+#endif /* ! FLEXINT_H */
+
+#ifdef __cplusplus
+
+/* The "const" storage-class-modifier is valid. */
+#define YY_USE_CONST
+
+#else	/* ! __cplusplus */
+
+/* C99 requires __STDC__ to be defined as 1. */
+#if defined (__STDC__)
+
+#define YY_USE_CONST
+
+#endif	/* defined (__STDC__) */
+#endif	/* ! __cplusplus */
+
+#ifdef YY_USE_CONST
+#define yyconst const
+#else
+#define yyconst
+#endif
+
+/* Returned upon end-of-file. */
+#define YY_NULL 0
+
+/* Promotes a possibly negative, possibly signed char to an unsigned
+ * integer for use as an array index.  If the signed char is negative,
+ * we want to instead treat it as an 8-bit unsigned char, hence the
+ * double cast.
+ */
+#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
+
+/* Enter a start condition.  This macro really ought to take a parameter,
+ * but we do it the disgusting crufty way forced on us by the ()-less
+ * definition of BEGIN.
+ */
+#define BEGIN (yy_start) = 1 + 2 *
+
+/* Translate the current start state into a value that can be later handed
+ * to BEGIN to return to the state.  The YYSTATE alias is for lex
+ * compatibility.
+ */
+#define YY_START (((yy_start) - 1) / 2)
+#define YYSTATE YY_START
+
+/* Action number for EOF rule of a given start state. */
+#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
+
+/* Special action meaning "start processing a new file". */
+#define YY_NEW_FILE yyrestart(yyin  )
+
+#define YY_END_OF_BUFFER_CHAR 0
+
+/* Size of default input buffer. */
+#ifndef YY_BUF_SIZE
+#ifdef __ia64__
+/* On IA-64, the buffer size is 16k, not 8k.
+ * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.
+ * Ditto for the __ia64__ case accordingly.
+ */
+#define YY_BUF_SIZE 32768
+#else
+#define YY_BUF_SIZE 16384
+#endif /* __ia64__ */
+#endif
+
+/* The state buf must be large enough to hold one state per character in the main buffer.
+ */
+#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
+
+#ifndef YY_TYPEDEF_YY_BUFFER_STATE
+#define YY_TYPEDEF_YY_BUFFER_STATE
+typedef struct yy_buffer_state *YY_BUFFER_STATE;
+#endif
+
+extern int yyleng;
+
+extern FILE *yyin, *yyout;
+
+#define EOB_ACT_CONTINUE_SCAN 0
+#define EOB_ACT_END_OF_FILE 1
+#define EOB_ACT_LAST_MATCH 2
+
+    #define YY_LESS_LINENO(n)
+    
+/* Return all but the first "n" matched characters back to the input stream. */
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up yytext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		*yy_cp = (yy_hold_char); \
+		YY_RESTORE_YY_MORE_OFFSET \
+		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
+		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
+		} \
+	while ( 0 )
+
+#define unput(c) yyunput( c, (yytext_ptr)  )
+
+#ifndef YY_TYPEDEF_YY_SIZE_T
+#define YY_TYPEDEF_YY_SIZE_T
+typedef size_t yy_size_t;
+#endif
+
+#ifndef YY_STRUCT_YY_BUFFER_STATE
+#define YY_STRUCT_YY_BUFFER_STATE
+struct yy_buffer_state
+	{
+	FILE *yy_input_file;
+
+	char *yy_ch_buf;		/* input buffer */
+	char *yy_buf_pos;		/* current position in input buffer */
+
+	/* Size of input buffer in bytes, not including room for EOB
+	 * characters.
+	 */
+	yy_size_t yy_buf_size;
+
+	/* Number of characters read into yy_ch_buf, not including EOB
+	 * characters.
+	 */
+	int yy_n_chars;
+
+	/* Whether we "own" the buffer - i.e., we know we created it,
+	 * and can realloc() it to grow it, and should free() it to
+	 * delete it.
+	 */
+	int yy_is_our_buffer;
+
+	/* Whether this is an "interactive" input source; if so, and
+	 * if we're using stdio for input, then we want to use getc()
+	 * instead of fread(), to make sure we stop fetching input after
+	 * each newline.
+	 */
+	int yy_is_interactive;
+
+	/* Whether we're considered to be at the beginning of a line.
+	 * If so, '^' rules will be active on the next match, otherwise
+	 * not.
+	 */
+	int yy_at_bol;
+
+    int yy_bs_lineno; /**< The line count. */
+    int yy_bs_column; /**< The column count. */
+    
+	/* Whether to try to fill the input buffer when we reach the
+	 * end of it.
+	 */
+	int yy_fill_buffer;
+
+	int yy_buffer_status;
+
+#define YY_BUFFER_NEW 0
+#define YY_BUFFER_NORMAL 1
+	/* When an EOF's been seen but there's still some text to process
+	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
+	 * shouldn't try reading from the input source any more.  We might
+	 * still have a bunch of tokens to match, though, because of
+	 * possible backing-up.
+	 *
+	 * When we actually see the EOF, we change the status to "new"
+	 * (via yyrestart()), so that the user can continue scanning by
+	 * just pointing yyin at a new input file.
+	 */
+#define YY_BUFFER_EOF_PENDING 2
+
+	};
+#endif /* !YY_STRUCT_YY_BUFFER_STATE */
+
+/* Stack of input buffers. */
+static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
+static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
+static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */
+
+/* We provide macros for accessing buffer states in case in the
+ * future we want to put the buffer states in a more general
+ * "scanner state".
+ *
+ * Returns the top of the stack, or NULL.
+ */
+#define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
+                          ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
+                          : NULL)
+
+/* Same as previous macro, but useful when we know that the buffer stack is not
+ * NULL or when we need an lvalue. For internal use only.
+ */
+#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
+
+/* yy_hold_char holds the character lost when yytext is formed. */
+static char yy_hold_char;
+static int yy_n_chars;		/* number of characters read into yy_ch_buf */
+int yyleng;
+
+/* Points to current character in buffer. */
+static char *yy_c_buf_p = (char *) 0;
+static int yy_init = 0;		/* whether we need to initialize */
+static int yy_start = 0;	/* start state number */
+
+/* Flag which is used to allow yywrap()'s to do buffer switches
+ * instead of setting up a fresh yyin.  A bit of a hack ...
+ */
+static int yy_did_buffer_switch_on_eof;
+
+void yyrestart (FILE *input_file  );
+void yy_switch_to_buffer (YY_BUFFER_STATE new_buffer  );
+YY_BUFFER_STATE yy_create_buffer (FILE *file,int size  );
+void yy_delete_buffer (YY_BUFFER_STATE b  );
+void yy_flush_buffer (YY_BUFFER_STATE b  );
+void yypush_buffer_state (YY_BUFFER_STATE new_buffer  );
+void yypop_buffer_state (void );
+
+static void yyensure_buffer_stack (void );
+static void yy_load_buffer_state (void );
+static void yy_init_buffer (YY_BUFFER_STATE b,FILE *file  );
+
+#define YY_FLUSH_BUFFER yy_flush_buffer(YY_CURRENT_BUFFER )
+
+YY_BUFFER_STATE yy_scan_buffer (char *base,yy_size_t size  );
+YY_BUFFER_STATE yy_scan_string (yyconst char *yy_str  );
+YY_BUFFER_STATE yy_scan_bytes (yyconst char *bytes,int len  );
+
+void *yyalloc (yy_size_t  );
+void *yyrealloc (void *,yy_size_t  );
+void yyfree (void *  );
+
+#define yy_new_buffer yy_create_buffer
+
+#define yy_set_interactive(is_interactive) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){ \
+        yyensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            yy_create_buffer(yyin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
+	}
+
+#define yy_set_bol(at_bol) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){\
+        yyensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            yy_create_buffer(yyin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
+	}
+
+#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
+
+/* Begin user sect3 */
+
+#define yywrap(n) 1
+#define YY_SKIP_YYWRAP
+
+typedef unsigned char YY_CHAR;
+
+FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
+
+typedef int yy_state_type;
+
+extern int yylineno;
+
+int yylineno = 1;
+
+extern char *yytext;
+#define yytext_ptr yytext
+
+static yy_state_type yy_get_previous_state (void );
+static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );
+static int yy_get_next_buffer (void );
+static void yy_fatal_error (yyconst char msg[]  );
+
+/* Done after the current pattern has been matched and before the
+ * corresponding action - sets up yytext.
+ */
+#define YY_DO_BEFORE_ACTION \
+	(yytext_ptr) = yy_bp; \
+	yyleng = (size_t) (yy_cp - yy_bp); \
+	(yy_hold_char) = *yy_cp; \
+	*yy_cp = '\0'; \
+	(yy_c_buf_p) = yy_cp;
+
+#define YY_NUM_RULES 31
+#define YY_END_OF_BUFFER 32
+/* This struct is not used in this scanner,
+   but its presence is necessary. */
+struct yy_trans_info
+	{
+	flex_int32_t yy_verify;
+	flex_int32_t yy_nxt;
+	};
+static yyconst flex_int16_t yy_accept[166] =
+    {   0,
+        0,    0,    0,    0,    0,    0,    0,    0,   32,   30,
+       19,   19,   30,   30,   30,   30,   30,   30,   30,   30,
+       30,   30,   30,   30,   30,   30,   16,   17,   17,   30,
+       17,   11,   11,   19,   27,    0,    3,    0,   28,   13,
+        0,    0,   12,    0,    0,    0,    0,    0,    0,    0,
+        0,   22,   24,   26,   25,   23,    0,   10,   29,    0,
+        0,    0,   15,   15,   17,   17,   17,   11,   11,   11,
+        0,   13,    0,   12,    0,    0,    0,   21,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,   17,   11,   11,
+       11,    0,   14,   20,    0,    0,    0,    0,    0,    0,
+
+        0,    0,    0,    0,   17,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,   17,    7,    0,    0,    0,
+        0,    0,    0,    0,    2,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    4,   18,    0,    0,    5,    2,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    1,    0,    0,    0,    0,    6,    9,    0,
+        0,    0,    0,    8,    0
+    } ;
+
+static yyconst flex_int32_t yy_ec[256] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
+        4,    4,    4,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    2,    5,    6,    7,    1,    1,    8,    9,    1,
+        1,   10,   11,   11,   12,   11,   13,   14,   15,   16,
+       16,   16,   16,   16,   16,   16,   16,   17,    1,   18,
+       19,   20,   11,   11,   21,   21,   21,   21,   21,   21,
+       22,   22,   22,   22,   22,   23,   22,   22,   22,   22,
+       22,   22,   22,   22,   24,   22,   22,   25,   22,   22,
+        1,   26,   27,    1,   22,    1,   21,   28,   29,   30,
+
+       31,   21,   32,   22,   33,   22,   22,   34,   35,   36,
+       37,   38,   22,   39,   40,   41,   42,   43,   22,   25,
+       44,   22,   45,   46,   47,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1
+    } ;
+
+static yyconst flex_int32_t yy_meta[48] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    2,    3,    1,    2,
+        2,    2,    4,    5,    5,    5,    6,    1,    1,    1,
+        7,    8,    8,    8,    8,    1,    1,    7,    7,    7,
+        7,    8,    8,    8,    8,    8,    8,    8,    8,    8,
+        8,    8,    8,    8,    3,    1,    4
+    } ;
+
+static yyconst flex_int16_t yy_base[180] =
+    {   0,
+        0,  393,   35,  392,   66,  391,   38,  107,  397,  401,
+       55,  113,  377,  112,  111,  111,  114,   42,  376,  106,
+      377,  347,  126,  120,    0,  147,  401,    0,  124,    0,
+      137,  158,  170,  163,  401,  153,  401,  389,  401,    0,
+      378,  120,  401,  131,  380,  386,  355,  139,  351,  355,
+      351,  401,  401,  401,  401,  401,  367,  401,  401,  185,
+      350,  346,  401,  364,    0,  185,  347,  189,  356,  355,
+        0,    0,  330,  180,  366,  141,  372,  361,  332,  338,
+      331,  341,  334,  326,  205,  331,  337,  329,  401,  341,
+      167,  316,  401,  349,  348,  320,  328,  346,  180,  318,
+
+      324,  209,  324,  320,  322,  342,  338,  309,  306,  315,
+      305,  315,  312,  192,  342,  341,  401,  293,  306,  282,
+      268,  252,  255,  203,  285,  282,  272,  268,  252,  233,
+      232,  239,  208,  107,  401,  401,  238,  211,  401,  211,
+      212,  208,  228,  203,  215,  207,  233,  222,  212,  211,
+      203,  227,  401,  237,  225,  204,  185,  401,  401,  149,
+      128,   88,   42,  401,  401,  253,  259,  267,  271,  275,
+      281,  288,  292,  300,  308,  312,  318,  326,  334
+    } ;
+
+static yyconst flex_int16_t yy_def[180] =
+    {   0,
+      165,    1,    1,    3,  165,    5,    1,    1,  165,  165,
+      165,  165,  165,  166,  167,  168,  165,  165,  165,  165,
+      169,  165,  165,  165,  170,  169,  165,  171,  172,  171,
+      171,  165,  165,  165,  165,  166,  165,  166,  165,  173,
+      165,  168,  165,  168,  174,  175,  165,  165,  165,  165,
+      165,  165,  165,  165,  165,  165,  169,  165,  165,  165,
+      165,  165,  165,  169,  171,  172,  171,  165,  165,  165,
+      176,  173,  177,  168,  174,  174,  175,  165,  165,  165,
+      165,  165,  165,  165,  165,  165,  165,  171,  165,  165,
+      176,  177,  165,  165,  165,  165,  165,  165,  165,  165,
+
+      165,  165,  165,  165,  171,  165,  165,  165,  165,  165,
+      165,  165,  165,  178,  165,  171,  165,  165,  165,  165,
+      165,  165,  165,  178,  165,  178,  165,  165,  165,  165,
+      165,  165,  165,  165,  165,  165,  165,  165,  165,  165,
+      165,  165,  165,  165,  165,  165,  165,  179,  165,  165,
+      165,  179,  165,  179,  165,  165,  165,  165,  165,  165,
+      165,  165,  165,  165,    0,  165,  165,  165,  165,  165,
+      165,  165,  165,  165,  165,  165,  165,  165,  165
+    } ;
+
+static yyconst flex_int16_t yy_nxt[449] =
+    {   0,
+       10,   11,   12,   11,   13,   14,   10,   15,   16,   10,
+       10,   10,   17,   10,   10,   10,   10,   18,   19,   20,
+       21,   21,   21,   21,   21,   10,   10,   21,   21,   21,
+       21,   21,   21,   21,   21,   21,   21,   21,   21,   21,
+       21,   21,   21,   21,   10,   22,   10,   24,   25,   25,
+       25,   32,   33,   33,  164,   26,   34,   34,   34,   52,
+       53,   27,   26,   26,   26,   26,   10,   11,   12,   11,
+       13,   14,   28,   15,   16,   28,   28,   28,   24,   28,
+       28,   28,   10,   18,   19,   20,   29,   29,   29,   29,
+       29,   30,   10,   29,   29,   29,   29,   29,   29,   29,
+
+       29,   29,   29,   29,   29,   29,   29,   29,   29,   29,
+       10,   22,   10,   23,   34,   34,   34,   37,   39,   43,
+       32,   33,   33,   45,   55,   56,   46,   60,   43,   45,
+       65,  163,   46,   65,   65,   65,   44,   38,   60,   74,
+       58,   47,  141,   48,  142,   44,   49,   47,   50,   48,
+       76,   51,   62,   94,   50,   41,   44,   51,   37,   61,
+       64,   64,   64,   58,   34,   34,   34,   64,  162,   80,
+       67,   68,   68,   68,   64,   64,   64,   64,   38,   81,
+       69,   70,   71,   68,   68,   68,   60,  161,   43,   69,
+       70,   65,   69,   70,   65,   65,   65,  125,   85,   85,
+
+       85,   58,   68,   68,   68,   44,  102,  110,  125,  133,
+      102,   69,   70,  111,  114,  160,  159,  126,   85,   85,
+       85,  140,  140,  140,  140,  140,  140,  153,  126,  147,
+      147,  147,  153,  148,  147,  147,  147,  158,  148,  165,
+      157,  156,  155,  151,  150,  149,  146,  154,  145,  144,
+      143,  139,  154,   36,   36,   36,   36,   36,   36,   36,
+       36,   40,  138,  137,  136,   40,   40,   42,   42,   42,
+       42,   42,   42,   42,   42,   57,   57,   57,   57,   63,
+      135,   63,   65,  134,  165,   65,  133,   65,   65,   66,
+      132,  131,   66,   66,   66,   66,   72,  130,   72,   72,
+
+       75,   75,   75,   75,   75,   75,   75,   75,   77,   77,
+       77,   77,   77,   77,   77,   77,   91,  129,   91,   92,
+      128,   92,   92,  127,   92,   92,  124,  124,  124,  124,
+      124,  124,  124,  124,  152,  152,  152,  152,  152,  152,
+      152,  152,   60,   60,  123,  122,  121,  120,  119,  118,
+      117,   45,  116,  111,  115,  113,  112,  109,  108,  107,
+       46,  106,   93,   89,  105,  104,  103,  101,  100,   99,
+       98,   97,   96,   95,   78,   76,   93,   90,   89,   88,
+       58,   87,   86,   58,   84,   83,   82,   79,   78,   76,
+       73,  165,   59,   58,   54,   35,  165,   31,   23,   23,
+
+        9,  165,  165,  165,  165,  165,  165,  165,  165,  165,
+      165,  165,  165,  165,  165,  165,  165,  165,  165,  165,
+      165,  165,  165,  165,  165,  165,  165,  165,  165,  165,
+      165,  165,  165,  165,  165,  165,  165,  165,  165,  165,
+      165,  165,  165,  165,  165,  165,  165,  165
+    } ;
+
+static yyconst flex_int16_t yy_chk[449] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    3,    3,    3,
+        3,    7,    7,    7,  163,    3,   11,   11,   11,   18,
+       18,    3,    3,    3,    3,    3,    5,    5,    5,    5,
+        5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
+        5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
+        5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
+
+        5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
+        5,    5,    5,    8,   12,   12,   12,   14,   15,   16,
+        8,    8,    8,   17,   20,   20,   17,   23,   42,   24,
+       29,  162,   24,   29,   29,   29,   16,   14,   31,   44,
+       29,   17,  134,   17,  134,   42,   17,   24,   17,   24,
+       76,   17,   24,   76,   24,   15,   44,   24,   36,   23,
+       26,   26,   26,   26,   34,   34,   34,   26,  161,   48,
+       31,   32,   32,   32,   26,   26,   26,   26,   36,   48,
+       32,   32,   32,   33,   33,   33,   60,  160,   74,   91,
+       91,   66,   33,   33,   66,   66,   66,  114,   60,   60,
+
+       60,   66,   68,   68,   68,   74,   85,   99,  124,  133,
+      102,   68,   68,   99,  102,  157,  156,  114,   85,   85,
+       85,  133,  133,  133,  140,  140,  140,  148,  124,  143,
+      143,  143,  152,  143,  147,  147,  147,  155,  147,  154,
+      151,  150,  149,  146,  145,  144,  142,  148,  141,  138,
+      137,  132,  152,  166,  166,  166,  166,  166,  166,  166,
+      166,  167,  131,  130,  129,  167,  167,  168,  168,  168,
+      168,  168,  168,  168,  168,  169,  169,  169,  169,  170,
+      128,  170,  171,  127,  126,  171,  125,  171,  171,  172,
+      123,  122,  172,  172,  172,  172,  173,  121,  173,  173,
+
+      174,  174,  174,  174,  174,  174,  174,  174,  175,  175,
+      175,  175,  175,  175,  175,  175,  176,  120,  176,  177,
+      119,  177,  177,  118,  177,  177,  178,  178,  178,  178,
+      178,  178,  178,  178,  179,  179,  179,  179,  179,  179,
+      179,  179,  116,  115,  113,  112,  111,  110,  109,  108,
+      107,  106,  105,  104,  103,  101,  100,   98,   97,   96,
+       95,   94,   92,   90,   88,   87,   86,   84,   83,   82,
+       81,   80,   79,   78,   77,   75,   73,   70,   69,   67,
+       64,   62,   61,   57,   51,   50,   49,   47,   46,   45,
+       41,   38,   22,   21,   19,   13,    9,    6,    4,    2,
+
+      165,  165,  165,  165,  165,  165,  165,  165,  165,  165,
+      165,  165,  165,  165,  165,  165,  165,  165,  165,  165,
+      165,  165,  165,  165,  165,  165,  165,  165,  165,  165,
+      165,  165,  165,  165,  165,  165,  165,  165,  165,  165,
+      165,  165,  165,  165,  165,  165,  165,  165
+    } ;
+
+static yy_state_type yy_last_accepting_state;
+static char *yy_last_accepting_cpos;
+
+extern int yy_flex_debug;
+int yy_flex_debug = 0;
+
+/* The intent behind this definition is that it'll catch
+ * any uses of REJECT which flex missed.
+ */
+#define REJECT reject_used_but_not_detected
+#define yymore() yymore_used_but_not_detected
+#define YY_MORE_ADJ 0
+#define YY_RESTORE_YY_MORE_OFFSET
+char *yytext;
+#line 1 "dtc-lexer.l"
+/*
+ * (C) Copyright David Gibson <dwg@au1.ibm.com>, IBM Corporation.  2005.
+ *
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307
+ *                                                                   USA
+ */
+#define YY_NO_INPUT 1
+
+
+
+#line 37 "dtc-lexer.l"
+#include "dtc.h"
+#include "srcpos.h"
+#include "dtc-parser.tab.h"
+
+YYLTYPE yylloc;
+extern bool treesource_error;
+
+/* CAUTION: this will stop working if we ever use yyless() or yyunput() */
+#define	YY_USER_ACTION \
+	{ \
+		srcpos_update(&yylloc, yytext, yyleng); \
+	}
+
+/*#define LEXDEBUG	1*/
+
+#ifdef LEXDEBUG
+#define DPRINT(fmt, ...)	fprintf(stderr, fmt, ##__VA_ARGS__)
+#else
+#define DPRINT(fmt, ...)	do { } while (0)
+#endif
+
+static int dts_version = 1;
+
+#define BEGIN_DEFAULT()		DPRINT("<V1>\n"); \
+				BEGIN(V1); \
+
+static void push_input_file(const char *filename);
+static bool pop_input_file(void);
+static void PRINTF(1, 2) lexical_error(const char *fmt, ...);
+
+#line 669 "dtc-lexer.lex.c"
+
+#define INITIAL 0
+#define BYTESTRING 1
+#define PROPNODENAME 2
+#define V1 3
+
+#ifndef YY_NO_UNISTD_H
+/* Special case for "unistd.h", since it is non-ANSI. We include it way
+ * down here because we want the user's section 1 to have been scanned first.
+ * The user has a chance to override it with an option.
+ */
+#include <unistd.h>
+#endif
+
+#ifndef YY_EXTRA_TYPE
+#define YY_EXTRA_TYPE void *
+#endif
+
+static int yy_init_globals (void );
+
+/* Accessor methods to globals.
+   These are made visible to non-reentrant scanners for convenience. */
+
+int yylex_destroy (void );
+
+int yyget_debug (void );
+
+void yyset_debug (int debug_flag  );
+
+YY_EXTRA_TYPE yyget_extra (void );
+
+void yyset_extra (YY_EXTRA_TYPE user_defined  );
+
+FILE *yyget_in (void );
+
+void yyset_in  (FILE * in_str  );
+
+FILE *yyget_out (void );
+
+void yyset_out  (FILE * out_str  );
+
+int yyget_leng (void );
+
+char *yyget_text (void );
+
+int yyget_lineno (void );
+
+void yyset_lineno (int line_number  );
+
+/* Macros after this point can all be overridden by user definitions in
+ * section 1.
+ */
+
+#ifndef YY_SKIP_YYWRAP
+#ifdef __cplusplus
+extern "C" int yywrap (void );
+#else
+extern int yywrap (void );
+#endif
+#endif
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char *,yyconst char *,int );
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * );
+#endif
+
+#ifndef YY_NO_INPUT
+
+#ifdef __cplusplus
+static int yyinput (void );
+#else
+static int input (void );
+#endif
+
+#endif
+
+/* Amount of stuff to slurp up with each read. */
+#ifndef YY_READ_BUF_SIZE
+#ifdef __ia64__
+/* On IA-64, the buffer size is 16k, not 8k */
+#define YY_READ_BUF_SIZE 16384
+#else
+#define YY_READ_BUF_SIZE 8192
+#endif /* __ia64__ */
+#endif
+
+/* Copy whatever the last rule matched to the standard output. */
+#ifndef ECHO
+/* This used to be an fputs(), but since the string might contain NUL's,
+ * we now use fwrite().
+ */
+#define ECHO do { if (fwrite( yytext, yyleng, 1, yyout )) {} } while (0)
+#endif
+
+/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
+ * is returned in "result".
+ */
+#ifndef YY_INPUT
+#define YY_INPUT(buf,result,max_size) \
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
+		{ \
+		int c = '*'; \
+		size_t n; \
+		for ( n = 0; n < max_size && \
+			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
+			buf[n] = (char) c; \
+		if ( c == '\n' ) \
+			buf[n++] = (char) c; \
+		if ( c == EOF && ferror( yyin ) ) \
+			YY_FATAL_ERROR( "input in flex scanner failed" ); \
+		result = n; \
+		} \
+	else \
+		{ \
+		errno=0; \
+		while ( (result = fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \
+			{ \
+			if( errno != EINTR) \
+				{ \
+				YY_FATAL_ERROR( "input in flex scanner failed" ); \
+				break; \
+				} \
+			errno=0; \
+			clearerr(yyin); \
+			} \
+		}\
+\
+
+#endif
+
+/* No semi-colon after return; correct usage is to write "yyterminate();" -
+ * we don't want an extra ';' after the "return" because that will cause
+ * some compilers to complain about unreachable statements.
+ */
+#ifndef yyterminate
+#define yyterminate() return YY_NULL
+#endif
+
+/* Number of entries by which start-condition stack grows. */
+#ifndef YY_START_STACK_INCR
+#define YY_START_STACK_INCR 25
+#endif
+
+/* Report a fatal error. */
+#ifndef YY_FATAL_ERROR
+#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
+#endif
+
+/* end tables serialization structures and prototypes */
+
+/* Default declaration of generated scanner - a define so the user can
+ * easily add parameters.
+ */
+#ifndef YY_DECL
+#define YY_DECL_IS_OURS 1
+
+extern int yylex (void);
+
+#define YY_DECL int yylex (void)
+#endif /* !YY_DECL */
+
+/* Code executed at the beginning of each rule, after yytext and yyleng
+ * have been set up.
+ */
+#ifndef YY_USER_ACTION
+#define YY_USER_ACTION
+#endif
+
+/* Code executed at the end of each rule. */
+#ifndef YY_BREAK
+#define YY_BREAK break;
+#endif
+
+#define YY_RULE_SETUP \
+	if ( yyleng > 0 ) \
+		YY_CURRENT_BUFFER_LVALUE->yy_at_bol = \
+				(yytext[yyleng - 1] == '\n'); \
+	YY_USER_ACTION
+
+/** The main scanner function which does all the work.
+ */
+YY_DECL
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp, *yy_bp;
+	register int yy_act;
+    
+#line 69 "dtc-lexer.l"
+
+#line 862 "dtc-lexer.lex.c"
+
+	if ( !(yy_init) )
+		{
+		(yy_init) = 1;
+
+#ifdef YY_USER_INIT
+		YY_USER_INIT;
+#endif
+
+		if ( ! (yy_start) )
+			(yy_start) = 1;	/* first start state */
+
+		if ( ! yyin )
+			yyin = stdin;
+
+		if ( ! yyout )
+			yyout = stdout;
+
+		if ( ! YY_CURRENT_BUFFER ) {
+			yyensure_buffer_stack ();
+			YY_CURRENT_BUFFER_LVALUE =
+				yy_create_buffer(yyin,YY_BUF_SIZE );
+		}
+
+		yy_load_buffer_state( );
+		}
+
+	while ( 1 )		/* loops until end-of-file is reached */
+		{
+		yy_cp = (yy_c_buf_p);
+
+		/* Support of yytext. */
+		*yy_cp = (yy_hold_char);
+
+		/* yy_bp points to the position in yy_ch_buf of the start of
+		 * the current run.
+		 */
+		yy_bp = yy_cp;
+
+		yy_current_state = (yy_start);
+		yy_current_state += YY_AT_BOL();
+yy_match:
+		do
+			{
+			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
+			if ( yy_accept[yy_current_state] )
+				{
+				(yy_last_accepting_state) = yy_current_state;
+				(yy_last_accepting_cpos) = yy_cp;
+				}
+			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+				{
+				yy_current_state = (int) yy_def[yy_current_state];
+				if ( yy_current_state >= 166 )
+					yy_c = yy_meta[(unsigned int) yy_c];
+				}
+			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+			++yy_cp;
+			}
+		while ( yy_current_state != 165 );
+		yy_cp = (yy_last_accepting_cpos);
+		yy_current_state = (yy_last_accepting_state);
+
+yy_find_action:
+		yy_act = yy_accept[yy_current_state];
+
+		YY_DO_BEFORE_ACTION;
+
+do_action:	/* This label is used only to access EOF actions. */
+
+		switch ( yy_act )
+	{ /* beginning of action switch */
+			case 0: /* must back up */
+			/* undo the effects of YY_DO_BEFORE_ACTION */
+			*yy_cp = (yy_hold_char);
+			yy_cp = (yy_last_accepting_cpos);
+			yy_current_state = (yy_last_accepting_state);
+			goto yy_find_action;
+
+case 1:
+/* rule 1 can match eol */
+YY_RULE_SETUP
+#line 70 "dtc-lexer.l"
+{
+			char *name = strchr(yytext, '\"') + 1;
+			yytext[yyleng-1] = '\0';
+			push_input_file(name);
+		}
+	YY_BREAK
+case 2:
+/* rule 2 can match eol */
+YY_RULE_SETUP
+#line 76 "dtc-lexer.l"
+{
+			char *line, *fnstart, *fnend;
+			struct data fn;
+			/* skip text before line # */
+			line = yytext;
+			while (!isdigit((unsigned char)*line))
+				line++;
+
+			/* regexp ensures that first and list "
+			 * in the whole yytext are those at
+			 * beginning and end of the filename string */
+			fnstart = memchr(yytext, '"', yyleng);
+			for (fnend = yytext + yyleng - 1;
+			     *fnend != '"'; fnend--)
+				;
+			assert(fnstart && fnend && (fnend > fnstart));
+
+			fn = data_copy_escape_string(fnstart + 1,
+						     fnend - fnstart - 1);
+
+			/* Don't allow nuls in filenames */
+			if (memchr(fn.val, '\0', fn.len - 1))
+				lexical_error("nul in line number directive");
+
+			/* -1 since #line is the number of the next line */
+			srcpos_set_line(xstrdup(fn.val), atoi(line) - 1);
+			data_free(fn);
+		}
+	YY_BREAK
+case YY_STATE_EOF(INITIAL):
+case YY_STATE_EOF(BYTESTRING):
+case YY_STATE_EOF(PROPNODENAME):
+case YY_STATE_EOF(V1):
+#line 105 "dtc-lexer.l"
+{
+			if (!pop_input_file()) {
+				yyterminate();
+			}
+		}
+	YY_BREAK
+case 3:
+/* rule 3 can match eol */
+YY_RULE_SETUP
+#line 111 "dtc-lexer.l"
+{
+			DPRINT("String: %s\n", yytext);
+			yylval.data = data_copy_escape_string(yytext+1,
+					yyleng-2);
+			return DT_STRING;
+		}
+	YY_BREAK
+case 4:
+YY_RULE_SETUP
+#line 118 "dtc-lexer.l"
+{
+			DPRINT("Keyword: /dts-v1/\n");
+			dts_version = 1;
+			BEGIN_DEFAULT();
+			return DT_V1;
+		}
+	YY_BREAK
+case 5:
+YY_RULE_SETUP
+#line 125 "dtc-lexer.l"
+{
+			DPRINT("Keyword: /plugin/\n");
+			return DT_PLUGIN;
+		}
+	YY_BREAK
+case 6:
+YY_RULE_SETUP
+#line 130 "dtc-lexer.l"
+{
+			DPRINT("Keyword: /memreserve/\n");
+			BEGIN_DEFAULT();
+			return DT_MEMRESERVE;
+		}
+	YY_BREAK
+case 7:
+YY_RULE_SETUP
+#line 136 "dtc-lexer.l"
+{
+			DPRINT("Keyword: /bits/\n");
+			BEGIN_DEFAULT();
+			return DT_BITS;
+		}
+	YY_BREAK
+case 8:
+YY_RULE_SETUP
+#line 142 "dtc-lexer.l"
+{
+			DPRINT("Keyword: /delete-property/\n");
+			DPRINT("<PROPNODENAME>\n");
+			BEGIN(PROPNODENAME);
+			return DT_DEL_PROP;
+		}
+	YY_BREAK
+case 9:
+YY_RULE_SETUP
+#line 149 "dtc-lexer.l"
+{
+			DPRINT("Keyword: /delete-node/\n");
+			DPRINT("<PROPNODENAME>\n");
+			BEGIN(PROPNODENAME);
+			return DT_DEL_NODE;
+		}
+	YY_BREAK
+case 10:
+YY_RULE_SETUP
+#line 156 "dtc-lexer.l"
+{
+			DPRINT("Label: %s\n", yytext);
+			yylval.labelref = xstrdup(yytext);
+			yylval.labelref[yyleng-1] = '\0';
+			return DT_LABEL;
+		}
+	YY_BREAK
+case 11:
+YY_RULE_SETUP
+#line 163 "dtc-lexer.l"
+{
+			char *e;
+			DPRINT("Integer Literal: '%s'\n", yytext);
+
+			errno = 0;
+			yylval.integer = strtoull(yytext, &e, 0);
+
+			if (*e && e[strspn(e, "UL")]) {
+				lexical_error("Bad integer literal '%s'",
+					      yytext);
+			}
+
+			if (errno == ERANGE)
+				lexical_error("Integer literal '%s' out of range",
+					      yytext);
+			else
+				/* ERANGE is the only strtoull error triggerable
+				 *  by strings matching the pattern */
+				assert(errno == 0);
+			return DT_LITERAL;
+		}
+	YY_BREAK
+case 12:
+/* rule 12 can match eol */
+YY_RULE_SETUP
+#line 185 "dtc-lexer.l"
+{
+			struct data d;
+			DPRINT("Character literal: %s\n", yytext);
+
+			d = data_copy_escape_string(yytext+1, yyleng-2);
+			if (d.len == 1) {
+				lexical_error("Empty character literal");
+				yylval.integer = 0;
+			} else {
+				yylval.integer = (unsigned char)d.val[0];
+
+				if (d.len > 2)
+					lexical_error("Character literal has %d"
+						      " characters instead of 1",
+						      d.len - 1);
+			}
+
+			data_free(d);
+			return DT_CHAR_LITERAL;
+		}
+	YY_BREAK
+case 13:
+YY_RULE_SETUP
+#line 206 "dtc-lexer.l"
+{	/* label reference */
+			DPRINT("Ref: %s\n", yytext+1);
+			yylval.labelref = xstrdup(yytext+1);
+			return DT_REF;
+		}
+	YY_BREAK
+case 14:
+YY_RULE_SETUP
+#line 212 "dtc-lexer.l"
+{	/* new-style path reference */
+			yytext[yyleng-1] = '\0';
+			DPRINT("Ref: %s\n", yytext+2);
+			yylval.labelref = xstrdup(yytext+2);
+			return DT_REF;
+		}
+	YY_BREAK
+case 15:
+YY_RULE_SETUP
+#line 219 "dtc-lexer.l"
+{
+			yylval.byte = strtol(yytext, NULL, 16);
+			DPRINT("Byte: %02x\n", (int)yylval.byte);
+			return DT_BYTE;
+		}
+	YY_BREAK
+case 16:
+YY_RULE_SETUP
+#line 225 "dtc-lexer.l"
+{
+			DPRINT("/BYTESTRING\n");
+			BEGIN_DEFAULT();
+			return ']';
+		}
+	YY_BREAK
+case 17:
+YY_RULE_SETUP
+#line 231 "dtc-lexer.l"
+{
+			DPRINT("PropNodeName: %s\n", yytext);
+			yylval.propnodename = xstrdup((yytext[0] == '\\') ?
+							yytext + 1 : yytext);
+			BEGIN_DEFAULT();
+			return DT_PROPNODENAME;
+		}
+	YY_BREAK
+case 18:
+YY_RULE_SETUP
+#line 239 "dtc-lexer.l"
+{
+			DPRINT("Binary Include\n");
+			return DT_INCBIN;
+		}
+	YY_BREAK
+case 19:
+/* rule 19 can match eol */
+YY_RULE_SETUP
+#line 244 "dtc-lexer.l"
+/* eat whitespace */
+	YY_BREAK
+case 20:
+/* rule 20 can match eol */
+YY_RULE_SETUP
+#line 245 "dtc-lexer.l"
+/* eat C-style comments */
+	YY_BREAK
+case 21:
+/* rule 21 can match eol */
+YY_RULE_SETUP
+#line 246 "dtc-lexer.l"
+/* eat C++-style comments */
+	YY_BREAK
+case 22:
+YY_RULE_SETUP
+#line 248 "dtc-lexer.l"
+{ return DT_LSHIFT; };
+	YY_BREAK
+case 23:
+YY_RULE_SETUP
+#line 249 "dtc-lexer.l"
+{ return DT_RSHIFT; };
+	YY_BREAK
+case 24:
+YY_RULE_SETUP
+#line 250 "dtc-lexer.l"
+{ return DT_LE; };
+	YY_BREAK
+case 25:
+YY_RULE_SETUP
+#line 251 "dtc-lexer.l"
+{ return DT_GE; };
+	YY_BREAK
+case 26:
+YY_RULE_SETUP
+#line 252 "dtc-lexer.l"
+{ return DT_EQ; };
+	YY_BREAK
+case 27:
+YY_RULE_SETUP
+#line 253 "dtc-lexer.l"
+{ return DT_NE; };
+	YY_BREAK
+case 28:
+YY_RULE_SETUP
+#line 254 "dtc-lexer.l"
+{ return DT_AND; };
+	YY_BREAK
+case 29:
+YY_RULE_SETUP
+#line 255 "dtc-lexer.l"
+{ return DT_OR; };
+	YY_BREAK
+case 30:
+YY_RULE_SETUP
+#line 257 "dtc-lexer.l"
+{
+			DPRINT("Char: %c (\\x%02x)\n", yytext[0],
+				(unsigned)yytext[0]);
+			if (yytext[0] == '[') {
+				DPRINT("<BYTESTRING>\n");
+				BEGIN(BYTESTRING);
+			}
+			if ((yytext[0] == '{')
+			    || (yytext[0] == ';')) {
+				DPRINT("<PROPNODENAME>\n");
+				BEGIN(PROPNODENAME);
+			}
+			return yytext[0];
+		}
+	YY_BREAK
+case 31:
+YY_RULE_SETUP
+#line 272 "dtc-lexer.l"
+ECHO;
+	YY_BREAK
+#line 1260 "dtc-lexer.lex.c"
+
+	case YY_END_OF_BUFFER:
+		{
+		/* Amount of text matched not including the EOB char. */
+		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;
+
+		/* Undo the effects of YY_DO_BEFORE_ACTION. */
+		*yy_cp = (yy_hold_char);
+		YY_RESTORE_YY_MORE_OFFSET
+
+		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
+			{
+			/* We're scanning a new file or input source.  It's
+			 * possible that this happened because the user
+			 * just pointed yyin at a new source and called
+			 * yylex().  If so, then we have to assure
+			 * consistency between YY_CURRENT_BUFFER and our
+			 * globals.  Here is the right place to do so, because
+			 * this is the first action (other than possibly a
+			 * back-up) that will match for the new input source.
+			 */
+			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
+			}
+
+		/* Note that here we test for yy_c_buf_p "<=" to the position
+		 * of the first EOB in the buffer, since yy_c_buf_p will
+		 * already have been incremented past the NUL character
+		 * (since all states make transitions on EOB to the
+		 * end-of-buffer state).  Contrast this with the test
+		 * in input().
+		 */
+		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			{ /* This was really a NUL. */
+			yy_state_type yy_next_state;
+
+			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;
+
+			yy_current_state = yy_get_previous_state(  );
+
+			/* Okay, we're now positioned to make the NUL
+			 * transition.  We couldn't have
+			 * yy_get_previous_state() go ahead and do it
+			 * for us because it doesn't know how to deal
+			 * with the possibility of jamming (and we don't
+			 * want to build jamming into it because then it
+			 * will run more slowly).
+			 */
+
+			yy_next_state = yy_try_NUL_trans( yy_current_state );
+
+			yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+
+			if ( yy_next_state )
+				{
+				/* Consume the NUL. */
+				yy_cp = ++(yy_c_buf_p);
+				yy_current_state = yy_next_state;
+				goto yy_match;
+				}
+
+			else
+				{
+				yy_cp = (yy_last_accepting_cpos);
+				yy_current_state = (yy_last_accepting_state);
+				goto yy_find_action;
+				}
+			}
+
+		else switch ( yy_get_next_buffer(  ) )
+			{
+			case EOB_ACT_END_OF_FILE:
+				{
+				(yy_did_buffer_switch_on_eof) = 0;
+
+				if ( yywrap( ) )
+					{
+					/* Note: because we've taken care in
+					 * yy_get_next_buffer() to have set up
+					 * yytext, we can now set up
+					 * yy_c_buf_p so that if some total
+					 * hoser (like flex itself) wants to
+					 * call the scanner after we return the
+					 * YY_NULL, it'll still work - another
+					 * YY_NULL will get returned.
+					 */
+					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;
+
+					yy_act = YY_STATE_EOF(YY_START);
+					goto do_action;
+					}
+
+				else
+					{
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+					}
+				break;
+				}
+
+			case EOB_ACT_CONTINUE_SCAN:
+				(yy_c_buf_p) =
+					(yytext_ptr) + yy_amount_of_matched_text;
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_match;
+
+			case EOB_ACT_LAST_MATCH:
+				(yy_c_buf_p) =
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_find_action;
+			}
+		break;
+		}
+
+	default:
+		YY_FATAL_ERROR(
+			"fatal flex scanner internal error--no action found" );
+	} /* end of action switch */
+		} /* end of scanning one token */
+} /* end of yylex */
+
+/* yy_get_next_buffer - try to read in a new buffer
+ *
+ * Returns a code representing an action:
+ *	EOB_ACT_LAST_MATCH -
+ *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
+ *	EOB_ACT_END_OF_FILE - end of file
+ */
+static int yy_get_next_buffer (void)
+{
+    	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
+	register char *source = (yytext_ptr);
+	register int number_to_move, i;
+	int ret_val;
+
+	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
+		YY_FATAL_ERROR(
+		"fatal flex scanner internal error--end of buffer missed" );
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
+		{ /* Don't try to fill the buffer, so this is an EOF. */
+		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
+			{
+			/* We matched a single character, the EOB, so
+			 * treat this as a final EOF.
+			 */
+			return EOB_ACT_END_OF_FILE;
+			}
+
+		else
+			{
+			/* We matched some text prior to the EOB, first
+			 * process it.
+			 */
+			return EOB_ACT_LAST_MATCH;
+			}
+		}
+
+	/* Try to read more data. */
+
+	/* First move last chars to start of buffer. */
+	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;
+
+	for ( i = 0; i < number_to_move; ++i )
+		*(dest++) = *(source++);
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
+		/* don't do the read, it's not guaranteed to return an EOF,
+		 * just force an EOF
+		 */
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;
+
+	else
+		{
+			int num_to_read =
+			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
+
+		while ( num_to_read <= 0 )
+			{ /* Not enough room in the buffer - grow it. */
+
+			/* just a shorter name for the current buffer */
+			YY_BUFFER_STATE b = YY_CURRENT_BUFFER;
+
+			int yy_c_buf_p_offset =
+				(int) ((yy_c_buf_p) - b->yy_ch_buf);
+
+			if ( b->yy_is_our_buffer )
+				{
+				int new_size = b->yy_buf_size * 2;
+
+				if ( new_size <= 0 )
+					b->yy_buf_size += b->yy_buf_size / 8;
+				else
+					b->yy_buf_size *= 2;
+
+				b->yy_ch_buf = (char *)
+					/* Include room in for 2 EOB chars. */
+					yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2  );
+				}
+			else
+				/* Can't grow it, we don't own it. */
+				b->yy_ch_buf = 0;
+
+			if ( ! b->yy_ch_buf )
+				YY_FATAL_ERROR(
+				"fatal error - scanner input buffer overflow" );
+
+			(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];
+
+			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
+						number_to_move - 1;
+
+			}
+
+		if ( num_to_read > YY_READ_BUF_SIZE )
+			num_to_read = YY_READ_BUF_SIZE;
+
+		/* Read in more data. */
+		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
+			(yy_n_chars), (size_t) num_to_read );
+
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	if ( (yy_n_chars) == 0 )
+		{
+		if ( number_to_move == YY_MORE_ADJ )
+			{
+			ret_val = EOB_ACT_END_OF_FILE;
+			yyrestart(yyin  );
+			}
+
+		else
+			{
+			ret_val = EOB_ACT_LAST_MATCH;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
+				YY_BUFFER_EOF_PENDING;
+			}
+		}
+
+	else
+		ret_val = EOB_ACT_CONTINUE_SCAN;
+
+	if ((yy_size_t) ((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
+		/* Extend the array by 50%, plus the number we really need. */
+		yy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
+		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size  );
+		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
+			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
+	}
+
+	(yy_n_chars) += number_to_move;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;
+
+	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
+
+	return ret_val;
+}
+
+/* yy_get_previous_state - get the state just before the EOB char was reached */
+
+    static yy_state_type yy_get_previous_state (void)
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp;
+    
+	yy_current_state = (yy_start);
+	yy_current_state += YY_AT_BOL();
+
+	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
+		{
+		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
+		if ( yy_accept[yy_current_state] )
+			{
+			(yy_last_accepting_state) = yy_current_state;
+			(yy_last_accepting_cpos) = yy_cp;
+			}
+		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+			{
+			yy_current_state = (int) yy_def[yy_current_state];
+			if ( yy_current_state >= 166 )
+				yy_c = yy_meta[(unsigned int) yy_c];
+			}
+		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+		}
+
+	return yy_current_state;
+}
+
+/* yy_try_NUL_trans - try to make a transition on the NUL character
+ *
+ * synopsis
+ *	next_state = yy_try_NUL_trans( current_state );
+ */
+    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
+{
+	register int yy_is_jam;
+    	register char *yy_cp = (yy_c_buf_p);
+
+	register YY_CHAR yy_c = 1;
+	if ( yy_accept[yy_current_state] )
+		{
+		(yy_last_accepting_state) = yy_current_state;
+		(yy_last_accepting_cpos) = yy_cp;
+		}
+	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+		{
+		yy_current_state = (int) yy_def[yy_current_state];
+		if ( yy_current_state >= 166 )
+			yy_c = yy_meta[(unsigned int) yy_c];
+		}
+	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+	yy_is_jam = (yy_current_state == 165);
+
+	return yy_is_jam ? 0 : yy_current_state;
+}
+
+#ifndef YY_NO_INPUT
+#ifdef __cplusplus
+    static int yyinput (void)
+#else
+    static int input  (void)
+#endif
+
+{
+	int c;
+    
+	*(yy_c_buf_p) = (yy_hold_char);
+
+	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
+		{
+		/* yy_c_buf_p now points to the character we want to return.
+		 * If this occurs *before* the EOB characters, then it's a
+		 * valid NUL; if not, then we've hit the end of the buffer.
+		 */
+		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			/* This was really a NUL. */
+			*(yy_c_buf_p) = '\0';
+
+		else
+			{ /* need more input */
+			int offset = (yy_c_buf_p) - (yytext_ptr);
+			++(yy_c_buf_p);
+
+			switch ( yy_get_next_buffer(  ) )
+				{
+				case EOB_ACT_LAST_MATCH:
+					/* This happens because yy_g_n_b()
+					 * sees that we've accumulated a
+					 * token and flags that we need to
+					 * try matching the token before
+					 * proceeding.  But for input(),
+					 * there's no matching to consider.
+					 * So convert the EOB_ACT_LAST_MATCH
+					 * to EOB_ACT_END_OF_FILE.
+					 */
+
+					/* Reset buffer status. */
+					yyrestart(yyin );
+
+					/*FALLTHROUGH*/
+
+				case EOB_ACT_END_OF_FILE:
+					{
+					if ( yywrap( ) )
+						return EOF;
+
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+#ifdef __cplusplus
+					return yyinput();
+#else
+					return input();
+#endif
+					}
+
+				case EOB_ACT_CONTINUE_SCAN:
+					(yy_c_buf_p) = (yytext_ptr) + offset;
+					break;
+				}
+			}
+		}
+
+	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
+	*(yy_c_buf_p) = '\0';	/* preserve yytext */
+	(yy_hold_char) = *++(yy_c_buf_p);
+
+	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = (c == '\n');
+
+	return c;
+}
+#endif	/* ifndef YY_NO_INPUT */
+
+/** Immediately switch to a different input stream.
+ * @param input_file A readable stream.
+ * 
+ * @note This function does not reset the start condition to @c INITIAL .
+ */
+    void yyrestart  (FILE * input_file )
+{
+    
+	if ( ! YY_CURRENT_BUFFER ){
+        yyensure_buffer_stack ();
+		YY_CURRENT_BUFFER_LVALUE =
+            yy_create_buffer(yyin,YY_BUF_SIZE );
+	}
+
+	yy_init_buffer(YY_CURRENT_BUFFER,input_file );
+	yy_load_buffer_state( );
+}
+
+/** Switch to a different input buffer.
+ * @param new_buffer The new input buffer.
+ * 
+ */
+    void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
+{
+    
+	/* TODO. We should be able to replace this entire function body
+	 * with
+	 *		yypop_buffer_state();
+	 *		yypush_buffer_state(new_buffer);
+     */
+	yyensure_buffer_stack ();
+	if ( YY_CURRENT_BUFFER == new_buffer )
+		return;
+
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+	yy_load_buffer_state( );
+
+	/* We don't actually know whether we did this switch during
+	 * EOF (yywrap()) processing, but the only time this flag
+	 * is looked at is after yywrap() is called, so it's safe
+	 * to go ahead and always set it.
+	 */
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+static void yy_load_buffer_state  (void)
+{
+    	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
+	yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
+	(yy_hold_char) = *(yy_c_buf_p);
+}
+
+/** Allocate and initialize an input buffer state.
+ * @param file A readable stream.
+ * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
+ * 
+ * @return the allocated buffer state.
+ */
+    YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size )
+{
+	YY_BUFFER_STATE b;
+    
+	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
+
+	b->yy_buf_size = size;
+
+	/* yy_ch_buf has to be 2 characters longer than the size given because
+	 * we need to put in 2 end-of-buffer characters.
+	 */
+	b->yy_ch_buf = (char *) yyalloc(b->yy_buf_size + 2  );
+	if ( ! b->yy_ch_buf )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
+
+	b->yy_is_our_buffer = 1;
+
+	yy_init_buffer(b,file );
+
+	return b;
+}
+
+/** Destroy the buffer.
+ * @param b a buffer created with yy_create_buffer()
+ * 
+ */
+    void yy_delete_buffer (YY_BUFFER_STATE  b )
+{
+    
+	if ( ! b )
+		return;
+
+	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
+		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
+
+	if ( b->yy_is_our_buffer )
+		yyfree((void *) b->yy_ch_buf  );
+
+	yyfree((void *) b  );
+}
+
+/* Initializes or reinitializes a buffer.
+ * This function is sometimes called more than once on the same buffer,
+ * such as during a yyrestart() or at EOF.
+ */
+    static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )
+
+{
+	int oerrno = errno;
+    
+	yy_flush_buffer(b );
+
+	b->yy_input_file = file;
+	b->yy_fill_buffer = 1;
+
+    /* If b is the current buffer, then yy_init_buffer was _probably_
+     * called from yyrestart() or through yy_get_next_buffer.
+     * In that case, we don't want to reset the lineno or column.
+     */
+    if (b != YY_CURRENT_BUFFER){
+        b->yy_bs_lineno = 1;
+        b->yy_bs_column = 0;
+    }
+
+        b->yy_is_interactive = 0;
+    
+	errno = oerrno;
+}
+
+/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
+ * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
+ * 
+ */
+    void yy_flush_buffer (YY_BUFFER_STATE  b )
+{
+    	if ( ! b )
+		return;
+
+	b->yy_n_chars = 0;
+
+	/* We always need two end-of-buffer characters.  The first causes
+	 * a transition to the end-of-buffer state.  The second causes
+	 * a jam in that state.
+	 */
+	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
+	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
+
+	b->yy_buf_pos = &b->yy_ch_buf[0];
+
+	b->yy_at_bol = 1;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	if ( b == YY_CURRENT_BUFFER )
+		yy_load_buffer_state( );
+}
+
+/** Pushes the new state onto the stack. The new state becomes
+ *  the current state. This function will allocate the stack
+ *  if necessary.
+ *  @param new_buffer The new state.
+ *  
+ */
+void yypush_buffer_state (YY_BUFFER_STATE new_buffer )
+{
+    	if (new_buffer == NULL)
+		return;
+
+	yyensure_buffer_stack();
+
+	/* This block is copied from yy_switch_to_buffer. */
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	/* Only push if top exists. Otherwise, replace top. */
+	if (YY_CURRENT_BUFFER)
+		(yy_buffer_stack_top)++;
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+
+	/* copied from yy_switch_to_buffer. */
+	yy_load_buffer_state( );
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+/** Removes and deletes the top of the stack, if present.
+ *  The next element becomes the new top.
+ *  
+ */
+void yypop_buffer_state (void)
+{
+    	if (!YY_CURRENT_BUFFER)
+		return;
+
+	yy_delete_buffer(YY_CURRENT_BUFFER );
+	YY_CURRENT_BUFFER_LVALUE = NULL;
+	if ((yy_buffer_stack_top) > 0)
+		--(yy_buffer_stack_top);
+
+	if (YY_CURRENT_BUFFER) {
+		yy_load_buffer_state( );
+		(yy_did_buffer_switch_on_eof) = 1;
+	}
+}
+
+/* Allocates the stack if it does not exist.
+ *  Guarantees space for at least one push.
+ */
+static void yyensure_buffer_stack (void)
+{
+	int num_to_alloc;
+    
+	if (!(yy_buffer_stack)) {
+
+		/* First allocation is just for 2 elements, since we don't know if this
+		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
+		 * immediate realloc on the next call.
+         */
+		num_to_alloc = 1;
+		(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc
+								(num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
+								  
+		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
+				
+		(yy_buffer_stack_max) = num_to_alloc;
+		(yy_buffer_stack_top) = 0;
+		return;
+	}
+
+	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){
+
+		/* Increase the buffer to prepare for a possible push. */
+		int grow_size = 8 /* arbitrary grow size */;
+
+		num_to_alloc = (yy_buffer_stack_max) + grow_size;
+		(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc
+								((yy_buffer_stack),
+								num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
+
+		/* zero only the new slots.*/
+		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
+		(yy_buffer_stack_max) = num_to_alloc;
+	}
+}
+
+/** Setup the input buffer state to scan directly from a user-specified character buffer.
+ * @param base the character buffer
+ * @param size the size in bytes of the character buffer
+ * 
+ * @return the newly allocated buffer state object. 
+ */
+YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )
+{
+	YY_BUFFER_STATE b;
+    
+	if ( size < 2 ||
+	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
+	     base[size-1] != YY_END_OF_BUFFER_CHAR )
+		/* They forgot to leave room for the EOB's. */
+		return 0;
+
+	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
+
+	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
+	b->yy_buf_pos = b->yy_ch_buf = base;
+	b->yy_is_our_buffer = 0;
+	b->yy_input_file = 0;
+	b->yy_n_chars = b->yy_buf_size;
+	b->yy_is_interactive = 0;
+	b->yy_at_bol = 1;
+	b->yy_fill_buffer = 0;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	yy_switch_to_buffer(b  );
+
+	return b;
+}
+
+/** Setup the input buffer state to scan a string. The next call to yylex() will
+ * scan from a @e copy of @a str.
+ * @param yystr a NUL-terminated string to scan
+ * 
+ * @return the newly allocated buffer state object.
+ * @note If you want to scan bytes that may contain NUL values, then use
+ *       yy_scan_bytes() instead.
+ */
+YY_BUFFER_STATE yy_scan_string (yyconst char * yystr )
+{
+    
+	return yy_scan_bytes(yystr,strlen(yystr) );
+}
+
+/** Setup the input buffer state to scan the given bytes. The next call to yylex() will
+ * scan from a @e copy of @a bytes.
+ * @param yybytes the byte buffer to scan
+ * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
+ * 
+ * @return the newly allocated buffer state object.
+ */
+YY_BUFFER_STATE yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len )
+{
+	YY_BUFFER_STATE b;
+	char *buf;
+	yy_size_t n;
+	int i;
+    
+	/* Get memory for full buffer, including space for trailing EOB's. */
+	n = _yybytes_len + 2;
+	buf = (char *) yyalloc(n  );
+	if ( ! buf )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
+
+	for ( i = 0; i < _yybytes_len; ++i )
+		buf[i] = yybytes[i];
+
+	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
+
+	b = yy_scan_buffer(buf,n );
+	if ( ! b )
+		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
+
+	/* It's okay to grow etc. this buffer, and we should throw it
+	 * away when we're done.
+	 */
+	b->yy_is_our_buffer = 1;
+
+	return b;
+}
+
+#ifndef YY_EXIT_FAILURE
+#define YY_EXIT_FAILURE 2
+#endif
+
+static void yy_fatal_error (yyconst char* msg )
+{
+    	(void) fprintf( stderr, "%s\n", msg );
+	exit( YY_EXIT_FAILURE );
+}
+
+/* Redefine yyless() so it works in section 3 code. */
+
+#undef yyless
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up yytext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		yytext[yyleng] = (yy_hold_char); \
+		(yy_c_buf_p) = yytext + yyless_macro_arg; \
+		(yy_hold_char) = *(yy_c_buf_p); \
+		*(yy_c_buf_p) = '\0'; \
+		yyleng = yyless_macro_arg; \
+		} \
+	while ( 0 )
+
+/* Accessor  methods (get/set functions) to struct members. */
+
+/** Get the current line number.
+ * 
+ */
+int yyget_lineno  (void)
+{
+        
+    return yylineno;
+}
+
+/** Get the input stream.
+ * 
+ */
+FILE *yyget_in  (void)
+{
+        return yyin;
+}
+
+/** Get the output stream.
+ * 
+ */
+FILE *yyget_out  (void)
+{
+        return yyout;
+}
+
+/** Get the length of the current token.
+ * 
+ */
+int yyget_leng  (void)
+{
+        return yyleng;
+}
+
+/** Get the current token.
+ * 
+ */
+
+char *yyget_text  (void)
+{
+        return yytext;
+}
+
+/** Set the current line number.
+ * @param line_number
+ * 
+ */
+void yyset_lineno (int  line_number )
+{
+    
+    yylineno = line_number;
+}
+
+/** Set the input stream. This does not discard the current
+ * input buffer.
+ * @param in_str A readable stream.
+ * 
+ * @see yy_switch_to_buffer
+ */
+void yyset_in (FILE *  in_str )
+{
+        yyin = in_str ;
+}
+
+void yyset_out (FILE *  out_str )
+{
+        yyout = out_str ;
+}
+
+int yyget_debug  (void)
+{
+        return yy_flex_debug;
+}
+
+void yyset_debug (int  bdebug )
+{
+        yy_flex_debug = bdebug ;
+}
+
+static int yy_init_globals (void)
+{
+        /* Initialization is the same as for the non-reentrant scanner.
+     * This function is called from yylex_destroy(), so don't allocate here.
+     */
+
+    (yy_buffer_stack) = 0;
+    (yy_buffer_stack_top) = 0;
+    (yy_buffer_stack_max) = 0;
+    (yy_c_buf_p) = (char *) 0;
+    (yy_init) = 0;
+    (yy_start) = 0;
+
+/* Defined in main.c */
+#ifdef YY_STDINIT
+    yyin = stdin;
+    yyout = stdout;
+#else
+    yyin = (FILE *) 0;
+    yyout = (FILE *) 0;
+#endif
+
+    /* For future reference: Set errno on error, since we are called by
+     * yylex_init()
+     */
+    return 0;
+}
+
+/* yylex_destroy is for both reentrant and non-reentrant scanners. */
+int yylex_destroy  (void)
+{
+    
+    /* Pop the buffer stack, destroying each element. */
+	while(YY_CURRENT_BUFFER){
+		yy_delete_buffer(YY_CURRENT_BUFFER  );
+		YY_CURRENT_BUFFER_LVALUE = NULL;
+		yypop_buffer_state();
+	}
+
+	/* Destroy the stack itself. */
+	yyfree((yy_buffer_stack) );
+	(yy_buffer_stack) = NULL;
+
+    /* Reset the globals. This is important in a non-reentrant scanner so the next time
+     * yylex() is called, initialization will occur. */
+    yy_init_globals( );
+
+    return 0;
+}
+
+/*
+ * Internal utility routines.
+ */
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )
+{
+	register int i;
+	for ( i = 0; i < n; ++i )
+		s1[i] = s2[i];
+}
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * s )
+{
+	register int n;
+	for ( n = 0; s[n]; ++n )
+		;
+
+	return n;
+}
+#endif
+
+void *yyalloc (yy_size_t  size )
+{
+	return (void *) malloc( size );
+}
+
+void *yyrealloc  (void * ptr, yy_size_t  size )
+{
+	/* The cast to (char *) in the following accommodates both
+	 * implementations that use char* generic pointers, and those
+	 * that use void* generic pointers.  It works with the latter
+	 * because both ANSI C and C++ allow castless assignment from
+	 * any pointer type to void*, and deal with argument conversions
+	 * as though doing an assignment.
+	 */
+	return (void *) realloc( (char *) ptr, size );
+}
+
+void yyfree (void * ptr )
+{
+	free( (char *) ptr );	/* see yyrealloc() for (char *) cast */
+}
+
+#define YYTABLES_NAME "yytables"
+
+#line 272 "dtc-lexer.l"
+
+
+
+static void push_input_file(const char *filename)
+{
+	assert(filename);
+
+	srcfile_push(filename);
+
+	yyin = current_srcfile->f;
+
+	yypush_buffer_state(yy_create_buffer(yyin,YY_BUF_SIZE));
+}
+
+
+static bool pop_input_file(void)
+{
+	if (srcfile_pop() == 0)
+		return false;
+
+	yypop_buffer_state();
+	yyin = current_srcfile->f;
+
+	return true;
+}
+
+static void lexical_error(const char *fmt, ...)
+{
+	va_list ap;
+
+	va_start(ap, fmt);
+	srcpos_verror(&yylloc, "Lexical error", fmt, ap);
+	va_end(ap);
+
+	treesource_error = true;
+}
+
diff -urN u-boot-2017.11/scripts/dtc/dtc-parser.tab.c u-boot-2017.11-itop4412/scripts/dtc/dtc-parser.tab.c
--- u-boot-2017.11/scripts/dtc/dtc-parser.tab.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-2017.11-itop4412/scripts/dtc/dtc-parser.tab.c	2019-02-16 09:37:36.000000000 +0800
@@ -0,0 +1,2301 @@
+/* A Bison parser, made by GNU Bison 3.0.2.  */
+
+/* Bison implementation for Yacc-like parsers in C
+
+   Copyright (C) 1984, 1989-1990, 2000-2013 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+/* C LALR(1) parser skeleton written by Richard Stallman, by
+   simplifying the original so-called "semantic" parser.  */
+
+/* All symbols defined below should begin with yy or YY, to avoid
+   infringing on user name space.  This should be done even for local
+   variables, as they might otherwise be expanded by user macros.
+   There are some unavoidable exceptions within include files to
+   define necessary library symbols; they are noted "INFRINGES ON
+   USER NAME SPACE" below.  */
+
+/* Identify Bison output.  */
+#define YYBISON 1
+
+/* Bison version.  */
+#define YYBISON_VERSION "3.0.2"
+
+/* Skeleton name.  */
+#define YYSKELETON_NAME "yacc.c"
+
+/* Pure parsers.  */
+#define YYPURE 0
+
+/* Push parsers.  */
+#define YYPUSH 0
+
+/* Pull parsers.  */
+#define YYPULL 1
+
+
+
+
+/* Copy the first part of user declarations.  */
+#line 20 "dtc-parser.y" /* yacc.c:339  */
+
+#include <stdio.h>
+#include <inttypes.h>
+
+#include "dtc.h"
+#include "srcpos.h"
+
+extern int yylex(void);
+extern void yyerror(char const *s);
+#define ERROR(loc, ...) \
+	do { \
+		srcpos_error((loc), "Error", __VA_ARGS__); \
+		treesource_error = true; \
+	} while (0)
+
+extern struct dt_info *parser_output;
+extern bool treesource_error;
+
+#line 85 "dtc-parser.tab.c" /* yacc.c:339  */
+
+# ifndef YY_NULLPTR
+#  if defined __cplusplus && 201103L <= __cplusplus
+#   define YY_NULLPTR nullptr
+#  else
+#   define YY_NULLPTR 0
+#  endif
+# endif
+
+/* Enabling verbose error messages.  */
+#ifdef YYERROR_VERBOSE
+# undef YYERROR_VERBOSE
+# define YYERROR_VERBOSE 1
+#else
+# define YYERROR_VERBOSE 0
+#endif
+
+/* In a future release of Bison, this section will be replaced
+   by #include "dtc-parser.tab.h".  */
+#ifndef YY_YY_DTC_PARSER_TAB_H_INCLUDED
+# define YY_YY_DTC_PARSER_TAB_H_INCLUDED
+/* Debug traces.  */
+#ifndef YYDEBUG
+# define YYDEBUG 0
+#endif
+#if YYDEBUG
+extern int yydebug;
+#endif
+
+/* Token type.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+  enum yytokentype
+  {
+    DT_V1 = 258,
+    DT_PLUGIN = 259,
+    DT_MEMRESERVE = 260,
+    DT_LSHIFT = 261,
+    DT_RSHIFT = 262,
+    DT_LE = 263,
+    DT_GE = 264,
+    DT_EQ = 265,
+    DT_NE = 266,
+    DT_AND = 267,
+    DT_OR = 268,
+    DT_BITS = 269,
+    DT_DEL_PROP = 270,
+    DT_DEL_NODE = 271,
+    DT_PROPNODENAME = 272,
+    DT_LITERAL = 273,
+    DT_CHAR_LITERAL = 274,
+    DT_BYTE = 275,
+    DT_STRING = 276,
+    DT_LABEL = 277,
+    DT_REF = 278,
+    DT_INCBIN = 279
+  };
+#endif
+
+/* Value type.  */
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef union YYSTYPE YYSTYPE;
+union YYSTYPE
+{
+#line 39 "dtc-parser.y" /* yacc.c:355  */
+
+	char *propnodename;
+	char *labelref;
+	uint8_t byte;
+	struct data data;
+
+	struct {
+		struct data	data;
+		int		bits;
+	} array;
+
+	struct property *prop;
+	struct property *proplist;
+	struct node *node;
+	struct node *nodelist;
+	struct reserve_info *re;
+	uint64_t integer;
+	unsigned int flags;
+
+#line 170 "dtc-parser.tab.c" /* yacc.c:355  */
+};
+# define YYSTYPE_IS_TRIVIAL 1
+# define YYSTYPE_IS_DECLARED 1
+#endif
+
+/* Location type.  */
+#if ! defined YYLTYPE && ! defined YYLTYPE_IS_DECLARED
+typedef struct YYLTYPE YYLTYPE;
+struct YYLTYPE
+{
+  int first_line;
+  int first_column;
+  int last_line;
+  int last_column;
+};
+# define YYLTYPE_IS_DECLARED 1
+# define YYLTYPE_IS_TRIVIAL 1
+#endif
+
+
+extern YYSTYPE yylval;
+extern YYLTYPE yylloc;
+int yyparse (void);
+
+#endif /* !YY_YY_DTC_PARSER_TAB_H_INCLUDED  */
+
+/* Copy the second part of user declarations.  */
+
+#line 199 "dtc-parser.tab.c" /* yacc.c:358  */
+
+#ifdef short
+# undef short
+#endif
+
+#ifdef YYTYPE_UINT8
+typedef YYTYPE_UINT8 yytype_uint8;
+#else
+typedef unsigned char yytype_uint8;
+#endif
+
+#ifdef YYTYPE_INT8
+typedef YYTYPE_INT8 yytype_int8;
+#else
+typedef signed char yytype_int8;
+#endif
+
+#ifdef YYTYPE_UINT16
+typedef YYTYPE_UINT16 yytype_uint16;
+#else
+typedef unsigned short int yytype_uint16;
+#endif
+
+#ifdef YYTYPE_INT16
+typedef YYTYPE_INT16 yytype_int16;
+#else
+typedef short int yytype_int16;
+#endif
+
+#ifndef YYSIZE_T
+# ifdef __SIZE_TYPE__
+#  define YYSIZE_T __SIZE_TYPE__
+# elif defined size_t
+#  define YYSIZE_T size_t
+# elif ! defined YYSIZE_T
+#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYSIZE_T size_t
+# else
+#  define YYSIZE_T unsigned int
+# endif
+#endif
+
+#define YYSIZE_MAXIMUM ((YYSIZE_T) -1)
+
+#ifndef YY_
+# if defined YYENABLE_NLS && YYENABLE_NLS
+#  if ENABLE_NLS
+#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
+#   define YY_(Msgid) dgettext ("bison-runtime", Msgid)
+#  endif
+# endif
+# ifndef YY_
+#  define YY_(Msgid) Msgid
+# endif
+#endif
+
+#ifndef YY_ATTRIBUTE
+# if (defined __GNUC__                                               \
+      && (2 < __GNUC__ || (__GNUC__ == 2 && 96 <= __GNUC_MINOR__)))  \
+     || defined __SUNPRO_C && 0x5110 <= __SUNPRO_C
+#  define YY_ATTRIBUTE(Spec) __attribute__(Spec)
+# else
+#  define YY_ATTRIBUTE(Spec) /* empty */
+# endif
+#endif
+
+#ifndef YY_ATTRIBUTE_PURE
+# define YY_ATTRIBUTE_PURE   YY_ATTRIBUTE ((__pure__))
+#endif
+
+#ifndef YY_ATTRIBUTE_UNUSED
+# define YY_ATTRIBUTE_UNUSED YY_ATTRIBUTE ((__unused__))
+#endif
+
+#if !defined _Noreturn \
+     && (!defined __STDC_VERSION__ || __STDC_VERSION__ < 201112)
+# if defined _MSC_VER && 1200 <= _MSC_VER
+#  define _Noreturn __declspec (noreturn)
+# else
+#  define _Noreturn YY_ATTRIBUTE ((__noreturn__))
+# endif
+#endif
+
+/* Suppress unused-variable warnings by "using" E.  */
+#if ! defined lint || defined __GNUC__
+# define YYUSE(E) ((void) (E))
+#else
+# define YYUSE(E) /* empty */
+#endif
+
+#if defined __GNUC__ && 407 <= __GNUC__ * 100 + __GNUC_MINOR__
+/* Suppress an incorrect diagnostic about yylval being uninitialized.  */
+# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN \
+    _Pragma ("GCC diagnostic push") \
+    _Pragma ("GCC diagnostic ignored \"-Wuninitialized\"")\
+    _Pragma ("GCC diagnostic ignored \"-Wmaybe-uninitialized\"")
+# define YY_IGNORE_MAYBE_UNINITIALIZED_END \
+    _Pragma ("GCC diagnostic pop")
+#else
+# define YY_INITIAL_VALUE(Value) Value
+#endif
+#ifndef YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+# define YY_IGNORE_MAYBE_UNINITIALIZED_END
+#endif
+#ifndef YY_INITIAL_VALUE
+# define YY_INITIAL_VALUE(Value) /* Nothing. */
+#endif
+
+
+#if ! defined yyoverflow || YYERROR_VERBOSE
+
+/* The parser invokes alloca or malloc; define the necessary symbols.  */
+
+# ifdef YYSTACK_USE_ALLOCA
+#  if YYSTACK_USE_ALLOCA
+#   ifdef __GNUC__
+#    define YYSTACK_ALLOC __builtin_alloca
+#   elif defined __BUILTIN_VA_ARG_INCR
+#    include <alloca.h> /* INFRINGES ON USER NAME SPACE */
+#   elif defined _AIX
+#    define YYSTACK_ALLOC __alloca
+#   elif defined _MSC_VER
+#    include <malloc.h> /* INFRINGES ON USER NAME SPACE */
+#    define alloca _alloca
+#   else
+#    define YYSTACK_ALLOC alloca
+#    if ! defined _ALLOCA_H && ! defined EXIT_SUCCESS
+#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+      /* Use EXIT_SUCCESS as a witness for stdlib.h.  */
+#     ifndef EXIT_SUCCESS
+#      define EXIT_SUCCESS 0
+#     endif
+#    endif
+#   endif
+#  endif
+# endif
+
+# ifdef YYSTACK_ALLOC
+   /* Pacify GCC's 'empty if-body' warning.  */
+#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (0)
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+    /* The OS might guarantee only one guard page at the bottom of the stack,
+       and a page size can be as small as 4096 bytes.  So we cannot safely
+       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
+       to allow for a few compiler-allocated temporary stack slots.  */
+#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
+#  endif
+# else
+#  define YYSTACK_ALLOC YYMALLOC
+#  define YYSTACK_FREE YYFREE
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
+#  endif
+#  if (defined __cplusplus && ! defined EXIT_SUCCESS \
+       && ! ((defined YYMALLOC || defined malloc) \
+             && (defined YYFREE || defined free)))
+#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#   ifndef EXIT_SUCCESS
+#    define EXIT_SUCCESS 0
+#   endif
+#  endif
+#  ifndef YYMALLOC
+#   define YYMALLOC malloc
+#   if ! defined malloc && ! defined EXIT_SUCCESS
+void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+#  ifndef YYFREE
+#   define YYFREE free
+#   if ! defined free && ! defined EXIT_SUCCESS
+void free (void *); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+# endif
+#endif /* ! defined yyoverflow || YYERROR_VERBOSE */
+
+
+#if (! defined yyoverflow \
+     && (! defined __cplusplus \
+         || (defined YYLTYPE_IS_TRIVIAL && YYLTYPE_IS_TRIVIAL \
+             && defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
+
+/* A type that is properly aligned for any stack member.  */
+union yyalloc
+{
+  yytype_int16 yyss_alloc;
+  YYSTYPE yyvs_alloc;
+  YYLTYPE yyls_alloc;
+};
+
+/* The size of the maximum gap between one aligned stack and the next.  */
+# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
+
+/* The size of an array large to enough to hold all stacks, each with
+   N elements.  */
+# define YYSTACK_BYTES(N) \
+     ((N) * (sizeof (yytype_int16) + sizeof (YYSTYPE) + sizeof (YYLTYPE)) \
+      + 2 * YYSTACK_GAP_MAXIMUM)
+
+# define YYCOPY_NEEDED 1
+
+/* Relocate STACK from its old location to the new one.  The
+   local variables YYSIZE and YYSTACKSIZE give the old and new number of
+   elements in the stack, and YYPTR gives the new location of the
+   stack.  Advance YYPTR to a properly aligned location for the next
+   stack.  */
+# define YYSTACK_RELOCATE(Stack_alloc, Stack)                           \
+    do                                                                  \
+      {                                                                 \
+        YYSIZE_T yynewbytes;                                            \
+        YYCOPY (&yyptr->Stack_alloc, Stack, yysize);                    \
+        Stack = &yyptr->Stack_alloc;                                    \
+        yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
+        yyptr += yynewbytes / sizeof (*yyptr);                          \
+      }                                                                 \
+    while (0)
+
+#endif
+
+#if defined YYCOPY_NEEDED && YYCOPY_NEEDED
+/* Copy COUNT objects from SRC to DST.  The source and destination do
+   not overlap.  */
+# ifndef YYCOPY
+#  if defined __GNUC__ && 1 < __GNUC__
+#   define YYCOPY(Dst, Src, Count) \
+      __builtin_memcpy (Dst, Src, (Count) * sizeof (*(Src)))
+#  else
+#   define YYCOPY(Dst, Src, Count)              \
+      do                                        \
+        {                                       \
+          YYSIZE_T yyi;                         \
+          for (yyi = 0; yyi < (Count); yyi++)   \
+            (Dst)[yyi] = (Src)[yyi];            \
+        }                                       \
+      while (0)
+#  endif
+# endif
+#endif /* !YYCOPY_NEEDED */
+
+/* YYFINAL -- State number of the termination state.  */
+#define YYFINAL  6
+/* YYLAST -- Last index in YYTABLE.  */
+#define YYLAST   138
+
+/* YYNTOKENS -- Number of terminals.  */
+#define YYNTOKENS  48
+/* YYNNTS -- Number of nonterminals.  */
+#define YYNNTS  30
+/* YYNRULES -- Number of rules.  */
+#define YYNRULES  84
+/* YYNSTATES -- Number of states.  */
+#define YYNSTATES  149
+
+/* YYTRANSLATE[YYX] -- Symbol number corresponding to YYX as returned
+   by yylex, with out-of-bounds checking.  */
+#define YYUNDEFTOK  2
+#define YYMAXUTOK   279
+
+#define YYTRANSLATE(YYX)                                                \
+  ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
+
+/* YYTRANSLATE[TOKEN-NUM] -- Symbol number corresponding to TOKEN-NUM
+   as returned by yylex, without out-of-bounds checking.  */
+static const yytype_uint8 yytranslate[] =
+{
+       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,    47,     2,     2,     2,    45,    41,     2,
+      33,    35,    44,    42,    34,    43,     2,    26,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,    38,    25,
+      36,    29,    30,    37,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,    31,     2,    32,    40,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,    27,    39,    28,    46,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
+       5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
+      15,    16,    17,    18,    19,    20,    21,    22,    23,    24
+};
+
+#if YYDEBUG
+  /* YYRLINE[YYN] -- Source line where rule number YYN was defined.  */
+static const yytype_uint16 yyrline[] =
+{
+       0,   109,   109,   117,   121,   128,   129,   139,   142,   149,
+     153,   161,   165,   170,   181,   191,   206,   214,   217,   224,
+     228,   232,   236,   244,   248,   252,   256,   260,   276,   286,
+     294,   297,   301,   308,   324,   329,   348,   362,   369,   370,
+     371,   378,   382,   383,   387,   388,   392,   393,   397,   398,
+     402,   403,   407,   408,   412,   413,   414,   418,   419,   420,
+     421,   422,   426,   427,   428,   432,   433,   434,   438,   439,
+     448,   457,   461,   462,   463,   464,   469,   472,   476,   484,
+     487,   491,   499,   503,   507
+};
+#endif
+
+#if YYDEBUG || YYERROR_VERBOSE || 0
+/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
+   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
+static const char *const yytname[] =
+{
+  "$end", "error", "$undefined", "DT_V1", "DT_PLUGIN", "DT_MEMRESERVE",
+  "DT_LSHIFT", "DT_RSHIFT", "DT_LE", "DT_GE", "DT_EQ", "DT_NE", "DT_AND",
+  "DT_OR", "DT_BITS", "DT_DEL_PROP", "DT_DEL_NODE", "DT_PROPNODENAME",
+  "DT_LITERAL", "DT_CHAR_LITERAL", "DT_BYTE", "DT_STRING", "DT_LABEL",
+  "DT_REF", "DT_INCBIN", "';'", "'/'", "'{'", "'}'", "'='", "'>'", "'['",
+  "']'", "'('", "','", "')'", "'<'", "'?'", "':'", "'|'", "'^'", "'&'",
+  "'+'", "'-'", "'*'", "'%'", "'~'", "'!'", "$accept", "sourcefile",
+  "header", "headers", "memreserves", "memreserve", "devicetree",
+  "nodedef", "proplist", "propdef", "propdata", "propdataprefix",
+  "arrayprefix", "integer_prim", "integer_expr", "integer_trinary",
+  "integer_or", "integer_and", "integer_bitor", "integer_bitxor",
+  "integer_bitand", "integer_eq", "integer_rela", "integer_shift",
+  "integer_add", "integer_mul", "integer_unary", "bytestring", "subnodes",
+  "subnode", YY_NULLPTR
+};
+#endif
+
+# ifdef YYPRINT
+/* YYTOKNUM[NUM] -- (External) token number corresponding to the
+   (internal) symbol number NUM (which must be that of a token).  */
+static const yytype_uint16 yytoknum[] =
+{
+       0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
+     265,   266,   267,   268,   269,   270,   271,   272,   273,   274,
+     275,   276,   277,   278,   279,    59,    47,   123,   125,    61,
+      62,    91,    93,    40,    44,    41,    60,    63,    58,   124,
+      94,    38,    43,    45,    42,    37,   126,    33
+};
+# endif
+
+#define YYPACT_NINF -44
+
+#define yypact_value_is_default(Yystate) \
+  (!!((Yystate) == (-44)))
+
+#define YYTABLE_NINF -1
+
+#define yytable_value_is_error(Yytable_value) \
+  0
+
+  /* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
+     STATE-NUM.  */
+static const yytype_int8 yypact[] =
+{
+      14,    27,    61,    14,     8,    18,   -44,   -44,    37,     8,
+      40,     8,    64,   -44,   -44,   -12,    37,   -44,    50,    52,
+     -44,   -44,   -12,   -12,   -12,   -44,    51,   -44,    -4,    78,
+      53,    54,    55,    17,     2,    30,    38,    -3,   -44,    66,
+     -44,   -44,    70,    72,    50,    50,   -44,   -44,   -44,   -44,
+     -12,   -12,   -12,   -12,   -12,   -12,   -12,   -12,   -12,   -12,
+     -12,   -12,   -12,   -12,   -12,   -12,   -12,   -12,   -12,   -44,
+       3,    73,    50,   -44,   -44,    78,    59,    53,    54,    55,
+      17,     2,     2,    30,    30,    30,    30,    38,    38,    -3,
+      -3,   -44,   -44,   -44,    82,    83,    44,     3,   -44,    74,
+       3,   -44,   -44,   -12,    76,    79,   -44,   -44,   -44,   -44,
+     -44,    80,   -44,   -44,   -44,   -44,   -44,   -10,    36,   -44,
+     -44,   -44,   -44,    85,   -44,   -44,   -44,    75,   -44,   -44,
+      21,    71,    88,    -6,   -44,   -44,   -44,   -44,   -44,    11,
+     -44,   -44,   -44,    37,   -44,    77,    37,    81,   -44
+};
+
+  /* YYDEFACT[STATE-NUM] -- Default reduction number in state STATE-NUM.
+     Performed when YYTABLE does not specify something else to do.  Zero
+     means the default is an error.  */
+static const yytype_uint8 yydefact[] =
+{
+       0,     0,     0,     5,     7,     3,     1,     6,     0,     0,
+       0,     7,     0,    38,    39,     0,     0,    10,     0,     2,
+       8,     4,     0,     0,     0,    72,     0,    41,    42,    44,
+      46,    48,    50,    52,    54,    57,    64,    67,    71,     0,
+      17,    11,     0,     0,     0,     0,    73,    74,    75,    40,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     9,
+      79,     0,     0,    14,    12,    45,     0,    47,    49,    51,
+      53,    55,    56,    60,    61,    59,    58,    62,    63,    65,
+      66,    69,    68,    70,     0,     0,     0,     0,    18,     0,
+      79,    15,    13,     0,     0,     0,    20,    30,    82,    22,
+      84,     0,    81,    80,    43,    21,    83,     0,     0,    16,
+      29,    19,    31,     0,    23,    32,    26,     0,    76,    34,
+       0,     0,     0,     0,    37,    36,    24,    35,    33,     0,
+      77,    78,    25,     0,    28,     0,     0,     0,    27
+};
+
+  /* YYPGOTO[NTERM-NUM].  */
+static const yytype_int8 yypgoto[] =
+{
+     -44,   -44,   -44,   103,    99,   104,   -44,   -43,   -44,   -21,
+     -44,   -44,   -44,    -8,    63,     9,   -44,    65,    67,    68,
+      69,    62,    26,     4,    22,    23,   -19,   -44,    20,    28
+};
+
+  /* YYDEFGOTO[NTERM-NUM].  */
+static const yytype_int16 yydefgoto[] =
+{
+      -1,     2,     3,     4,    10,    11,    19,    41,    70,    98,
+     117,   118,   130,    25,    26,    27,    28,    29,    30,    31,
+      32,    33,    34,    35,    36,    37,    38,   133,    99,   100
+};
+
+  /* YYTABLE[YYPACT[STATE-NUM]] -- What to do in state STATE-NUM.  If
+     positive, shift that token.  If negative, reduce the rule whose
+     number is the opposite.  If YYTABLE_NINF, syntax error.  */
+static const yytype_uint8 yytable[] =
+{
+      16,    73,    74,    46,    47,    48,    13,    14,    39,    50,
+      58,    59,   120,     8,   140,   121,   141,     1,    94,    95,
+      96,    15,    12,    66,   122,    97,   142,    56,    57,   102,
+       9,    22,    60,    51,    23,    24,    62,    63,    61,    13,
+      14,    67,    68,   134,   135,   143,   144,    91,    92,    93,
+     123,   136,     5,   108,    15,    13,    14,   124,   125,   126,
+     127,     6,    83,    84,    85,    86,    18,   128,    42,   106,
+      15,    40,   129,   107,    43,    44,   109,    40,    45,   112,
+      64,    65,    81,    82,    87,    88,    49,    89,    90,    21,
+      52,    69,    53,    71,    54,    72,    55,   103,   101,   104,
+     105,   115,   111,   131,   116,   119,     7,   138,   132,   139,
+      20,   146,   114,    17,    76,    75,   148,    80,     0,    77,
+     113,    78,   137,    79,     0,   110,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,   145,     0,     0,   147
+};
+
+static const yytype_int16 yycheck[] =
+{
+       8,    44,    45,    22,    23,    24,    18,    19,    16,    13,
+       8,     9,    22,     5,    20,    25,    22,     3,    15,    16,
+      17,    33,     4,    26,    34,    22,    32,    10,    11,    72,
+      22,    43,    30,    37,    46,    47,     6,     7,    36,    18,
+      19,    44,    45,    22,    23,    34,    35,    66,    67,    68,
+      14,    30,    25,    96,    33,    18,    19,    21,    22,    23,
+      24,     0,    58,    59,    60,    61,    26,    31,    16,    25,
+      33,    27,    36,    29,    22,    23,    97,    27,    26,   100,
+      42,    43,    56,    57,    62,    63,    35,    64,    65,    25,
+      12,    25,    39,    23,    40,    23,    41,    38,    25,    17,
+      17,    25,    28,    18,    25,    25,     3,    36,    33,    21,
+      11,    34,   103,     9,    51,    50,    35,    55,    -1,    52,
+     100,    53,   130,    54,    -1,    97,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,   143,    -1,    -1,   146
+};
+
+  /* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
+     symbol of state STATE-NUM.  */
+static const yytype_uint8 yystos[] =
+{
+       0,     3,    49,    50,    51,    25,     0,    51,     5,    22,
+      52,    53,     4,    18,    19,    33,    61,    53,    26,    54,
+      52,    25,    43,    46,    47,    61,    62,    63,    64,    65,
+      66,    67,    68,    69,    70,    71,    72,    73,    74,    61,
+      27,    55,    16,    22,    23,    26,    74,    74,    74,    35,
+      13,    37,    12,    39,    40,    41,    10,    11,     8,     9,
+      30,    36,     6,     7,    42,    43,    26,    44,    45,    25,
+      56,    23,    23,    55,    55,    65,    62,    66,    67,    68,
+      69,    70,    70,    71,    71,    71,    71,    72,    72,    73,
+      73,    74,    74,    74,    15,    16,    17,    22,    57,    76,
+      77,    25,    55,    38,    17,    17,    25,    29,    55,    57,
+      77,    28,    57,    76,    63,    25,    25,    58,    59,    25,
+      22,    25,    34,    14,    21,    22,    23,    24,    31,    36,
+      60,    18,    33,    75,    22,    23,    30,    61,    36,    21,
+      20,    22,    32,    34,    35,    61,    34,    61,    35
+};
+
+  /* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
+static const yytype_uint8 yyr1[] =
+{
+       0,    48,    49,    50,    50,    51,    51,    52,    52,    53,
+      53,    54,    54,    54,    54,    54,    55,    56,    56,    57,
+      57,    57,    57,    58,    58,    58,    58,    58,    58,    58,
+      59,    59,    59,    60,    60,    60,    60,    60,    61,    61,
+      61,    62,    63,    63,    64,    64,    65,    65,    66,    66,
+      67,    67,    68,    68,    69,    69,    69,    70,    70,    70,
+      70,    70,    71,    71,    71,    72,    72,    72,    73,    73,
+      73,    73,    74,    74,    74,    74,    75,    75,    75,    76,
+      76,    76,    77,    77,    77
+};
+
+  /* YYR2[YYN] -- Number of symbols on the right hand side of rule YYN.  */
+static const yytype_uint8 yyr2[] =
+{
+       0,     2,     3,     2,     4,     1,     2,     0,     2,     4,
+       2,     2,     3,     4,     3,     4,     5,     0,     2,     4,
+       2,     3,     2,     2,     3,     4,     2,     9,     5,     2,
+       0,     2,     2,     3,     1,     2,     2,     2,     1,     1,
+       3,     1,     1,     5,     1,     3,     1,     3,     1,     3,
+       1,     3,     1,     3,     1,     3,     3,     1,     3,     3,
+       3,     3,     3,     3,     1,     3,     3,     1,     3,     3,
+       3,     1,     1,     2,     2,     2,     0,     2,     2,     0,
+       2,     2,     2,     3,     2
+};
+
+
+#define yyerrok         (yyerrstatus = 0)
+#define yyclearin       (yychar = YYEMPTY)
+#define YYEMPTY         (-2)
+#define YYEOF           0
+
+#define YYACCEPT        goto yyacceptlab
+#define YYABORT         goto yyabortlab
+#define YYERROR         goto yyerrorlab
+
+
+#define YYRECOVERING()  (!!yyerrstatus)
+
+#define YYBACKUP(Token, Value)                                  \
+do                                                              \
+  if (yychar == YYEMPTY)                                        \
+    {                                                           \
+      yychar = (Token);                                         \
+      yylval = (Value);                                         \
+      YYPOPSTACK (yylen);                                       \
+      yystate = *yyssp;                                         \
+      goto yybackup;                                            \
+    }                                                           \
+  else                                                          \
+    {                                                           \
+      yyerror (YY_("syntax error: cannot back up")); \
+      YYERROR;                                                  \
+    }                                                           \
+while (0)
+
+/* Error token number */
+#define YYTERROR        1
+#define YYERRCODE       256
+
+
+/* YYLLOC_DEFAULT -- Set CURRENT to span from RHS[1] to RHS[N].
+   If N is 0, then set CURRENT to the empty location which ends
+   the previous symbol: RHS[0] (always defined).  */
+
+#ifndef YYLLOC_DEFAULT
+# define YYLLOC_DEFAULT(Current, Rhs, N)                                \
+    do                                                                  \
+      if (N)                                                            \
+        {                                                               \
+          (Current).first_line   = YYRHSLOC (Rhs, 1).first_line;        \
+          (Current).first_column = YYRHSLOC (Rhs, 1).first_column;      \
+          (Current).last_line    = YYRHSLOC (Rhs, N).last_line;         \
+          (Current).last_column  = YYRHSLOC (Rhs, N).last_column;       \
+        }                                                               \
+      else                                                              \
+        {                                                               \
+          (Current).first_line   = (Current).last_line   =              \
+            YYRHSLOC (Rhs, 0).last_line;                                \
+          (Current).first_column = (Current).last_column =              \
+            YYRHSLOC (Rhs, 0).last_column;                              \
+        }                                                               \
+    while (0)
+#endif
+
+#define YYRHSLOC(Rhs, K) ((Rhs)[K])
+
+
+/* Enable debugging if requested.  */
+#if YYDEBUG
+
+# ifndef YYFPRINTF
+#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYFPRINTF fprintf
+# endif
+
+# define YYDPRINTF(Args)                        \
+do {                                            \
+  if (yydebug)                                  \
+    YYFPRINTF Args;                             \
+} while (0)
+
+
+/* YY_LOCATION_PRINT -- Print the location on the stream.
+   This macro was not mandated originally: define only if we know
+   we won't break user code: when these are the locations we know.  */
+
+#ifndef YY_LOCATION_PRINT
+# if defined YYLTYPE_IS_TRIVIAL && YYLTYPE_IS_TRIVIAL
+
+/* Print *YYLOCP on YYO.  Private, do not rely on its existence. */
+
+YY_ATTRIBUTE_UNUSED
+static unsigned
+yy_location_print_ (FILE *yyo, YYLTYPE const * const yylocp)
+{
+  unsigned res = 0;
+  int end_col = 0 != yylocp->last_column ? yylocp->last_column - 1 : 0;
+  if (0 <= yylocp->first_line)
+    {
+      res += YYFPRINTF (yyo, "%d", yylocp->first_line);
+      if (0 <= yylocp->first_column)
+        res += YYFPRINTF (yyo, ".%d", yylocp->first_column);
+    }
+  if (0 <= yylocp->last_line)
+    {
+      if (yylocp->first_line < yylocp->last_line)
+        {
+          res += YYFPRINTF (yyo, "-%d", yylocp->last_line);
+          if (0 <= end_col)
+            res += YYFPRINTF (yyo, ".%d", end_col);
+        }
+      else if (0 <= end_col && yylocp->first_column < end_col)
+        res += YYFPRINTF (yyo, "-%d", end_col);
+    }
+  return res;
+ }
+
+#  define YY_LOCATION_PRINT(File, Loc)          \
+  yy_location_print_ (File, &(Loc))
+
+# else
+#  define YY_LOCATION_PRINT(File, Loc) ((void) 0)
+# endif
+#endif
+
+
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)                    \
+do {                                                                      \
+  if (yydebug)                                                            \
+    {                                                                     \
+      YYFPRINTF (stderr, "%s ", Title);                                   \
+      yy_symbol_print (stderr,                                            \
+                  Type, Value, Location); \
+      YYFPRINTF (stderr, "\n");                                           \
+    }                                                                     \
+} while (0)
+
+
+/*----------------------------------------.
+| Print this symbol's value on YYOUTPUT.  |
+`----------------------------------------*/
+
+static void
+yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep, YYLTYPE const * const yylocationp)
+{
+  FILE *yyo = yyoutput;
+  YYUSE (yyo);
+  YYUSE (yylocationp);
+  if (!yyvaluep)
+    return;
+# ifdef YYPRINT
+  if (yytype < YYNTOKENS)
+    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
+# endif
+  YYUSE (yytype);
+}
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+static void
+yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep, YYLTYPE const * const yylocationp)
+{
+  YYFPRINTF (yyoutput, "%s %s (",
+             yytype < YYNTOKENS ? "token" : "nterm", yytname[yytype]);
+
+  YY_LOCATION_PRINT (yyoutput, *yylocationp);
+  YYFPRINTF (yyoutput, ": ");
+  yy_symbol_value_print (yyoutput, yytype, yyvaluep, yylocationp);
+  YYFPRINTF (yyoutput, ")");
+}
+
+/*------------------------------------------------------------------.
+| yy_stack_print -- Print the state stack from its BOTTOM up to its |
+| TOP (included).                                                   |
+`------------------------------------------------------------------*/
+
+static void
+yy_stack_print (yytype_int16 *yybottom, yytype_int16 *yytop)
+{
+  YYFPRINTF (stderr, "Stack now");
+  for (; yybottom <= yytop; yybottom++)
+    {
+      int yybot = *yybottom;
+      YYFPRINTF (stderr, " %d", yybot);
+    }
+  YYFPRINTF (stderr, "\n");
+}
+
+# define YY_STACK_PRINT(Bottom, Top)                            \
+do {                                                            \
+  if (yydebug)                                                  \
+    yy_stack_print ((Bottom), (Top));                           \
+} while (0)
+
+
+/*------------------------------------------------.
+| Report that the YYRULE is going to be reduced.  |
+`------------------------------------------------*/
+
+static void
+yy_reduce_print (yytype_int16 *yyssp, YYSTYPE *yyvsp, YYLTYPE *yylsp, int yyrule)
+{
+  unsigned long int yylno = yyrline[yyrule];
+  int yynrhs = yyr2[yyrule];
+  int yyi;
+  YYFPRINTF (stderr, "Reducing stack by rule %d (line %lu):\n",
+             yyrule - 1, yylno);
+  /* The symbols being reduced.  */
+  for (yyi = 0; yyi < yynrhs; yyi++)
+    {
+      YYFPRINTF (stderr, "   $%d = ", yyi + 1);
+      yy_symbol_print (stderr,
+                       yystos[yyssp[yyi + 1 - yynrhs]],
+                       &(yyvsp[(yyi + 1) - (yynrhs)])
+                       , &(yylsp[(yyi + 1) - (yynrhs)])                       );
+      YYFPRINTF (stderr, "\n");
+    }
+}
+
+# define YY_REDUCE_PRINT(Rule)          \
+do {                                    \
+  if (yydebug)                          \
+    yy_reduce_print (yyssp, yyvsp, yylsp, Rule); \
+} while (0)
+
+/* Nonzero means print parse trace.  It is left uninitialized so that
+   multiple parsers can coexist.  */
+int yydebug;
+#else /* !YYDEBUG */
+# define YYDPRINTF(Args)
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
+# define YY_STACK_PRINT(Bottom, Top)
+# define YY_REDUCE_PRINT(Rule)
+#endif /* !YYDEBUG */
+
+
+/* YYINITDEPTH -- initial size of the parser's stacks.  */
+#ifndef YYINITDEPTH
+# define YYINITDEPTH 200
+#endif
+
+/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
+   if the built-in stack extension method is used).
+
+   Do not make this value too large; the results are undefined if
+   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
+   evaluated with infinite-precision integer arithmetic.  */
+
+#ifndef YYMAXDEPTH
+# define YYMAXDEPTH 10000
+#endif
+
+
+#if YYERROR_VERBOSE
+
+# ifndef yystrlen
+#  if defined __GLIBC__ && defined _STRING_H
+#   define yystrlen strlen
+#  else
+/* Return the length of YYSTR.  */
+static YYSIZE_T
+yystrlen (const char *yystr)
+{
+  YYSIZE_T yylen;
+  for (yylen = 0; yystr[yylen]; yylen++)
+    continue;
+  return yylen;
+}
+#  endif
+# endif
+
+# ifndef yystpcpy
+#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
+#   define yystpcpy stpcpy
+#  else
+/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
+   YYDEST.  */
+static char *
+yystpcpy (char *yydest, const char *yysrc)
+{
+  char *yyd = yydest;
+  const char *yys = yysrc;
+
+  while ((*yyd++ = *yys++) != '\0')
+    continue;
+
+  return yyd - 1;
+}
+#  endif
+# endif
+
+# ifndef yytnamerr
+/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
+   quotes and backslashes, so that it's suitable for yyerror.  The
+   heuristic is that double-quoting is unnecessary unless the string
+   contains an apostrophe, a comma, or backslash (other than
+   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
+   null, do not copy; instead, return the length of what the result
+   would have been.  */
+static YYSIZE_T
+yytnamerr (char *yyres, const char *yystr)
+{
+  if (*yystr == '"')
+    {
+      YYSIZE_T yyn = 0;
+      char const *yyp = yystr;
+
+      for (;;)
+        switch (*++yyp)
+          {
+          case '\'':
+          case ',':
+            goto do_not_strip_quotes;
+
+          case '\\':
+            if (*++yyp != '\\')
+              goto do_not_strip_quotes;
+            /* Fall through.  */
+          default:
+            if (yyres)
+              yyres[yyn] = *yyp;
+            yyn++;
+            break;
+
+          case '"':
+            if (yyres)
+              yyres[yyn] = '\0';
+            return yyn;
+          }
+    do_not_strip_quotes: ;
+    }
+
+  if (! yyres)
+    return yystrlen (yystr);
+
+  return yystpcpy (yyres, yystr) - yyres;
+}
+# endif
+
+/* Copy into *YYMSG, which is of size *YYMSG_ALLOC, an error message
+   about the unexpected token YYTOKEN for the state stack whose top is
+   YYSSP.
+
+   Return 0 if *YYMSG was successfully written.  Return 1 if *YYMSG is
+   not large enough to hold the message.  In that case, also set
+   *YYMSG_ALLOC to the required number of bytes.  Return 2 if the
+   required number of bytes is too large to store.  */
+static int
+yysyntax_error (YYSIZE_T *yymsg_alloc, char **yymsg,
+                yytype_int16 *yyssp, int yytoken)
+{
+  YYSIZE_T yysize0 = yytnamerr (YY_NULLPTR, yytname[yytoken]);
+  YYSIZE_T yysize = yysize0;
+  enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
+  /* Internationalized format string. */
+  const char *yyformat = YY_NULLPTR;
+  /* Arguments of yyformat. */
+  char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
+  /* Number of reported tokens (one for the "unexpected", one per
+     "expected"). */
+  int yycount = 0;
+
+  /* There are many possibilities here to consider:
+     - If this state is a consistent state with a default action, then
+       the only way this function was invoked is if the default action
+       is an error action.  In that case, don't check for expected
+       tokens because there are none.
+     - The only way there can be no lookahead present (in yychar) is if
+       this state is a consistent state with a default action.  Thus,
+       detecting the absence of a lookahead is sufficient to determine
+       that there is no unexpected or expected token to report.  In that
+       case, just report a simple "syntax error".
+     - Don't assume there isn't a lookahead just because this state is a
+       consistent state with a default action.  There might have been a
+       previous inconsistent state, consistent state with a non-default
+       action, or user semantic action that manipulated yychar.
+     - Of course, the expected token list depends on states to have
+       correct lookahead information, and it depends on the parser not
+       to perform extra reductions after fetching a lookahead from the
+       scanner and before detecting a syntax error.  Thus, state merging
+       (from LALR or IELR) and default reductions corrupt the expected
+       token list.  However, the list is correct for canonical LR with
+       one exception: it will still contain any token that will not be
+       accepted due to an error action in a later state.
+  */
+  if (yytoken != YYEMPTY)
+    {
+      int yyn = yypact[*yyssp];
+      yyarg[yycount++] = yytname[yytoken];
+      if (!yypact_value_is_default (yyn))
+        {
+          /* Start YYX at -YYN if negative to avoid negative indexes in
+             YYCHECK.  In other words, skip the first -YYN actions for
+             this state because they are default actions.  */
+          int yyxbegin = yyn < 0 ? -yyn : 0;
+          /* Stay within bounds of both yycheck and yytname.  */
+          int yychecklim = YYLAST - yyn + 1;
+          int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
+          int yyx;
+
+          for (yyx = yyxbegin; yyx < yyxend; ++yyx)
+            if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR
+                && !yytable_value_is_error (yytable[yyx + yyn]))
+              {
+                if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
+                  {
+                    yycount = 1;
+                    yysize = yysize0;
+                    break;
+                  }
+                yyarg[yycount++] = yytname[yyx];
+                {
+                  YYSIZE_T yysize1 = yysize + yytnamerr (YY_NULLPTR, yytname[yyx]);
+                  if (! (yysize <= yysize1
+                         && yysize1 <= YYSTACK_ALLOC_MAXIMUM))
+                    return 2;
+                  yysize = yysize1;
+                }
+              }
+        }
+    }
+
+  switch (yycount)
+    {
+# define YYCASE_(N, S)                      \
+      case N:                               \
+        yyformat = S;                       \
+      break
+      YYCASE_(0, YY_("syntax error"));
+      YYCASE_(1, YY_("syntax error, unexpected %s"));
+      YYCASE_(2, YY_("syntax error, unexpected %s, expecting %s"));
+      YYCASE_(3, YY_("syntax error, unexpected %s, expecting %s or %s"));
+      YYCASE_(4, YY_("syntax error, unexpected %s, expecting %s or %s or %s"));
+      YYCASE_(5, YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s"));
+# undef YYCASE_
+    }
+
+  {
+    YYSIZE_T yysize1 = yysize + yystrlen (yyformat);
+    if (! (yysize <= yysize1 && yysize1 <= YYSTACK_ALLOC_MAXIMUM))
+      return 2;
+    yysize = yysize1;
+  }
+
+  if (*yymsg_alloc < yysize)
+    {
+      *yymsg_alloc = 2 * yysize;
+      if (! (yysize <= *yymsg_alloc
+             && *yymsg_alloc <= YYSTACK_ALLOC_MAXIMUM))
+        *yymsg_alloc = YYSTACK_ALLOC_MAXIMUM;
+      return 1;
+    }
+
+  /* Avoid sprintf, as that infringes on the user's name space.
+     Don't have undefined behavior even if the translation
+     produced a string with the wrong number of "%s"s.  */
+  {
+    char *yyp = *yymsg;
+    int yyi = 0;
+    while ((*yyp = *yyformat) != '\0')
+      if (*yyp == '%' && yyformat[1] == 's' && yyi < yycount)
+        {
+          yyp += yytnamerr (yyp, yyarg[yyi++]);
+          yyformat += 2;
+        }
+      else
+        {
+          yyp++;
+          yyformat++;
+        }
+  }
+  return 0;
+}
+#endif /* YYERROR_VERBOSE */
+
+/*-----------------------------------------------.
+| Release the memory associated to this symbol.  |
+`-----------------------------------------------*/
+
+static void
+yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep, YYLTYPE *yylocationp)
+{
+  YYUSE (yyvaluep);
+  YYUSE (yylocationp);
+  if (!yymsg)
+    yymsg = "Deleting";
+  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
+
+  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+  YYUSE (yytype);
+  YY_IGNORE_MAYBE_UNINITIALIZED_END
+}
+
+
+
+
+/* The lookahead symbol.  */
+int yychar;
+
+/* The semantic value of the lookahead symbol.  */
+YYSTYPE yylval;
+/* Location data for the lookahead symbol.  */
+YYLTYPE yylloc
+# if defined YYLTYPE_IS_TRIVIAL && YYLTYPE_IS_TRIVIAL
+  = { 1, 1, 1, 1 }
+# endif
+;
+/* Number of syntax errors so far.  */
+int yynerrs;
+
+
+/*----------.
+| yyparse.  |
+`----------*/
+
+int
+yyparse (void)
+{
+    int yystate;
+    /* Number of tokens to shift before error messages enabled.  */
+    int yyerrstatus;
+
+    /* The stacks and their tools:
+       'yyss': related to states.
+       'yyvs': related to semantic values.
+       'yyls': related to locations.
+
+       Refer to the stacks through separate pointers, to allow yyoverflow
+       to reallocate them elsewhere.  */
+
+    /* The state stack.  */
+    yytype_int16 yyssa[YYINITDEPTH];
+    yytype_int16 *yyss;
+    yytype_int16 *yyssp;
+
+    /* The semantic value stack.  */
+    YYSTYPE yyvsa[YYINITDEPTH];
+    YYSTYPE *yyvs;
+    YYSTYPE *yyvsp;
+
+    /* The location stack.  */
+    YYLTYPE yylsa[YYINITDEPTH];
+    YYLTYPE *yyls;
+    YYLTYPE *yylsp;
+
+    /* The locations where the error started and ended.  */
+    YYLTYPE yyerror_range[3];
+
+    YYSIZE_T yystacksize;
+
+  int yyn;
+  int yyresult;
+  /* Lookahead token as an internal (translated) token number.  */
+  int yytoken = 0;
+  /* The variables used to return semantic value and location from the
+     action routines.  */
+  YYSTYPE yyval;
+  YYLTYPE yyloc;
+
+#if YYERROR_VERBOSE
+  /* Buffer for error messages, and its allocated size.  */
+  char yymsgbuf[128];
+  char *yymsg = yymsgbuf;
+  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
+#endif
+
+#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N), yylsp -= (N))
+
+  /* The number of symbols on the RHS of the reduced rule.
+     Keep to zero when no symbol should be popped.  */
+  int yylen = 0;
+
+  yyssp = yyss = yyssa;
+  yyvsp = yyvs = yyvsa;
+  yylsp = yyls = yylsa;
+  yystacksize = YYINITDEPTH;
+
+  YYDPRINTF ((stderr, "Starting parse\n"));
+
+  yystate = 0;
+  yyerrstatus = 0;
+  yynerrs = 0;
+  yychar = YYEMPTY; /* Cause a token to be read.  */
+  yylsp[0] = yylloc;
+  goto yysetstate;
+
+/*------------------------------------------------------------.
+| yynewstate -- Push a new state, which is found in yystate.  |
+`------------------------------------------------------------*/
+ yynewstate:
+  /* In all cases, when you get here, the value and location stacks
+     have just been pushed.  So pushing a state here evens the stacks.  */
+  yyssp++;
+
+ yysetstate:
+  *yyssp = yystate;
+
+  if (yyss + yystacksize - 1 <= yyssp)
+    {
+      /* Get the current used size of the three stacks, in elements.  */
+      YYSIZE_T yysize = yyssp - yyss + 1;
+
+#ifdef yyoverflow
+      {
+        /* Give user a chance to reallocate the stack.  Use copies of
+           these so that the &'s don't force the real ones into
+           memory.  */
+        YYSTYPE *yyvs1 = yyvs;
+        yytype_int16 *yyss1 = yyss;
+        YYLTYPE *yyls1 = yyls;
+
+        /* Each stack pointer address is followed by the size of the
+           data in use in that stack, in bytes.  This used to be a
+           conditional around just the two extra args, but that might
+           be undefined if yyoverflow is a macro.  */
+        yyoverflow (YY_("memory exhausted"),
+                    &yyss1, yysize * sizeof (*yyssp),
+                    &yyvs1, yysize * sizeof (*yyvsp),
+                    &yyls1, yysize * sizeof (*yylsp),
+                    &yystacksize);
+
+        yyls = yyls1;
+        yyss = yyss1;
+        yyvs = yyvs1;
+      }
+#else /* no yyoverflow */
+# ifndef YYSTACK_RELOCATE
+      goto yyexhaustedlab;
+# else
+      /* Extend the stack our own way.  */
+      if (YYMAXDEPTH <= yystacksize)
+        goto yyexhaustedlab;
+      yystacksize *= 2;
+      if (YYMAXDEPTH < yystacksize)
+        yystacksize = YYMAXDEPTH;
+
+      {
+        yytype_int16 *yyss1 = yyss;
+        union yyalloc *yyptr =
+          (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
+        if (! yyptr)
+          goto yyexhaustedlab;
+        YYSTACK_RELOCATE (yyss_alloc, yyss);
+        YYSTACK_RELOCATE (yyvs_alloc, yyvs);
+        YYSTACK_RELOCATE (yyls_alloc, yyls);
+#  undef YYSTACK_RELOCATE
+        if (yyss1 != yyssa)
+          YYSTACK_FREE (yyss1);
+      }
+# endif
+#endif /* no yyoverflow */
+
+      yyssp = yyss + yysize - 1;
+      yyvsp = yyvs + yysize - 1;
+      yylsp = yyls + yysize - 1;
+
+      YYDPRINTF ((stderr, "Stack size increased to %lu\n",
+                  (unsigned long int) yystacksize));
+
+      if (yyss + yystacksize - 1 <= yyssp)
+        YYABORT;
+    }
+
+  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
+
+  if (yystate == YYFINAL)
+    YYACCEPT;
+
+  goto yybackup;
+
+/*-----------.
+| yybackup.  |
+`-----------*/
+yybackup:
+
+  /* Do appropriate processing given the current state.  Read a
+     lookahead token if we need one and don't already have one.  */
+
+  /* First try to decide what to do without reference to lookahead token.  */
+  yyn = yypact[yystate];
+  if (yypact_value_is_default (yyn))
+    goto yydefault;
+
+  /* Not known => get a lookahead token if don't already have one.  */
+
+  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
+  if (yychar == YYEMPTY)
+    {
+      YYDPRINTF ((stderr, "Reading a token: "));
+      yychar = yylex ();
+    }
+
+  if (yychar <= YYEOF)
+    {
+      yychar = yytoken = YYEOF;
+      YYDPRINTF ((stderr, "Now at end of input.\n"));
+    }
+  else
+    {
+      yytoken = YYTRANSLATE (yychar);
+      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
+    }
+
+  /* If the proper action on seeing token YYTOKEN is to reduce or to
+     detect an error, take that action.  */
+  yyn += yytoken;
+  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
+    goto yydefault;
+  yyn = yytable[yyn];
+  if (yyn <= 0)
+    {
+      if (yytable_value_is_error (yyn))
+        goto yyerrlab;
+      yyn = -yyn;
+      goto yyreduce;
+    }
+
+  /* Count tokens shifted since error; after three, turn off error
+     status.  */
+  if (yyerrstatus)
+    yyerrstatus--;
+
+  /* Shift the lookahead token.  */
+  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
+
+  /* Discard the shifted token.  */
+  yychar = YYEMPTY;
+
+  yystate = yyn;
+  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+  *++yyvsp = yylval;
+  YY_IGNORE_MAYBE_UNINITIALIZED_END
+  *++yylsp = yylloc;
+  goto yynewstate;
+
+
+/*-----------------------------------------------------------.
+| yydefault -- do the default action for the current state.  |
+`-----------------------------------------------------------*/
+yydefault:
+  yyn = yydefact[yystate];
+  if (yyn == 0)
+    goto yyerrlab;
+  goto yyreduce;
+
+
+/*-----------------------------.
+| yyreduce -- Do a reduction.  |
+`-----------------------------*/
+yyreduce:
+  /* yyn is the number of a rule to reduce with.  */
+  yylen = yyr2[yyn];
+
+  /* If YYLEN is nonzero, implement the default value of the action:
+     '$$ = $1'.
+
+     Otherwise, the following line sets YYVAL to garbage.
+     This behavior is undocumented and Bison
+     users should not rely upon it.  Assigning to YYVAL
+     unconditionally makes the parser a bit smaller, and it avoids a
+     GCC warning that YYVAL may be used uninitialized.  */
+  yyval = yyvsp[1-yylen];
+
+  /* Default location.  */
+  YYLLOC_DEFAULT (yyloc, (yylsp - yylen), yylen);
+  YY_REDUCE_PRINT (yyn);
+  switch (yyn)
+    {
+        case 2:
+#line 110 "dtc-parser.y" /* yacc.c:1646  */
+    {
+			parser_output = build_dt_info((yyvsp[-2].flags), (yyvsp[-1].re), (yyvsp[0].node),
+			                              guess_boot_cpuid((yyvsp[0].node)));
+		}
+#line 1476 "dtc-parser.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 3:
+#line 118 "dtc-parser.y" /* yacc.c:1646  */
+    {
+			(yyval.flags) = DTSF_V1;
+		}
+#line 1484 "dtc-parser.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 4:
+#line 122 "dtc-parser.y" /* yacc.c:1646  */
+    {
+			(yyval.flags) = DTSF_V1 | DTSF_PLUGIN;
+		}
+#line 1492 "dtc-parser.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 6:
+#line 130 "dtc-parser.y" /* yacc.c:1646  */
+    {
+			if ((yyvsp[0].flags) != (yyvsp[-1].flags))
+				ERROR(&(yylsp[0]), "Header flags don't match earlier ones");
+			(yyval.flags) = (yyvsp[-1].flags);
+		}
+#line 1502 "dtc-parser.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 7:
+#line 139 "dtc-parser.y" /* yacc.c:1646  */
+    {
+			(yyval.re) = NULL;
+		}
+#line 1510 "dtc-parser.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 8:
+#line 143 "dtc-parser.y" /* yacc.c:1646  */
+    {
+			(yyval.re) = chain_reserve_entry((yyvsp[-1].re), (yyvsp[0].re));
+		}
+#line 1518 "dtc-parser.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 9:
+#line 150 "dtc-parser.y" /* yacc.c:1646  */
+    {
+			(yyval.re) = build_reserve_entry((yyvsp[-2].integer), (yyvsp[-1].integer));
+		}
+#line 1526 "dtc-parser.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 10:
+#line 154 "dtc-parser.y" /* yacc.c:1646  */
+    {
+			add_label(&(yyvsp[0].re)->labels, (yyvsp[-1].labelref));
+			(yyval.re) = (yyvsp[0].re);
+		}
+#line 1535 "dtc-parser.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 11:
+#line 162 "dtc-parser.y" /* yacc.c:1646  */
+    {
+			(yyval.node) = name_node((yyvsp[0].node), "");
+		}
+#line 1543 "dtc-parser.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 12:
+#line 166 "dtc-parser.y" /* yacc.c:1646  */
+    {
+			(yyval.node) = merge_nodes((yyvsp[-2].node), (yyvsp[0].node));
+		}
+#line 1551 "dtc-parser.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 13:
+#line 171 "dtc-parser.y" /* yacc.c:1646  */
+    {
+			struct node *target = get_node_by_ref((yyvsp[-3].node), (yyvsp[-1].labelref));
+
+			if (target) {
+				add_label(&target->labels, (yyvsp[-2].labelref));
+				merge_nodes(target, (yyvsp[0].node));
+			} else
+				ERROR(&(yylsp[-1]), "Label or path %s not found", (yyvsp[-1].labelref));
+			(yyval.node) = (yyvsp[-3].node);
+		}
+#line 1566 "dtc-parser.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 14:
+#line 182 "dtc-parser.y" /* yacc.c:1646  */
+    {
+			struct node *target = get_node_by_ref((yyvsp[-2].node), (yyvsp[-1].labelref));
+
+			if (target)
+				merge_nodes(target, (yyvsp[0].node));
+			else
+				ERROR(&(yylsp[-1]), "Label or path %s not found", (yyvsp[-1].labelref));
+			(yyval.node) = (yyvsp[-2].node);
+		}
+#line 1580 "dtc-parser.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 15:
+#line 192 "dtc-parser.y" /* yacc.c:1646  */
+    {
+			struct node *target = get_node_by_ref((yyvsp[-3].node), (yyvsp[-1].labelref));
+
+			if (target)
+				delete_node(target);
+			else
+				ERROR(&(yylsp[-1]), "Label or path %s not found", (yyvsp[-1].labelref));
+
+
+			(yyval.node) = (yyvsp[-3].node);
+		}
+#line 1596 "dtc-parser.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 16:
+#line 207 "dtc-parser.y" /* yacc.c:1646  */
+    {
+			(yyval.node) = build_node((yyvsp[-3].proplist), (yyvsp[-2].nodelist));
+		}
+#line 1604 "dtc-parser.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 17:
+#line 214 "dtc-parser.y" /* yacc.c:1646  */
+    {
+			(yyval.proplist) = NULL;
+		}
+#line 1612 "dtc-parser.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 18:
+#line 218 "dtc-parser.y" /* yacc.c:1646  */
+    {
+			(yyval.proplist) = chain_property((yyvsp[0].prop), (yyvsp[-1].proplist));
+		}
+#line 1620 "dtc-parser.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 19:
+#line 225 "dtc-parser.y" /* yacc.c:1646  */
+    {
+			(yyval.prop) = build_property((yyvsp[-3].propnodename), (yyvsp[-1].data));
+		}
+#line 1628 "dtc-parser.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 20:
+#line 229 "dtc-parser.y" /* yacc.c:1646  */
+    {
+			(yyval.prop) = build_property((yyvsp[-1].propnodename), empty_data);
+		}
+#line 1636 "dtc-parser.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 21:
+#line 233 "dtc-parser.y" /* yacc.c:1646  */
+    {
+			(yyval.prop) = build_property_delete((yyvsp[-1].propnodename));
+		}
+#line 1644 "dtc-parser.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 22:
+#line 237 "dtc-parser.y" /* yacc.c:1646  */
+    {
+			add_label(&(yyvsp[0].prop)->labels, (yyvsp[-1].labelref));
+			(yyval.prop) = (yyvsp[0].prop);
+		}
+#line 1653 "dtc-parser.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 23:
+#line 245 "dtc-parser.y" /* yacc.c:1646  */
+    {
+			(yyval.data) = data_merge((yyvsp[-1].data), (yyvsp[0].data));
+		}
+#line 1661 "dtc-parser.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 24:
+#line 249 "dtc-parser.y" /* yacc.c:1646  */
+    {
+			(yyval.data) = data_merge((yyvsp[-2].data), (yyvsp[-1].array).data);
+		}
+#line 1669 "dtc-parser.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 25:
+#line 253 "dtc-parser.y" /* yacc.c:1646  */
+    {
+			(yyval.data) = data_merge((yyvsp[-3].data), (yyvsp[-1].data));
+		}
+#line 1677 "dtc-parser.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 26:
+#line 257 "dtc-parser.y" /* yacc.c:1646  */
+    {
+			(yyval.data) = data_add_marker((yyvsp[-1].data), REF_PATH, (yyvsp[0].labelref));
+		}
+#line 1685 "dtc-parser.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 27:
+#line 261 "dtc-parser.y" /* yacc.c:1646  */
+    {
+			FILE *f = srcfile_relative_open((yyvsp[-5].data).val, NULL);
+			struct data d;
+
+			if ((yyvsp[-3].integer) != 0)
+				if (fseek(f, (yyvsp[-3].integer), SEEK_SET) != 0)
+					die("Couldn't seek to offset %llu in \"%s\": %s",
+					    (unsigned long long)(yyvsp[-3].integer), (yyvsp[-5].data).val,
+					    strerror(errno));
+
+			d = data_copy_file(f, (yyvsp[-1].integer));
+
+			(yyval.data) = data_merge((yyvsp[-8].data), d);
+			fclose(f);
+		}
+#line 1705 "dtc-parser.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 28:
+#line 277 "dtc-parser.y" /* yacc.c:1646  */
+    {
+			FILE *f = srcfile_relative_open((yyvsp[-1].data).val, NULL);
+			struct data d = empty_data;
+
+			d = data_copy_file(f, -1);
+
+			(yyval.data) = data_merge((yyvsp[-4].data), d);
+			fclose(f);
+		}
+#line 1719 "dtc-parser.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 29:
+#line 287 "dtc-parser.y" /* yacc.c:1646  */
+    {
+			(yyval.data) = data_add_marker((yyvsp[-1].data), LABEL, (yyvsp[0].labelref));
+		}
+#line 1727 "dtc-parser.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 30:
+#line 294 "dtc-parser.y" /* yacc.c:1646  */
+    {
+			(yyval.data) = empty_data;
+		}
+#line 1735 "dtc-parser.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 31:
+#line 298 "dtc-parser.y" /* yacc.c:1646  */
+    {
+			(yyval.data) = (yyvsp[-1].data);
+		}
+#line 1743 "dtc-parser.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 32:
+#line 302 "dtc-parser.y" /* yacc.c:1646  */
+    {
+			(yyval.data) = data_add_marker((yyvsp[-1].data), LABEL, (yyvsp[0].labelref));
+		}
+#line 1751 "dtc-parser.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 33:
+#line 309 "dtc-parser.y" /* yacc.c:1646  */
+    {
+			unsigned long long bits;
+
+			bits = (yyvsp[-1].integer);
+
+			if ((bits !=  8) && (bits != 16) &&
+			    (bits != 32) && (bits != 64)) {
+				ERROR(&(yylsp[-1]), "Array elements must be"
+				      " 8, 16, 32 or 64-bits");
+				bits = 32;
+			}
+
+			(yyval.array).data = empty_data;
+			(yyval.array).bits = bits;
+		}
+#line 1771 "dtc-parser.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 34:
+#line 325 "dtc-parser.y" /* yacc.c:1646  */
+    {
+			(yyval.array).data = empty_data;
+			(yyval.array).bits = 32;
+		}
+#line 1780 "dtc-parser.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 35:
+#line 330 "dtc-parser.y" /* yacc.c:1646  */
+    {
+			if ((yyvsp[-1].array).bits < 64) {
+				uint64_t mask = (1ULL << (yyvsp[-1].array).bits) - 1;
+				/*
+				 * Bits above mask must either be all zero
+				 * (positive within range of mask) or all one
+				 * (negative and sign-extended). The second
+				 * condition is true if when we set all bits
+				 * within the mask to one (i.e. | in the
+				 * mask), all bits are one.
+				 */
+				if (((yyvsp[0].integer) > mask) && (((yyvsp[0].integer) | mask) != -1ULL))
+					ERROR(&(yylsp[0]), "Value out of range for"
+					      " %d-bit array element", (yyvsp[-1].array).bits);
+			}
+
+			(yyval.array).data = data_append_integer((yyvsp[-1].array).data, (yyvsp[0].integer), (yyvsp[-1].array).bits);
+		}
+#line 1803 "dtc-parser.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 36:
+#line 349 "dtc-parser.y" /* yacc.c:1646  */
+    {
+			uint64_t val = ~0ULL >> (64 - (yyvsp[-1].array).bits);
+
+			if ((yyvsp[-1].array).bits == 32)
+				(yyvsp[-1].array).data = data_add_marker((yyvsp[-1].array).data,
+							  REF_PHANDLE,
+							  (yyvsp[0].labelref));
+			else
+				ERROR(&(yylsp[0]), "References are only allowed in "
+					    "arrays with 32-bit elements.");
+
+			(yyval.array).data = data_append_integer((yyvsp[-1].array).data, val, (yyvsp[-1].array).bits);
+		}
+#line 1821 "dtc-parser.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 37:
+#line 363 "dtc-parser.y" /* yacc.c:1646  */
+    {
+			(yyval.array).data = data_add_marker((yyvsp[-1].array).data, LABEL, (yyvsp[0].labelref));
+		}
+#line 1829 "dtc-parser.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 40:
+#line 372 "dtc-parser.y" /* yacc.c:1646  */
+    {
+			(yyval.integer) = (yyvsp[-1].integer);
+		}
+#line 1837 "dtc-parser.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 43:
+#line 383 "dtc-parser.y" /* yacc.c:1646  */
+    { (yyval.integer) = (yyvsp[-4].integer) ? (yyvsp[-2].integer) : (yyvsp[0].integer); }
+#line 1843 "dtc-parser.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 45:
+#line 388 "dtc-parser.y" /* yacc.c:1646  */
+    { (yyval.integer) = (yyvsp[-2].integer) || (yyvsp[0].integer); }
+#line 1849 "dtc-parser.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 47:
+#line 393 "dtc-parser.y" /* yacc.c:1646  */
+    { (yyval.integer) = (yyvsp[-2].integer) && (yyvsp[0].integer); }
+#line 1855 "dtc-parser.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 49:
+#line 398 "dtc-parser.y" /* yacc.c:1646  */
+    { (yyval.integer) = (yyvsp[-2].integer) | (yyvsp[0].integer); }
+#line 1861 "dtc-parser.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 51:
+#line 403 "dtc-parser.y" /* yacc.c:1646  */
+    { (yyval.integer) = (yyvsp[-2].integer) ^ (yyvsp[0].integer); }
+#line 1867 "dtc-parser.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 53:
+#line 408 "dtc-parser.y" /* yacc.c:1646  */
+    { (yyval.integer) = (yyvsp[-2].integer) & (yyvsp[0].integer); }
+#line 1873 "dtc-parser.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 55:
+#line 413 "dtc-parser.y" /* yacc.c:1646  */
+    { (yyval.integer) = (yyvsp[-2].integer) == (yyvsp[0].integer); }
+#line 1879 "dtc-parser.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 56:
+#line 414 "dtc-parser.y" /* yacc.c:1646  */
+    { (yyval.integer) = (yyvsp[-2].integer) != (yyvsp[0].integer); }
+#line 1885 "dtc-parser.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 58:
+#line 419 "dtc-parser.y" /* yacc.c:1646  */
+    { (yyval.integer) = (yyvsp[-2].integer) < (yyvsp[0].integer); }
+#line 1891 "dtc-parser.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 59:
+#line 420 "dtc-parser.y" /* yacc.c:1646  */
+    { (yyval.integer) = (yyvsp[-2].integer) > (yyvsp[0].integer); }
+#line 1897 "dtc-parser.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 60:
+#line 421 "dtc-parser.y" /* yacc.c:1646  */
+    { (yyval.integer) = (yyvsp[-2].integer) <= (yyvsp[0].integer); }
+#line 1903 "dtc-parser.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 61:
+#line 422 "dtc-parser.y" /* yacc.c:1646  */
+    { (yyval.integer) = (yyvsp[-2].integer) >= (yyvsp[0].integer); }
+#line 1909 "dtc-parser.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 62:
+#line 426 "dtc-parser.y" /* yacc.c:1646  */
+    { (yyval.integer) = (yyvsp[-2].integer) << (yyvsp[0].integer); }
+#line 1915 "dtc-parser.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 63:
+#line 427 "dtc-parser.y" /* yacc.c:1646  */
+    { (yyval.integer) = (yyvsp[-2].integer) >> (yyvsp[0].integer); }
+#line 1921 "dtc-parser.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 65:
+#line 432 "dtc-parser.y" /* yacc.c:1646  */
+    { (yyval.integer) = (yyvsp[-2].integer) + (yyvsp[0].integer); }
+#line 1927 "dtc-parser.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 66:
+#line 433 "dtc-parser.y" /* yacc.c:1646  */
+    { (yyval.integer) = (yyvsp[-2].integer) - (yyvsp[0].integer); }
+#line 1933 "dtc-parser.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 68:
+#line 438 "dtc-parser.y" /* yacc.c:1646  */
+    { (yyval.integer) = (yyvsp[-2].integer) * (yyvsp[0].integer); }
+#line 1939 "dtc-parser.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 69:
+#line 440 "dtc-parser.y" /* yacc.c:1646  */
+    {
+			if ((yyvsp[0].integer) != 0) {
+				(yyval.integer) = (yyvsp[-2].integer) / (yyvsp[0].integer);
+			} else {
+				ERROR(&(yyloc), "Division by zero");
+				(yyval.integer) = 0;
+			}
+		}
+#line 1952 "dtc-parser.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 70:
+#line 449 "dtc-parser.y" /* yacc.c:1646  */
+    {
+			if ((yyvsp[0].integer) != 0) {
+				(yyval.integer) = (yyvsp[-2].integer) % (yyvsp[0].integer);
+			} else {
+				ERROR(&(yyloc), "Division by zero");
+				(yyval.integer) = 0;
+			}
+		}
+#line 1965 "dtc-parser.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 73:
+#line 462 "dtc-parser.y" /* yacc.c:1646  */
+    { (yyval.integer) = -(yyvsp[0].integer); }
+#line 1971 "dtc-parser.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 74:
+#line 463 "dtc-parser.y" /* yacc.c:1646  */
+    { (yyval.integer) = ~(yyvsp[0].integer); }
+#line 1977 "dtc-parser.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 75:
+#line 464 "dtc-parser.y" /* yacc.c:1646  */
+    { (yyval.integer) = !(yyvsp[0].integer); }
+#line 1983 "dtc-parser.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 76:
+#line 469 "dtc-parser.y" /* yacc.c:1646  */
+    {
+			(yyval.data) = empty_data;
+		}
+#line 1991 "dtc-parser.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 77:
+#line 473 "dtc-parser.y" /* yacc.c:1646  */
+    {
+			(yyval.data) = data_append_byte((yyvsp[-1].data), (yyvsp[0].byte));
+		}
+#line 1999 "dtc-parser.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 78:
+#line 477 "dtc-parser.y" /* yacc.c:1646  */
+    {
+			(yyval.data) = data_add_marker((yyvsp[-1].data), LABEL, (yyvsp[0].labelref));
+		}
+#line 2007 "dtc-parser.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 79:
+#line 484 "dtc-parser.y" /* yacc.c:1646  */
+    {
+			(yyval.nodelist) = NULL;
+		}
+#line 2015 "dtc-parser.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 80:
+#line 488 "dtc-parser.y" /* yacc.c:1646  */
+    {
+			(yyval.nodelist) = chain_node((yyvsp[-1].node), (yyvsp[0].nodelist));
+		}
+#line 2023 "dtc-parser.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 81:
+#line 492 "dtc-parser.y" /* yacc.c:1646  */
+    {
+			ERROR(&(yylsp[0]), "Properties must precede subnodes");
+			YYERROR;
+		}
+#line 2032 "dtc-parser.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 82:
+#line 500 "dtc-parser.y" /* yacc.c:1646  */
+    {
+			(yyval.node) = name_node((yyvsp[0].node), (yyvsp[-1].propnodename));
+		}
+#line 2040 "dtc-parser.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 83:
+#line 504 "dtc-parser.y" /* yacc.c:1646  */
+    {
+			(yyval.node) = name_node(build_node_delete(), (yyvsp[-1].propnodename));
+		}
+#line 2048 "dtc-parser.tab.c" /* yacc.c:1646  */
+    break;
+
+  case 84:
+#line 508 "dtc-parser.y" /* yacc.c:1646  */
+    {
+			add_label(&(yyvsp[0].node)->labels, (yyvsp[-1].labelref));
+			(yyval.node) = (yyvsp[0].node);
+		}
+#line 2057 "dtc-parser.tab.c" /* yacc.c:1646  */
+    break;
+
+
+#line 2061 "dtc-parser.tab.c" /* yacc.c:1646  */
+      default: break;
+    }
+  /* User semantic actions sometimes alter yychar, and that requires
+     that yytoken be updated with the new translation.  We take the
+     approach of translating immediately before every use of yytoken.
+     One alternative is translating here after every semantic action,
+     but that translation would be missed if the semantic action invokes
+     YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or
+     if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an
+     incorrect destructor might then be invoked immediately.  In the
+     case of YYERROR or YYBACKUP, subsequent parser actions might lead
+     to an incorrect destructor call or verbose syntax error message
+     before the lookahead is translated.  */
+  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
+
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+
+  *++yyvsp = yyval;
+  *++yylsp = yyloc;
+
+  /* Now 'shift' the result of the reduction.  Determine what state
+     that goes to, based on the state we popped back to and the rule
+     number reduced by.  */
+
+  yyn = yyr1[yyn];
+
+  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
+  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
+    yystate = yytable[yystate];
+  else
+    yystate = yydefgoto[yyn - YYNTOKENS];
+
+  goto yynewstate;
+
+
+/*--------------------------------------.
+| yyerrlab -- here on detecting error.  |
+`--------------------------------------*/
+yyerrlab:
+  /* Make sure we have latest lookahead translation.  See comments at
+     user semantic actions for why this is necessary.  */
+  yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);
+
+  /* If not already recovering from an error, report this error.  */
+  if (!yyerrstatus)
+    {
+      ++yynerrs;
+#if ! YYERROR_VERBOSE
+      yyerror (YY_("syntax error"));
+#else
+# define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \
+                                        yyssp, yytoken)
+      {
+        char const *yymsgp = YY_("syntax error");
+        int yysyntax_error_status;
+        yysyntax_error_status = YYSYNTAX_ERROR;
+        if (yysyntax_error_status == 0)
+          yymsgp = yymsg;
+        else if (yysyntax_error_status == 1)
+          {
+            if (yymsg != yymsgbuf)
+              YYSTACK_FREE (yymsg);
+            yymsg = (char *) YYSTACK_ALLOC (yymsg_alloc);
+            if (!yymsg)
+              {
+                yymsg = yymsgbuf;
+                yymsg_alloc = sizeof yymsgbuf;
+                yysyntax_error_status = 2;
+              }
+            else
+              {
+                yysyntax_error_status = YYSYNTAX_ERROR;
+                yymsgp = yymsg;
+              }
+          }
+        yyerror (yymsgp);
+        if (yysyntax_error_status == 2)
+          goto yyexhaustedlab;
+      }
+# undef YYSYNTAX_ERROR
+#endif
+    }
+
+  yyerror_range[1] = yylloc;
+
+  if (yyerrstatus == 3)
+    {
+      /* If just tried and failed to reuse lookahead token after an
+         error, discard it.  */
+
+      if (yychar <= YYEOF)
+        {
+          /* Return failure if at end of input.  */
+          if (yychar == YYEOF)
+            YYABORT;
+        }
+      else
+        {
+          yydestruct ("Error: discarding",
+                      yytoken, &yylval, &yylloc);
+          yychar = YYEMPTY;
+        }
+    }
+
+  /* Else will try to reuse lookahead token after shifting the error
+     token.  */
+  goto yyerrlab1;
+
+
+/*---------------------------------------------------.
+| yyerrorlab -- error raised explicitly by YYERROR.  |
+`---------------------------------------------------*/
+yyerrorlab:
+
+  /* Pacify compilers like GCC when the user code never invokes
+     YYERROR and the label yyerrorlab therefore never appears in user
+     code.  */
+  if (/*CONSTCOND*/ 0)
+     goto yyerrorlab;
+
+  yyerror_range[1] = yylsp[1-yylen];
+  /* Do not reclaim the symbols of the rule whose action triggered
+     this YYERROR.  */
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+  yystate = *yyssp;
+  goto yyerrlab1;
+
+
+/*-------------------------------------------------------------.
+| yyerrlab1 -- common code for both syntax error and YYERROR.  |
+`-------------------------------------------------------------*/
+yyerrlab1:
+  yyerrstatus = 3;      /* Each real token shifted decrements this.  */
+
+  for (;;)
+    {
+      yyn = yypact[yystate];
+      if (!yypact_value_is_default (yyn))
+        {
+          yyn += YYTERROR;
+          if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
+            {
+              yyn = yytable[yyn];
+              if (0 < yyn)
+                break;
+            }
+        }
+
+      /* Pop the current state because it cannot handle the error token.  */
+      if (yyssp == yyss)
+        YYABORT;
+
+      yyerror_range[1] = *yylsp;
+      yydestruct ("Error: popping",
+                  yystos[yystate], yyvsp, yylsp);
+      YYPOPSTACK (1);
+      yystate = *yyssp;
+      YY_STACK_PRINT (yyss, yyssp);
+    }
+
+  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+  *++yyvsp = yylval;
+  YY_IGNORE_MAYBE_UNINITIALIZED_END
+
+  yyerror_range[2] = yylloc;
+  /* Using YYLLOC is tempting, but would change the location of
+     the lookahead.  YYLOC is available though.  */
+  YYLLOC_DEFAULT (yyloc, yyerror_range, 2);
+  *++yylsp = yyloc;
+
+  /* Shift the error token.  */
+  YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);
+
+  yystate = yyn;
+  goto yynewstate;
+
+
+/*-------------------------------------.
+| yyacceptlab -- YYACCEPT comes here.  |
+`-------------------------------------*/
+yyacceptlab:
+  yyresult = 0;
+  goto yyreturn;
+
+/*-----------------------------------.
+| yyabortlab -- YYABORT comes here.  |
+`-----------------------------------*/
+yyabortlab:
+  yyresult = 1;
+  goto yyreturn;
+
+#if !defined yyoverflow || YYERROR_VERBOSE
+/*-------------------------------------------------.
+| yyexhaustedlab -- memory exhaustion comes here.  |
+`-------------------------------------------------*/
+yyexhaustedlab:
+  yyerror (YY_("memory exhausted"));
+  yyresult = 2;
+  /* Fall through.  */
+#endif
+
+yyreturn:
+  if (yychar != YYEMPTY)
+    {
+      /* Make sure we have latest lookahead translation.  See comments at
+         user semantic actions for why this is necessary.  */
+      yytoken = YYTRANSLATE (yychar);
+      yydestruct ("Cleanup: discarding lookahead",
+                  yytoken, &yylval, &yylloc);
+    }
+  /* Do not reclaim the symbols of the rule whose action triggered
+     this YYABORT or YYACCEPT.  */
+  YYPOPSTACK (yylen);
+  YY_STACK_PRINT (yyss, yyssp);
+  while (yyssp != yyss)
+    {
+      yydestruct ("Cleanup: popping",
+                  yystos[*yyssp], yyvsp, yylsp);
+      YYPOPSTACK (1);
+    }
+#ifndef yyoverflow
+  if (yyss != yyssa)
+    YYSTACK_FREE (yyss);
+#endif
+#if YYERROR_VERBOSE
+  if (yymsg != yymsgbuf)
+    YYSTACK_FREE (yymsg);
+#endif
+  return yyresult;
+}
+#line 514 "dtc-parser.y" /* yacc.c:1906  */
+
+
+void yyerror(char const *s)
+{
+	ERROR(&yylloc, "%s", s);
+}
diff -urN u-boot-2017.11/scripts/dtc/dtc-parser.tab.h u-boot-2017.11-itop4412/scripts/dtc/dtc-parser.tab.h
--- u-boot-2017.11/scripts/dtc/dtc-parser.tab.h	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-2017.11-itop4412/scripts/dtc/dtc-parser.tab.h	2019-02-16 09:37:36.000000000 +0800
@@ -0,0 +1,123 @@
+/* A Bison parser, made by GNU Bison 3.0.2.  */
+
+/* Bison interface for Yacc-like parsers in C
+
+   Copyright (C) 1984, 1989-1990, 2000-2013 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+#ifndef YY_YY_DTC_PARSER_TAB_H_INCLUDED
+# define YY_YY_DTC_PARSER_TAB_H_INCLUDED
+/* Debug traces.  */
+#ifndef YYDEBUG
+# define YYDEBUG 0
+#endif
+#if YYDEBUG
+extern int yydebug;
+#endif
+
+/* Token type.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+  enum yytokentype
+  {
+    DT_V1 = 258,
+    DT_PLUGIN = 259,
+    DT_MEMRESERVE = 260,
+    DT_LSHIFT = 261,
+    DT_RSHIFT = 262,
+    DT_LE = 263,
+    DT_GE = 264,
+    DT_EQ = 265,
+    DT_NE = 266,
+    DT_AND = 267,
+    DT_OR = 268,
+    DT_BITS = 269,
+    DT_DEL_PROP = 270,
+    DT_DEL_NODE = 271,
+    DT_PROPNODENAME = 272,
+    DT_LITERAL = 273,
+    DT_CHAR_LITERAL = 274,
+    DT_BYTE = 275,
+    DT_STRING = 276,
+    DT_LABEL = 277,
+    DT_REF = 278,
+    DT_INCBIN = 279
+  };
+#endif
+
+/* Value type.  */
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef union YYSTYPE YYSTYPE;
+union YYSTYPE
+{
+#line 39 "dtc-parser.y" /* yacc.c:1909  */
+
+	char *propnodename;
+	char *labelref;
+	uint8_t byte;
+	struct data data;
+
+	struct {
+		struct data	data;
+		int		bits;
+	} array;
+
+	struct property *prop;
+	struct property *proplist;
+	struct node *node;
+	struct node *nodelist;
+	struct reserve_info *re;
+	uint64_t integer;
+	unsigned int flags;
+
+#line 99 "dtc-parser.tab.h" /* yacc.c:1909  */
+};
+# define YYSTYPE_IS_TRIVIAL 1
+# define YYSTYPE_IS_DECLARED 1
+#endif
+
+/* Location type.  */
+#if ! defined YYLTYPE && ! defined YYLTYPE_IS_DECLARED
+typedef struct YYLTYPE YYLTYPE;
+struct YYLTYPE
+{
+  int first_line;
+  int first_column;
+  int last_line;
+  int last_column;
+};
+# define YYLTYPE_IS_DECLARED 1
+# define YYLTYPE_IS_TRIVIAL 1
+#endif
+
+
+extern YYSTYPE yylval;
+extern YYLTYPE yylloc;
+int yyparse (void);
+
+#endif /* !YY_YY_DTC_PARSER_TAB_H_INCLUDED  */
Binary files u-boot-2017.11/scripts/kconfig/conf and u-boot-2017.11-itop4412/scripts/kconfig/conf differ
Binary files u-boot-2017.11/scripts/kconfig/mconf and u-boot-2017.11-itop4412/scripts/kconfig/mconf differ
